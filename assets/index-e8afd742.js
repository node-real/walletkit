var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _focused, _cleanup, _setup, _a2, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _dispatch, dispatch_fn, _d, _queries, _e, _observers, _mutationCache, _retryer2, _dispatch2, dispatch_fn2, _f, _mutations, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client, _currentResult, _currentMutation, _mutateOptions, _updateResult, updateResult_fn, _notify, notify_fn, _i, _names, _data, _dataLength, _writeData, writeData_fn, _data2, _offset, _bytesRead, _parent, _maxInflation, _incrementBytesRead, incrementBytesRead_fn, _peekBytes, peekBytes_fn, _r, _s, _v, _networkV, _privateKey, _options, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _getSerialized, getSerialized_fn, _j, _types, _fullTypes, _encoderCache, _getEncoder, getEncoder_fn, _k, _offset2, _tokens, _subTokenString, subTokenString_fn, _l, _walkAsync, walkAsync_fn, _m, _getCoder, getCoder_fn, _throwUnsupported, throwUnsupported_fn, _signingKey, _data4, _checksum, _words, _loadWords, loadWords_fn, _account, account_fn, _fromSeed, fromSeed_fn, _offset3, _tokens2, _subTokenString2, subTokenString_fn2, _walkAsync2, walkAsync_fn2, _errors, _events, _functions, _abiCoder, _getFunction, getFunction_fn, _getEvent, getEvent_fn, _types2, _fullTypes2, _encoderCache2, _getEncoder2, getEncoder_fn2;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$4 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A$1(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$1 && a[z$1] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d, c = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d) && !L$1.hasOwnProperty(d) && (c[d] = b2[d]);
  var g = arguments.length - 2;
  if (1 === g)
    c.children = e2;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++)
      f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps)
    for (d in g = a.defaultProps, g)
      void 0 === c[d] && (c[d] = g[d]);
  return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c, _owner: K$1.current };
}
function N$2(a, b2) {
  return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$2;
}
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e2, d, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$2:
          case n$4:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c = c(h2), a = "" === d ? "." + Q$1(h2, 0) : d, I$1(c) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c, b2, e2, "", function(a2) {
      return a2;
    })) : null != c && (O$1(c) && (c = N$2(c, e2 + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b2.push(c)), 1;
  h2 = 0;
  d = "" === d ? "." : d + ":";
  if (I$1(a))
    for (var g = 0; g < a.length; g++) {
      k2 = a[g];
      var f2 = d + Q$1(k2, g);
      h2 += R$1(k2, b2, e2, f2, c);
    }
  else if (f2 = A$1(a), "function" === typeof f2)
    for (a = f2.call(a), g = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d + Q$1(k2, g++), h2 += R$1(k2, b2, e2, f2, c);
  else if ("object" === k2)
    throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a, b2, e2) {
  if (null == a)
    return a;
  var d = [], c = 0;
  R$1(a, d, "", "", function(a2) {
    return b2.call(e2, a2, c++);
  });
  return d;
}
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$2, forEach: function(a, b2, e2) {
  S$2(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$2(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$2(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C$1({}, a.props), c = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c = "" + b2.key);
    if (a.type && a.type.defaultProps)
      var g = a.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = void 0 === b2[f2] && void 0 !== g ? g[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d.children = e2;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g[m2] = arguments[m2 + 2];
    d.children = g;
  }
  return { $$typeof: l$2, type: a.type, key: c, ref: k2, props: d, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u$2, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$2, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$2, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs$1(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$3 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$2(c, a, g) {
  var b2, d = {}, e2 = null, h2 = null;
  void 0 !== g && (e2 = "" + g);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a)
    m$2.call(a, b2) && !p$3.hasOwnProperty(b2) && (d[b2] = a[b2]);
  if (c && c.defaultProps)
    for (b2 in a = c.defaultProps, a)
      void 0 === d[b2] && (d[b2] = a[b2]);
  return { $$typeof: k$1, type: c, key: e2, ref: h2, props: d, _owner: n$3.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
const style = "";
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c = a.length;
    a.push(b2);
    a:
      for (; 0 < c; ) {
        var d = c - 1 >>> 1, e2 = a[d];
        if (0 < g(e2, b2))
          a[d] = b2, a[c] = e2, c = d;
        else
          break a;
      }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length)
      return null;
    var b2 = a[0], c = a.pop();
    if (c !== b2) {
      a[0] = c;
      a:
        for (var d = 0, e2 = a.length, w2 = e2 >>> 1; d < w2; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g(C2, c))
            n2 < e2 && 0 > g(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
          else if (n2 < e2 && 0 > g(x2, c))
            a[d] = x2, a[n2] = c, d = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g(a, b2) {
    var c = a.sortIndex - b2.sortIndex;
    return 0 !== c ? c : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a);
      }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d = v2.callback;
        if ("function" === typeof d) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T9 = new MessageChannel(), U5 = T9.port2;
    T9.port1.onmessage = R2;
    S2 = function() {
      U5.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c, expirationTime: e2, sortIndex: -1 };
    c > d ? (a.sortIndex = c, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$2(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++)
    da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c, d) {
  if (null !== c && 0 === c.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (null !== c)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c, d) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c, d))
    return true;
  if (d)
    return false;
  if (null !== c)
    switch (c.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$1(a, b2, c, d, e2, f2, g) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d;
  this.attributeNamespace = e2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z[a] = new v$1(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z[b2] = new v$1(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z[a] = new v$1(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z[a] = new v$1(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z[a] = new v$1(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z[a] = new v$1(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z[b2] = new v$1(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
});
z.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c, d) {
  var e2 = z.hasOwnProperty(b2) ? z[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c, e2, d) && (c = null), d || null === e2 ? oa(b2) && (null === c ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c)) : e2.mustUseProperty ? a[e2.propertyName] = null === c ? 3 === e2.type ? false : "" : c : (b2 = e2.attributeName, d = e2.attributeNamespace, null === c ? a.removeAttribute(b2) : (e2 = e2.type, c = 3 === e2 || 4 === e2 && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b2, c) : a.setAttribute(b2, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c) {
      var b2 = c.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na)
    return "";
  Na = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d = l2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d.stack.split("\n"), g = e2.length - 1, h2 = f2.length - 1; 1 <= g && 0 <= h2 && e2[g] !== f2[h2]; )
        h2--;
      for (; 1 <= g && 0 <= h2; g--, h2--)
        if (e2[g] !== f2[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e2[g] !== f2[h2]) {
                var k2 = "\n" + e2[g].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
      case Ha:
        b2 = a._payload;
        a = a._init;
        try {
          return Qa(a(b2));
        } catch (c) {
        }
    }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e2 = c.get, f2 = c.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c = b2.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c = b2.checked;
  return A({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c = null == b2.defaultValue ? "" : b2.defaultValue, d = null != b2.checked ? b2.checked : b2.defaultChecked;
  c = Sa(null != b2.value ? b2.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c = Sa(b2.value), d = b2.type;
  if (null != c)
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d = b2.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b2, c) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a)
    null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b2, c, d) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c.length; e2++)
      b2["$" + c[e2]] = true;
    for (c = 0; c < a.length; c++)
      e2 = b2.hasOwnProperty("$" + a[c].value), a[c].selected !== e2 && (a[c].selected = e2), e2 && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c) {
        a[e2].selected = true;
        d && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$2(91));
  return A({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c = b2.value;
  if (null == c) {
    c = b2.children;
    b2 = b2.defaultValue;
    if (null != c) {
      if (null != b2)
        throw Error(p$2(92));
      if (eb(c)) {
        if (1 < c.length)
          throw Error(p$2(93));
        c = c[0];
      }
      b2 = c;
    }
    null == b2 && (b2 = "");
    c = b2;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b2) {
  var c = Sa(b2.value), d = Sa(b2.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b2.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c, d, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c, d, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c in b2)
    if (b2.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e2 = rb(c, b2[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e2) : a[c] = e2;
    }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$2(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$2(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$2(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$2(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p$2(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c) {
  if (Ib)
    return a(b2, c);
  Ib = true;
  try {
    return Gb(a, b2, c);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c = a.stateNode;
  if (null === c)
    return null;
  var d = Db(c);
  if (null === d)
    return null;
  c = d[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && "function" !== typeof c)
    throw Error(p$2(231, b2, typeof c));
  return c;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b2, c, d, e2, f2, g, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c, d, e2, f2, g, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c, d, e2, f2, g, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$2(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p$2(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2)
      throw Error(p$2(188));
    return b2 !== a ? null : a;
  }
  for (var c = a, d = b2; ; ) {
    var e2 = c.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d = e2.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c)
          return Xb(e2), a;
        if (f2 === d)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$2(188));
    }
    if (c.return !== d.return)
      c = e2, d = f2;
    else {
      for (var g = false, h2 = e2.child; h2; ) {
        if (h2 === c) {
          g = true;
          c = e2;
          d = f2;
          break;
        }
        if (h2 === d) {
          g = true;
          d = e2;
          c = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c) {
            g = true;
            c = f2;
            d = e2;
            break;
          }
          if (h2 === d) {
            g = true;
            d = f2;
            c = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g)
          throw Error(p$2(189));
      }
    }
    if (c.alternate !== d)
      throw Error(p$2(190));
  }
  if (3 !== c.tag)
    throw Error(p$2(188));
  return c.stateNode.current === c ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2)
      return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c = a.pendingLanes;
  if (0 === c)
    return 0;
  var d = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g = c & 268435455;
  if (0 !== g) {
    var h2 = g & ~e2;
    0 !== h2 ? d = tc(h2) : (f2 &= g, 0 !== f2 && (d = tc(f2)));
  } else
    g = c & ~e2, 0 !== g ? d = tc(g) : 0 !== f2 && (d = tc(f2));
  if (0 === d)
    return 0;
  if (0 !== b2 && b2 !== d && 0 === (b2 & e2) && (e2 = d & -d, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d & 4) && (d |= c & 16);
  b2 = a.entangledLanes;
  if (0 !== b2)
    for (a = a.entanglements, b2 &= d; 0 < b2; )
      c = 31 - oc(b2), e2 = 1 << c, d |= a[c], b2 &= ~e2;
  return d;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g = 31 - oc(f2), h2 = 1 << g, k2 = e2[g];
    if (-1 === k2) {
      if (0 === (h2 & c) || 0 !== (h2 & d))
        e2[g] = vc(h2, b2);
    } else
      k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c = 0; 31 > c; c++)
    b2.push(a);
  return b2;
}
function Ac(a, b2, c) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c;
}
function Bc(a, b2) {
  var c = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e2 = 31 - oc(c), f2 = 1 << e2;
    b2[e2] = 0;
    d[e2] = -1;
    a[e2] = -1;
    c &= ~f2;
  }
}
function Cc(a, b2) {
  var c = a.entangledLanes |= b2;
  for (a = a.entanglements; c; ) {
    var d = 31 - oc(c), e2 = 1 << d;
    e2 & b2 | a[d] & b2 && (a[d] |= b2);
    c &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c, d, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b2, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c, d, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c, d, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c, d, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c, d, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c, d, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c, d, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c = Vb(b2);
    if (null !== c) {
      if (b2 = c.tag, 13 === b2) {
        if (b2 = Wb(c), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c);
          });
          return;
        }
      } else if (3 === b2 && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else
      return b2 = Cb(c), null !== b2 && Fc(b2), a.blockedOn = c, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c) {
  Xc(a) && c.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c = 0; c < Qc.length; c++)
    d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); )
    Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c, d) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c, d);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b2, c, d) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c, d);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b2, c, d) {
  if (dd) {
    var e2 = Yc(a, b2, c, d);
    if (null === e2)
      hd(a, b2, d, id$1, c), Sc(a, d);
    else if (Uc(e2, a, b2, c, d))
      d.stopPropagation();
    else if (Sc(a, d), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c, d);
        null === f2 && hd(a, b2, d, id$1, c);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d.stopPropagation();
    } else
      hd(a, b2, d, null, c);
  }
}
var id$1 = null;
function Yc(a, b2, c, d) {
  id$1 = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a)
    if (b2 = Vb(a), null === b2)
      a = null;
    else if (c = b2.tag, 13 === c) {
      a = Wb(b2);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a = null;
    } else
      b2 !== a && (a = null);
  id$1 = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b2 = ld, c = b2.length, d, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c && b2[a] === e2[a]; a++)
    ;
  var g = c - a;
  for (d = 1; d <= g && b2[c - d] === e2[f2 - d]; d++)
    ;
  return md = e2.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d, e2, f2, g) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b3 = a[c], this[c] = b3 ? b3(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id$1 = A({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id$1), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
function ne(a, b2, c, d) {
  Eb(d);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b2 }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2))
    return a;
}
function ve(a, b2) {
  if ("change" === a)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
function Ce(a, b2, c) {
  "focusin" === a ? (Ae(), pe = b2, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b2) {
  if ("click" === a)
    return te(b2);
}
function Fe(a, b2) {
  if ("input" === a || "change" === a)
    return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
    return false;
  var c = Object.keys(a), d = Object.keys(b2);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++) {
    var e2 = c[d];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ke(a, b2) {
  var c = Je(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b2 && d >= b2)
        return { node: c, offset: b2 - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b2.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c)
      a = b2.contentWindow;
    else
      break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe(a) {
  var b2 = Me(), c = a.focusedElem, d = a.selectionRange;
  if (b2 !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) {
      if (b2 = d.start, a = d.end, void 0 === a && (a = b2), "selectionStart" in c)
        c.selectionStart = b2, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b2 = c.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c.textContent.length, f2 = Math.min(d.start, e2);
        d = void 0 === d.end ? f2 : Math.min(d.end, e2);
        !a.extend && f2 > d && (e2 = d, d = f2, f2 = e2);
        e2 = Ke(c, f2);
        var g = Ke(
          c,
          d
        );
        e2 && g && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b2), a.extend(g.node, g.offset)) : (b2.setEnd(g.node, g.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c; a = a.parentNode; )
      1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b2.length; c++)
      a = b2[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b2 = new td("onSelect", "select", null, b2, c), a.push({ event: b2, listeners: d }), b2.target = Qe)));
}
function Ve(a, b2) {
  var c = {};
  c[a.toLowerCase()] = b2.toLowerCase();
  c["Webkit" + a] = "webkit" + b2;
  c["Moz" + a] = "moz" + b2;
  return c;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a])
    return Xe[a];
  if (!We[a])
    return a;
  var b2 = We[a], c;
  for (c in b2)
    if (b2.hasOwnProperty(c) && c in Ye)
      return Xe[a] = b2[c];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e2 = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g = d.length - 1; 0 <= g; g--) {
          var h2 = d[g], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g = 0; g < d.length; g++) {
          h2 = d[g];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b2) {
  var c = b2[of];
  void 0 === c && (c = b2[of] = /* @__PURE__ */ new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b2, a, 2, false), c.add(d));
}
function qf(a, b2, c) {
  var d = 0;
  b2 && (d |= 4);
  pf(c, a, d, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c, d) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c = e2.bind(null, b2, c, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d ? void 0 !== e2 ? a.addEventListener(b2, c, { capture: true, passive: e2 }) : a.addEventListener(b2, c, true) : void 0 !== e2 ? a.addEventListener(b2, c, { passive: e2 }) : a.addEventListener(b2, c, false);
}
function hd(a, b2, c, d, e2) {
  var f2 = d;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d)
    a:
      for (; ; ) {
        if (null === d)
          return;
        var g = d.tag;
        if (3 === g || 4 === g) {
          var h2 = d.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g)
            for (g = d.return; null !== g; ) {
              var k2 = g.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g = g.return;
            }
          for (; null !== h2; ) {
            g = Wc(h2);
            if (null === g)
              return;
            k2 = g.tag;
            if (5 === k2 || 6 === k2) {
              d = f2 = g;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d = d.return;
      }
  Jb(function() {
    var d2 = f2, e3 = xb(c), g2 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d2, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c, e3), g2.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d2;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g2, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d2 ? ue(d2) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d2))) {
          ne(g2, na, c, e3);
          break a;
        }
        xa && xa(a, h3, d2);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e3), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c, e3), g2.push({ event: e3, listeners: d2 }), e3.data = $a);
    }
    se(g2, b2);
  });
}
function tf(a, b2, c) {
  return { instance: a, listener: b2, currentTarget: c };
}
function oe(a, b2) {
  for (var c = b2 + "Capture", d = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c), null != f2 && d.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c, d, e2) {
  for (var f2 = b2._reactName, g = []; null !== c && c !== d; ) {
    var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c, f2), null != k2 && g.unshift(tf(c, k2, h2))) : e2 || (k2 = Kb(c, f2), null != k2 && g.push(tf(c, k2, h2))));
    c = c.return;
  }
  0 !== g.length && a.push({ event: b2, listeners: g });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c)
    throw Error(p$2(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c = b2, d = 0;
  do {
    var e2 = c.nextSibling;
    a.removeChild(c);
    if (e2 && 8 === e2.nodeType)
      if (c = e2.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e2);
          bd(b2);
          return;
        }
        d--;
      } else
        "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e2;
  } while (c);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b2)
          return a;
        b2--;
      } else
        "/$" === c && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2)
    return b2;
  for (var c = a.parentNode; c; ) {
    if (b2 = c[uf] || c[Of]) {
      c = b2.alternate;
      if (null !== b2.child || null !== c && null !== c.child)
        for (a = Mf(a); null !== a; ) {
          if (c = a[Of])
            return c;
          a = Mf(a);
        }
      return b2;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p$2(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c = a.type.contextTypes;
  if (!c)
    return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c)
    e2[f2] = b2[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b2, c) {
  if (H.current !== Vf)
    throw Error(p$2(168));
  G(H, b2);
  G(Wf, c);
}
function bg(a, b2, c) {
  var d = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d.getChildContext)
    return c;
  d = d.getChildContext();
  for (var e2 in d)
    if (!(e2 in b2))
      throw Error(p$2(108, Ra(a) || "Unknown", e2));
  return A({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b2, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(p$2(169));
  c ? (a = bg(a, b2, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c = eg;
      for (C = 1; a < c.length; a++) {
        var d = c[a];
        do
          d = d(true);
        while (null !== d);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e2 = 32 - oc(d) - 1;
  d &= ~(1 << e2);
  c += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g = e2 - e2 % 5;
    f2 = (d & (1 << g) - 1).toString(32);
    d >>= g;
    e2 -= g;
    rg = 1 << 32 - oc(b2) + e2 | c << e2 | d;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c << e2 | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b2;
  c.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c], a.flags |= 16) : b2.push(c);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b2 = 1 !== b2.nodeType || c.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b2, c.return = a, a.child = c, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c = b2;
      if (!Cg(a, b2)) {
        if (Dg(a))
          throw Error(p$2(418));
        b2 = Lf(c.nextSibling);
        var d = xg;
        b2 && Cg(a, b2) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p$2(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I)
    return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a))
      throw Hg(), Error(p$2(418));
    for (; b2; )
      Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p$2(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c && "$!" !== c && "$?" !== c || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag)
          throw Error(p$2(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(p$2(147, a));
      var e2 = d, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a)
      throw Error(p$2(284));
    if (!c._owner)
      throw Error(p$2(290, a));
  }
  return a;
}
function Mg(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$2(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function Ng(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function Og(a) {
  function b2(b3, c2) {
    if (a) {
      var d2 = b3.deletions;
      null === d2 ? (b3.deletions = [c2], b3.flags |= 16) : d2.push(c2);
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; null !== d2; )
      b2(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = Pg(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c2, d2) {
    b3.index = d2;
    if (!a)
      return b3.flags |= 1048576, c2;
    d2 = b3.alternate;
    if (null !== d2)
      return d2 = d2.index, d2 < c2 ? (b3.flags |= 2, c2) : d2;
    b3.flags |= 2;
    return c2;
  }
  function g(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c2, d2) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = Qg(c2, a2.mode, d2), b3.return = a2, b3;
    b3 = e2(b3, c2);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c2, d2) {
    var f3 = c2.type;
    if (f3 === ya)
      return m2(a2, b3, c2.props.children, d2, c2.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type))
      return d2 = e2(b3, c2.props), d2.ref = Lg(a2, b3, c2), d2.return = a2, d2;
    d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Lg(a2, b3, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b3, c2, d2) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c2.containerInfo || b3.stateNode.implementation !== c2.implementation)
      return b3 = Sg(c2, a2.mode, d2), b3.return = a2, b3;
    b3 = e2(b3, c2.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c2, d2, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Tg(c2, a2.mode, d2, f3), b3.return = a2, b3;
    b3 = e2(b3, c2);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c2) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = Qg("" + b3, a2.mode, c2), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c2 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b3), c2.return = a2, c2;
        case wa:
          return b3 = Sg(b3, a2.mode, c2), b3.return = a2, b3;
        case Ha:
          var d2 = b3._init;
          return q2(a2, d2(b3._payload), c2);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Tg(b3, a2.mode, c2, null), b3.return = a2, b3;
      Mg(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c2, d2) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2)
      return null !== e3 ? null : h2(a2, b3, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case va:
          return c2.key === e3 ? k2(a2, b3, c2, d2) : null;
        case wa:
          return c2.key === e3 ? l2(a2, b3, c2, d2) : null;
        case Ha:
          return e3 = c2._init, r2(
            a2,
            b3,
            e3(c2._payload),
            d2
          );
      }
      if (eb(c2) || Ka(c2))
        return null !== e3 ? null : m2(a2, b3, c2, d2, null);
      Mg(a2, c2);
    }
    return null;
  }
  function y2(a2, b3, c2, d2, e3) {
    if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2)
      return a2 = a2.get(c2) || null, h2(b3, a2, "" + d2, e3);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case va:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b3, a2, d2, e3);
        case wa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b3, a2, d2, e3);
        case Ha:
          var f3 = d2._init;
          return y2(a2, b3, c2, f3(d2._payload), e3);
      }
      if (eb(d2) || Ka(d2))
        return a2 = a2.get(c2) || null, m2(b3, a2, d2, e3, null);
      Mg(b3, d2);
    }
    return null;
  }
  function n2(e3, g2, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g2 = f2(n3, g2, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g2, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$2(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$2(151));
    for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g2 = f2(t3, g2, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d2, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d2; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c(a2, l3.sibling);
                    d2 = e2(l3, f3.props.children);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d2 = e2(l3, f3.props);
                  d2.ref = Lg(a2, l3, f3);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                }
                c(a2, l3);
                break;
              } else
                b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d2 = Tg(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d2, f3), h3.return = a2, a2 = h3);
          }
          return g(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d2; ) {
              if (d2.key === l3)
                if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling);
                  d2 = e2(d2, f3.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b2(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Sg(f3, a2.mode, h3);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d2, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d2, f3, h3);
      if (Ka(f3))
        return t2(a2, d2, f3, h3);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e2(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f3, a2.mode, h3), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b2 = Wg.current;
  E(Wg);
  a._currentValue = b2;
}
function bh(a, b2, c) {
  for (; null !== a; ) {
    var d = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d && (d.childLanes |= b2)) : null !== d && (d.childLanes & b2) !== b2 && (d.childLanes |= b2);
    if (a === c)
      break;
    a = a.return;
  }
}
function ch(a, b2) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b2 = a._currentValue;
  if (Zg !== a)
    if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg)
        throw Error(p$2(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else
      Yg = Yg.next = a;
  return b2;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b2, c, d) {
  var e2 = b2.interleaved;
  null === e2 ? (c.next = c, gh(b2)) : (c.next = e2.next, e2.next = c);
  b2.interleaved = c;
  return ih(a, d);
}
function ih(a, b2) {
  a.lanes |= b2;
  var c = a.alternate;
  null !== c && (c.lanes |= b2);
  c = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b2, c = a.alternate, null !== c && (c.childLanes |= b2), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b2, c) {
  var d = a.updateQueue;
  if (null === d)
    return null;
  d = d.shared;
  if (0 !== (K & 2)) {
    var e2 = d.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d.pending = b2;
    return ih(a, c);
  }
  e2 = d.interleaved;
  null === e2 ? (b2.next = b2, gh(d)) : (b2.next = e2.next, e2.next = b2);
  d.interleaved = b2;
  return ih(a, c);
}
function oh(a, b2, c) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c & 4194240))) {
    var d = b2.lanes;
    d &= a.pendingLanes;
    c |= d;
    b2.lanes = c;
    Cc(a, c);
  }
}
function ph(a, b2) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e2 = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e2 = f2 = g : f2 = f2.next = g;
        c = c.next;
      } while (null !== c);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c = { baseState: d.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b2 : a.next = b2;
  c.lastBaseUpdate = b2;
}
function qh(a, b2, c, d) {
  var e2 = a.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g ? f2 = l2 : g.next = l2;
    g = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    rh |= g;
    a.lanes = g;
    a.memoizedState = q2;
  }
}
function sh(a, b2, c) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a)
    for (b2 = 0; b2 < a.length; b2++) {
      var d = a[b2], e2 = d.callback;
      if (null !== e2) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e2)
          throw Error(p$2(191, e2));
        e2.call(d);
      }
    }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th)
    throw Error(p$2(174));
  return a;
}
function yh(a, b2) {
  G(wh, b2);
  G(vh, a);
  G(uh, th);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c = lb(b2, a.type);
  b2 !== c && (G(vh, a), G(uh, c));
}
function Bh(a) {
  vh.current === a && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c = b2.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++)
    Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N$1 = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p$2(321));
}
function Mh(a, b2) {
  if (null === b2)
    return false;
  for (var c = 0; c < b2.length && c < a.length; c++)
    if (!He(a[c], b2[c]))
      return false;
  return true;
}
function Nh(a, b2, c, d, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c(d, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2)
        throw Error(p$2(301));
      f2 += 1;
      O = N$1 = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a = c(d, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N$1 && null !== N$1.next;
  Hh = 0;
  O = N$1 = M = null;
  Ih = false;
  if (b2)
    throw Error(p$2(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a : O = O.next = a;
  return O;
}
function Uh() {
  if (null === N$1) {
    var a = M.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = N$1.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2)
    O = b2, N$1 = a;
  else {
    if (null === a)
      throw Error(p$2(310));
    N$1 = a;
    a = { memoizedState: N$1.memoizedState, baseState: N$1.baseState, baseQueue: N$1.baseQueue, queue: N$1.queue, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
function Vh(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function Wh(a) {
  var b2 = Uh(), c = b2.queue;
  if (null === c)
    throw Error(p$2(311));
  c.lastRenderedReducer = a;
  var d = N$1, e2 = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g = e2.next;
      e2.next = f2.next;
      f2.next = g;
    }
    d.baseQueue = e2 = f2;
    c.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d = d.baseState;
    var h2 = g = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g = d) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g = d : k2.next = h2;
    He(d, b2.memoizedState) || (dh = true);
    b2.memoizedState = d;
    b2.baseState = g;
    b2.baseQueue = k2;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else
    null === e2 && (c.lanes = 0);
  return [b2.memoizedState, c.dispatch];
}
function Xh(a) {
  var b2 = Uh(), c = b2.queue;
  if (null === c)
    throw Error(p$2(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e2 = c.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c.pending = null;
    var g = e2 = e2.next;
    do
      f2 = a(f2, g.action), g = g.next;
    while (g !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function Yh() {
}
function Zh(a, b2) {
  var c = M, d = Uh(), e2 = b2(), f2 = !He(d.memoizedState, e2);
  f2 && (d.memoizedState = e2, dh = true);
  d = d.queue;
  $h(ai.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c.flags |= 2048;
    bi(9, ci.bind(null, c, d, e2, b2), void 0, null);
    if (null === Q)
      throw Error(p$2(349));
    0 !== (Hh & 30) || di(c, b2, e2);
  }
  return e2;
}
function di(a, b2, c) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c = b2.stores, null === c ? b2.stores = [a] : c.push(a));
}
function ci(a, b2, c, d) {
  b2.value = c;
  b2.getSnapshot = d;
  ei(b2) && fi(a);
}
function ai(a, b2, c) {
  return c(function() {
    ei(b2) && fi(a);
  });
}
function ei(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c = b2();
    return !He(a, c);
  } catch (d) {
    return true;
  }
}
function fi(a) {
  var b2 = ih(a, 1);
  null !== b2 && gi(b2, a, 1, -1);
}
function hi(a) {
  var b2 = Th();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ii.bind(null, M, a);
  return [b2.memoizedState, a];
}
function bi(a, b2, c, d) {
  a = { tag: a, create: b2, destroy: c, deps: d, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c = b2.lastEffect, null === c ? b2.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b2.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b2, c, d) {
  var e2 = Th();
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c, void 0, void 0 === d ? null : d);
}
function li(a, b2, c, d) {
  var e2 = Uh();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== N$1) {
    var g = N$1.memoizedState;
    f2 = g.destroy;
    if (null !== d && Mh(d, g.deps)) {
      e2.memoizedState = bi(b2, c, f2, d);
      return;
    }
  }
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c, f2, d);
}
function mi(a, b2) {
  return ki(8390656, 8, a, b2);
}
function $h(a, b2) {
  return li(2048, 8, a, b2);
}
function ni(a, b2) {
  return li(4, 2, a, b2);
}
function oi(a, b2) {
  return li(4, 4, a, b2);
}
function pi(a, b2) {
  if ("function" === typeof b2)
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function qi(a, b2, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return li(4, 4, pi.bind(null, b2, a), c);
}
function ri() {
}
function si(a, b2) {
  var c = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d = c.memoizedState;
  if (null !== d && null !== b2 && Mh(b2, d[1]))
    return d[0];
  c.memoizedState = [a, b2];
  return a;
}
function ti(a, b2) {
  var c = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d = c.memoizedState;
  if (null !== d && null !== b2 && Mh(b2, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b2];
  return a;
}
function ui(a, b2, c) {
  if (0 === (Hh & 21))
    return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
  He(c, b2) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
  return b2;
}
function vi(a, b2) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(true);
  var d = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c, Gh.transition = d;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b2, c) {
  var d = yi(a);
  c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a))
    Ai(b2, c);
  else if (c = hh(a, b2, c, d), null !== c) {
    var e2 = R();
    gi(c, a, d, e2);
    Bi(c, b2, d);
  }
}
function ii(a, b2, c) {
  var d = yi(a), e2 = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a))
    Ai(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g = b2.lastRenderedState, h2 = f2(g, c);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c = hh(a, b2, e2, d);
    null !== c && (e2 = R(), gi(c, a, d, e2), Bi(c, b2, d));
  }
}
function zi(a) {
  var b2 = a.alternate;
  return a === M || null !== b2 && b2 === M;
}
function Ai(a, b2) {
  Jh = Ih = true;
  var c = a.pending;
  null === c ? b2.next = b2 : (b2.next = c.next, c.next = b2);
  a.pending = b2;
}
function Bi(a, b2, c) {
  if (0 !== (c & 4194240)) {
    var d = b2.lanes;
    d &= a.pendingLanes;
    c |= d;
    b2.lanes = c;
    Cc(a, c);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
  Th().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a),
    c
  );
}, useLayoutEffect: function(a, b2) {
  return ki(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ki(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c = Th();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c) {
  var d = Th();
  b2 = void 0 !== c ? c(b2) : b2;
  d.memoizedState = d.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d.queue = a;
  a = a.dispatch = xi.bind(null, M, a);
  return [d.memoizedState, a];
}, useRef: function(a) {
  var b2 = Th();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b2 = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c) {
  var d = M, e2 = Th();
  if (I) {
    if (void 0 === c)
      throw Error(p$2(407));
    c = c();
  } else {
    c = b2();
    if (null === Q)
      throw Error(p$2(349));
    0 !== (Hh & 30) || di(d, b2, c);
  }
  e2.memoizedState = c;
  var f2 = { value: c, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d,
    f2,
    a
  ), [a]);
  d.flags |= 2048;
  bi(9, ci.bind(null, d, f2, c, b2), void 0, null);
  return c;
}, useId: function() {
  var a = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c = sg;
    var d = rg;
    c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
    b2 = ":" + b2 + "R" + c;
    c = Kh++;
    0 < c && (b2 += "H" + c.toString(32));
    b2 += ":";
  } else
    c = Lh++, b2 = ":" + b2 + "r" + c.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b2 = Uh();
    return ui(b2, N$1.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b2 = Uh();
  return null === N$1 ? b2.memoizedState = a : ui(b2, N$1.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b2) {
  if (a && a.defaultProps) {
    b2 = A({}, b2);
    a = a.defaultProps;
    for (var c in a)
      void 0 === b2[c] && (b2[c] = a[c]);
    return b2;
  }
  return b2;
}
function Di(a, b2, c, d) {
  b2 = a.memoizedState;
  c = c(d, b2);
  c = null === c || void 0 === c ? b2 : A({}, b2, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c) {
  a = a._reactInternals;
  var d = R(), e2 = yi(a), f2 = mh(d, e2);
  f2.payload = b2;
  void 0 !== c && null !== c && (f2.callback = c);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d), oh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c) {
  a = a._reactInternals;
  var d = R(), e2 = yi(a), f2 = mh(d, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c && null !== c && (f2.callback = c);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d), oh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c = R(), d = yi(a), e2 = mh(c, d);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a, e2, d);
  null !== b2 && (gi(b2, a, d, c), oh(b2, a, d));
} };
function Fi(a, b2, c, d, e2, f2, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e2, f2) : true;
}
function Gi(a, b2, c) {
  var d = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d = b2.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e2) : Vf);
  b2 = new b2(c, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a.stateNode = b2;
  b2._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a, b2, c, d) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c, d);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c, d);
  b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a, b2, c, d) {
  var e2 = a.stateNode;
  e2.props = c;
  e2.state = a.memoizedState;
  e2.refs = {};
  kh(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b2, f2, c), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c, e2, d), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b2) {
  try {
    var c = "", d = b2;
    do
      c += Pa(d), d = d.return;
    while (d);
    var e2 = c;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Ki(a, b2, c) {
  return { value: a, source: null, stack: null != c ? c : null, digest: null != b2 ? b2 : null };
}
function Li(a, b2) {
  try {
    console.error(b2.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b2, c) {
  c = mh(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b2.value;
  c.callback = function() {
    Oi || (Oi = true, Pi$1 = d);
    Li(a, b2);
  };
  return c;
}
function Qi(a, b2, c) {
  c = mh(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e2 = b2.value;
    c.payload = function() {
      return d(e2);
    };
    c.callback = function() {
      Li(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    Li(a, b2);
    "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c2 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
function Si$1(a, b2, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d.set(b2, e2);
  } else
    e2 = d.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d.set(b2, e2));
  e2.has(c) || (e2.add(c), a = Ti.bind(null, a, b2, c), b2.then(a, a));
}
function Ui(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag)
      b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b2, c, d, e2) {
  if (0 === (a.mode & 1))
    return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c, b2, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a, b2, c, d) {
  b2.child = null === a ? Vg(b2, null, c, d) : Ug(b2, a.child, c, d);
}
function Yi(a, b2, c, d, e2) {
  c = c.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d = Nh(a, b2, c, d, f2, e2);
  c = Sh();
  if (null !== a && !dh)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && c && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, d, e2);
  return b2.child;
}
function $i(a, b2, c, d, e2) {
  if (null === a) {
    var f2 = c.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps)
      return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d, e2);
    a = Rg(c.type, null, d, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g = f2.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d) && a.ref === b2.ref)
      return Zi(a, b2, e2);
  }
  b2.flags |= 1;
  a = Pg(f2, d);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function bj(a, b2, c, d, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d) && a.ref === b2.ref)
      if (dh = false, b2.pendingProps = d = f2, 0 !== (a.lanes & e2))
        0 !== (a.flags & 131072) && (dh = true);
      else
        return b2.lanes = a.lanes, Zi(a, b2, e2);
  }
  return cj(a, b2, c, d, e2);
}
function dj(a, b2, c) {
  var d = b2.pendingProps, e2 = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c : c, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f2 ? f2.baseLanes : c;
      G(ej, fj);
      fj |= d;
    }
  else
    null !== f2 ? (d = f2.baseLanes | c, b2.memoizedState = null) : d = c, G(ej, fj), fj |= d;
  Xi(a, b2, e2, c);
  return b2.child;
}
function gj(a, b2) {
  var c = b2.ref;
  if (null === a && null !== c || null !== a && a.ref !== c)
    b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a, b2, c, d, e2) {
  var f2 = Zf(c) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c = Nh(a, b2, c, d, f2, e2);
  d = Sh();
  if (null !== a && !dh)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && d && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, c, e2);
  return b2.child;
}
function hj(a, b2, c, d, e2) {
  if (Zf(c)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode)
    ij(a, b2), Gi(b2, c, d), Ii(b2, c, d, e2), d = true;
  else if (null === a) {
    var g = b2.stateNode, h2 = b2.memoizedProps;
    g.props = h2;
    var k2 = g.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d || k2 !== l2) && Hi(b2, g, d, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g.state = r2;
    qh(b2, d, g, e2);
    k2 = b2.memoizedState;
    h2 !== d || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c, m2, d), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c, h2, d, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d, b2.memoizedState = k2), g.props = d, g.state = k2, g.context = l2, d = h2) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), d = false);
  } else {
    g = b2.stateNode;
    lh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g.props = l2;
    q2 = b2.pendingProps;
    r2 = g.context;
    k2 = c.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g, d, k2);
    jh = false;
    r2 = b2.memoizedState;
    g.state = r2;
    qh(b2, d, g, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c, y2, d), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g.componentDidUpdate && (b2.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d, b2.memoizedState = n2), g.props = d, g.state = n2, g.context = k2, d = l2) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d = false);
  }
  return jj(a, b2, c, d, f2, e2);
}
function jj(a, b2, c, d, e2, f2) {
  gj(a, b2);
  var g = 0 !== (b2.flags & 128);
  if (!d && !g)
    return e2 && dg(b2, c, false), Zi(a, b2, f2);
  d = b2.stateNode;
  Wi.current = b2;
  var h2 = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b2.flags |= 1;
  null !== a && g ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
  b2.memoizedState = d.state;
  e2 && dg(b2, c, true);
  return b2.child;
}
function kj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  yh(a, b2.containerInfo);
}
function lj(a, b2, c, d, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a, b2, c, d);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b2, c) {
  var d = b2.pendingProps, e2 = L.current, f2 = false, g = 0 !== (b2.flags & 128), h2;
  (h2 = g) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e2 |= 1;
  G(L, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g = d.children;
    a = d.fallback;
    return f2 ? (d = b2.mode, f2 = b2.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = pj(g, d, 0, null), a = Tg(a, d, c, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c), b2.memoizedState = mj, a) : qj(b2, g);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return rj(a, b2, g, d, h2, e2, c);
  if (f2) {
    f2 = d.fallback;
    g = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d.children };
    0 === (g & 1) && b2.child !== e2 ? (d = b2.child, d.childLanes = 0, d.pendingProps = k2, b2.deletions = null) : (d = Pg(e2, k2), d.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g, c, null), f2.flags |= 2);
    f2.return = b2;
    d.return = b2;
    d.sibling = f2;
    b2.child = d;
    d = f2;
    f2 = b2.child;
    g = a.child.memoizedState;
    g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
    f2.memoizedState = g;
    f2.childLanes = a.childLanes & ~c;
    b2.memoizedState = mj;
    return d;
  }
  f2 = a.child;
  a = f2.sibling;
  d = Pg(f2, { mode: "visible", children: d.children });
  0 === (b2.mode & 1) && (d.lanes = c);
  d.return = b2;
  d.sibling = null;
  null !== a && (c = b2.deletions, null === c ? (b2.deletions = [a], b2.flags |= 16) : c.push(a));
  b2.child = d;
  b2.memoizedState = null;
  return d;
}
function qj(a, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function sj(a, b2, c, d) {
  null !== d && Jg(d);
  Ug(b2, a.child, null, c);
  a = qj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function rj(a, b2, c, d, e2, f2, g) {
  if (c) {
    if (b2.flags & 256)
      return b2.flags &= -257, d = Ki(Error(p$2(422))), sj(a, b2, g, d);
    if (null !== b2.memoizedState)
      return b2.child = a.child, b2.flags |= 128, null;
    f2 = d.fallback;
    e2 = b2.mode;
    d = pj({ mode: "visible", children: d.children }, e2, 0, null);
    f2 = Tg(f2, e2, g, null);
    f2.flags |= 2;
    d.return = b2;
    f2.return = b2;
    d.sibling = f2;
    b2.child = d;
    0 !== (b2.mode & 1) && Ug(b2, a.child, null, g);
    b2.child.memoizedState = nj(g);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return sj(a, b2, g, null);
  if ("$!" === e2.data) {
    d = e2.nextSibling && e2.nextSibling.dataset;
    if (d)
      var h2 = d.dgst;
    d = h2;
    f2 = Error(p$2(419));
    d = Ki(f2, d, void 0);
    return sj(a, b2, g, d);
  }
  h2 = 0 !== (g & a.childLanes);
  if (dh || h2) {
    d = Q;
    if (null !== d) {
      switch (g & -g) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d.suspendedLanes | g)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d, a, e2, -1));
    }
    tj();
    d = Ki(Error(p$2(421)));
    return sj(a, b2, g, d);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = qj(b2, d.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a, b2, c) {
  a.lanes |= b2;
  var d = a.alternate;
  null !== d && (d.lanes |= b2);
  bh(a.return, b2, c);
}
function wj(a, b2, c, d, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e2);
}
function xj(a, b2, c) {
  var d = b2.pendingProps, e2 = d.revealOrder, f2 = d.tail;
  Xi(a, b2, d.children, c);
  d = L.current;
  if (0 !== (d & 2))
    d = d & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b2.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && vj(a, c, b2);
          else if (19 === a.tag)
            vj(a, c, b2);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  G(L, d);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c = b2.child;
        for (e2 = null; null !== c; )
          a = c.alternate, null !== a && null === Ch(a) && (e2 = c), c = c.sibling;
        c = e2;
        null === c ? (e2 = b2.child, b2.child = null) : (e2 = c.sibling, c.sibling = null);
        wj(b2, false, e2, c, f2);
        break;
      case "backwards":
        c = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === Ch(a)) {
            b2.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c;
          c = e2;
          e2 = a;
        }
        wj(b2, true, c, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function ij(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a, b2, c) {
  null !== a && (b2.dependencies = a.dependencies);
  rh |= b2.lanes;
  if (0 === (c & b2.childLanes))
    return null;
  if (null !== a && b2.child !== a.child)
    throw Error(p$2(153));
  if (null !== b2.child) {
    a = b2.child;
    c = Pg(a, a.pendingProps);
    b2.child = c;
    for (c.return = b2; null !== a.sibling; )
      a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b2;
    c.sibling = null;
  }
  return b2.child;
}
function yj(a, b2, c) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d._currentValue);
      d._currentValue = e2;
      break;
    case 13:
      d = b2.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated)
          return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c & b2.child.childLanes))
          return oj(a, b2, c);
        G(L, L.current & 1);
        a = Zi(a, b2, c);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d = 0 !== (c & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d)
          return xj(a, b2, c);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a, b2, c);
  }
  return Zi(a, b2, c);
}
var zj, Aj, Bj, Cj;
zj = function(a, b2) {
  for (var c = b2.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag)
      a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b2)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b2)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b2, c, d) {
  var e2 = a.memoizedProps;
  if (e2 !== d) {
    a = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e2 = Ya(a, e2);
        d = Ya(a, d);
        f2 = [];
        break;
      case "select":
        e2 = A({}, e2, { value: void 0 });
        d = A({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d = gb(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub(c, d);
    var g;
    c = null;
    for (l2 in e2)
      if (!d.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g in h2)
            h2.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k2 = d[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g in h2)
              !h2.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k2)
              k2.hasOwnProperty(g) && h2[g] !== k2[g] && (c || (c = {}), c[g] = k2[g]);
          } else
            c || (f2 || (f2 = []), f2.push(
              l2,
              c
            )), c = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Cj = function(a, b2, c, d) {
  c !== d && (b2.flags |= 4);
};
function Dj(a, b2) {
  if (!I)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c = null; null !== b2; )
          null !== b2.alternate && (c = b2), b2 = b2.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; )
          null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function S$1(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
  if (b2)
    for (var e2 = a.child; null !== e2; )
      c |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags & 14680064, d |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else
    for (e2 = a.child; null !== e2; )
      c |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags, d |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b2;
}
function Ej(a, b2, c) {
  var d = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d = b2.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b2);
      S$1(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c = b2.type;
      if (null !== a && null != b2.stateNode)
        Bj(a, b2, c, d, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d) {
          if (null === b2.stateNode)
            throw Error(p$2(166));
          S$1(b2);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b2)) {
          d = b2.stateNode;
          c = b2.type;
          var f2 = b2.memoizedProps;
          d[Of] = b2;
          d[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d);
              break;
            case "source":
              D("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d
              );
              D("load", d);
              break;
            case "details":
              D("toggle", d);
              break;
            case "input":
              Za(d, f2);
              D("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d);
              break;
            case "textarea":
              hb(d, f2), D("invalid", d);
          }
          ub(c, f2);
          e2 = null;
          for (var g in f2)
            if (f2.hasOwnProperty(g)) {
              var h2 = f2[g];
              "children" === g ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d.textContent,
                h2,
                a
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D("scroll", d);
            }
          switch (c) {
            case "input":
              Va(d);
              db(d, f2, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = Bf);
          }
          d = e2;
          b2.updateQueue = d;
          null !== d && (b2.flags |= 4);
        } else {
          g = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[Of] = b2;
          a[Pf] = d;
          zj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g = vb(c, d);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a);
                e2 = d;
                break;
              case "source":
                D("error", a);
                e2 = d;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d;
                break;
              case "details":
                D("toggle", a);
                e2 = d;
                break;
              case "input":
                Za(a, d);
                e2 = Ya(a, d);
                D("invalid", a);
                break;
              case "option":
                e2 = d;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d.multiple };
                e2 = A({}, d, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d);
                e2 = gb(a, d);
                D("invalid", a);
                break;
              default:
                e2 = d;
            }
            ub(c, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g));
              }
            switch (c) {
              case "input":
                Va(a);
                db(a, d, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f2 = d.value;
                null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                  a,
                  !!d.multiple,
                  d.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = true;
                break a;
              default:
                d = false;
            }
          }
          d && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode)
        Cj(a, b2, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b2.stateNode)
          throw Error(p$2(166));
        c = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d = b2.stateNode;
          c = b2.memoizedProps;
          d[Of] = b2;
          if (f2 = d.nodeValue !== c) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b2, b2.stateNode = d;
      }
      S$1(b2);
      return null;
    case 13:
      E(L);
      d = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p$2(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$2(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else
          null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c, b2;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return ah(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$1(b2), null;
      d = 0 !== (b2.flags & 128);
      g = f2.rendering;
      if (null === g)
        if (d)
          Dj(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128))
            for (a = b2.child; null !== a; ) {
              g = Ch(a);
              if (null !== g) {
                b2.flags |= 128;
                Dj(f2, false);
                d = g.updateQueue;
                null !== d && (b2.updateQueue = d, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d = c;
                for (c = b2.child; null !== c; )
                  f2 = c, a = d, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a = g.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(L, L.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B() > Gj && (b2.flags |= 128, d = true, Dj(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d)
          if (a = Ch(g), null !== a) {
            if (b2.flags |= 128, d = true, c = a.updateQueue, null !== c && (b2.updateQueue = c, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I)
              return S$1(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c && (b2.flags |= 128, d = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g.sibling = b2.child, b2.child = g) : (c = f2.last, null !== c ? c.sibling = g : b2.child = g, f2.last = g);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d && (b2.flags |= 8192), d && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$2(156, b2.tag));
}
function Ij(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$2(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b2) {
  var c = a.ref;
  if (null !== c)
    if ("function" === typeof c)
      try {
        c(null);
      } catch (d) {
        W(a, b2, d);
      }
    else
      c.current = null;
}
function Mj(a, b2, c) {
  try {
    c();
  } catch (d) {
    W(a, b2, d);
  }
}
var Nj = false;
function Oj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a)
      var c = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e2 = d.anchorOffset, f2 = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch (F2) {
            c = null;
            break a;
          }
          var g = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c || 0 !== e2 && 3 !== q2.nodeType || (h2 = g + e2);
                q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g + d);
                3 === q2.nodeType && (g += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c && ++l2 === e2 && (h2 = g);
                r2 === f2 && ++m2 === d && (k2 = g);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c = null;
      }
    c = c || { start: 0, end: 0 };
  } else
    c = null;
  Df = { focusedElem: a, selectionRange: c };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
      a.return = b2, V = a;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$2(163));
            }
        } catch (F2) {
          W(b2, b2.return, F2);
        }
        a = b2.sibling;
        if (null !== a) {
          a.return = b2.return;
          V = a;
          break;
        }
        V = b2.return;
      }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b2, c) {
  var d = b2.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e2 = d = d.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c, f2);
      }
      e2 = e2.next;
    } while (e2 !== d);
  }
}
function Qj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c = b2 = b2.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b2);
  }
}
function Rj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Sj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Sj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Vj(a, b2, c) {
  var d = a.tag;
  if (5 === d || 6 === d)
    a = a.stateNode, b2 ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b2) : c.insertBefore(a, b2) : (8 === c.nodeType ? (b2 = c.parentNode, b2.insertBefore(a, c)) : (b2 = c, b2.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d && (a = a.child, null !== a))
    for (Vj(a, b2, c), a = a.sibling; null !== a; )
      Vj(a, b2, c), a = a.sibling;
}
function Wj(a, b2, c) {
  var d = a.tag;
  if (5 === d || 6 === d)
    a = a.stateNode, b2 ? c.insertBefore(a, b2) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a))
    for (Wj(a, b2, c), a = a.sibling; null !== a; )
      Wj(a, b2, c), a = a.sibling;
}
var X = null, Xj = false;
function Yj(a, b2, c) {
  for (c = c.child; null !== c; )
    Zj(a, b2, c), c = c.sibling;
}
function Zj(a, b2, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h2) {
    }
  switch (c.tag) {
    case 5:
      U || Lj(c, b2);
    case 6:
      var d = X, e2 = Xj;
      X = null;
      Yj(a, b2, c);
      X = d;
      Xj = e2;
      null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
      break;
    case 4:
      d = X;
      e2 = Xj;
      X = c.stateNode.containerInfo;
      Xj = true;
      Yj(a, b2, c);
      X = d;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e2 = d = d.next;
        do {
          var f2 = e2, g = f2.destroy;
          f2 = f2.tag;
          void 0 !== g && (0 !== (f2 & 2) ? Mj(c, b2, g) : 0 !== (f2 & 4) && Mj(c, b2, g));
          e2 = e2.next;
        } while (e2 !== d);
      }
      Yj(a, b2, c);
      break;
    case 1:
      if (!U && (Lj(c, b2), d = c.stateNode, "function" === typeof d.componentWillUnmount))
        try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h2) {
          W(c, b2, h2);
        }
      Yj(a, b2, c);
      break;
    case 21:
      Yj(a, b2, c);
      break;
    case 22:
      c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b2, c), U = d) : Yj(a, b2, c);
      break;
    default:
      Yj(a, b2, c);
  }
}
function ak(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d = bk.bind(null, a, b3);
      c.has(b3) || (c.add(b3), b3.then(d, d));
    });
  }
}
function ck(a, b2) {
  var c = b2.deletions;
  if (null !== c)
    for (var d = 0; d < c.length; d++) {
      var e2 = c[d];
      try {
        var f2 = a, g = b2, h2 = g;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Xj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$2(160));
        Zj(f2, g, e2);
        X = null;
        Xj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      dk(b2, a), b2 = b2.sibling;
}
function dk(a, b2) {
  var c = a.alternate, d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a);
      ek(a);
      if (d & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      break;
    case 5:
      ck(b2, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g = null !== c ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g);
            var l2 = vb(h2, f2);
            for (g = 0; g < k2.length; g += 2) {
              var m2 = k2[g], q2 = k2[g + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
      }
      break;
    case 6:
      ck(b2, a);
      ek(a);
      if (d & 4) {
        if (null === a.stateNode)
          throw Error(p$2(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a);
      ek(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
      break;
    case 4:
      ck(b2, a);
      ek(a);
      break;
    case 13:
      ck(b2, a);
      ek(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
      ek(a);
      if (d & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d = r2;
                    c = r2.return;
                    try {
                      b2 = d, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d, c, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      ck(b2, a);
      ek(a);
      d & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c = a.return; null !== c; ) {
          if (Tj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p$2(160));
      }
      switch (d.tag) {
        case 5:
          var e2 = d.stateNode;
          d.flags & 32 && (ob(e2, ""), d.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g = d.stateNode.containerInfo, h2 = Uj(a);
          Vj(a, h2, g);
          break;
        default:
          throw Error(p$2(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function hk(a, b2, c) {
  V = a;
  ik(a);
}
function ik(a, b2, c) {
  for (var d = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d) {
      var g = null !== e2.memoizedState || Jj;
      if (!g) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g, V = k2) : jk(e2);
        for (; null !== f2; )
          V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b2);
              break;
            case 1:
              var d = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c)
                  d.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c.memoizedProps : Ci(b2.type, c.memoizedProps);
                  d.componentDidUpdate(e2, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d);
              break;
            case 3:
              var g = b2.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c = b2.child.stateNode;
                      break;
                    case 1:
                      c = b2.child.stateNode;
                  }
                sh(b2, g, c);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c && b2.flags & 4) {
                c = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$2(163));
          }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c = b2.sibling;
    if (null !== c) {
      c.return = b2.return;
      V = c;
      break;
    }
    V = b2.return;
  }
}
function gk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c = b2.sibling;
    if (null !== c) {
      c.return = b2.return;
      V = c;
      break;
    }
    V = b2.return;
  }
}
function jk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c, k2);
          }
          break;
        case 1:
          var d = b2.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e2 = b2.return;
            try {
              d.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi$1 = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function gi(a, b2, c, d) {
  if (50 < yk)
    throw yk = 0, zk = null, Error(p$2(185));
  Ac(a, c, d);
  if (0 === (K & 2) || a !== Q)
    a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a, b2) {
  var c = a.callbackNode;
  wc(a, b2);
  var d = uc(a, a === Q ? Z : 0);
  if (0 === d)
    null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d & -d, a.callbackPriority !== b2) {
    null != c && bc(c);
    if (1 === b2)
      0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
    else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Fk(c, Gk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c;
  }
}
function Gk(a, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6))
    throw Error(p$2(327));
  var c = a.callbackNode;
  if (Hk() && a.callbackNode !== c)
    return null;
  var d = uc(a, a === Q ? Z : 0);
  if (0 === d)
    return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b2)
    b2 = Ik(a, d);
  else {
    b2 = d;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z !== b2)
      uk = null, Gj = B() + 500, Kk(a, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d = e2, b2 = Nk(a, e2)));
    if (1 === b2)
      throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
    if (6 === b2)
      Ck(a, d);
    else {
      e2 = a.current.alternate;
      if (0 === (d & 30) && !Ok(e2) && (b2 = Ik(a, d), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d = f2, b2 = Nk(a, f2))), 1 === b2))
        throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      a.finishedWork = e2;
      a.finishedLanes = d;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$2(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d);
          if ((d & 130023424) === d && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & d) !== d) {
              R();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d);
          if ((d & 4194240) === d)
            break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d; ) {
            var g = 31 - oc(d);
            f2 = 1 << g;
            g = b2[g];
            g > e2 && (e2 = g);
            d &= ~f2;
          }
          d = e2;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p$2(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c ? Gk.bind(null, a) : null;
}
function Nk(a, b2) {
  var c = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
  a = Ik(a, b2);
  2 !== a && (b2 = tk, tk = c, null !== b2 && Fj(b2));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c = b2.updateQueue;
      if (null !== c && (c = c.stores, null !== c))
        for (var d = 0; d < c.length; d++) {
          var e2 = c[d], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g) {
            return false;
          }
        }
    }
    c = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c)
      c.return = b2, b2 = c;
    else {
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c = 31 - oc(b2), d = 1 << c;
    a[c] = -1;
    b2 &= ~d;
  }
}
function Ek(a) {
  if (0 !== (K & 6))
    throw Error(p$2(327));
  Hk();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1))
    return Dk(a, B()), null;
  var c = Ik(a, b2);
  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b2 = d, c = Nk(a, d));
  }
  if (1 === c)
    throw c = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c;
  if (6 === c)
    throw Error(p$2(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
function Qk(a, b2) {
  var c = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c = ok.transition, d = C;
  try {
    if (ok.transition = null, C = 1, a)
      return a();
  } finally {
    C = d, ok.transition = c, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y)
    for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
  Q = a;
  Y = a = Pg(a.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++)
      if (c = fh[b2], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e2 = d.next, f2 = c.pending;
        if (null !== f2) {
          var g = f2.next;
          f2.next = e2;
          d.next = g;
        }
        c.pending = d;
      }
    fh = null;
  }
  return a;
}
function Mk(a, b2) {
  do {
    var c = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d = M.memoizedState; null !== d; ) {
          var e2 = d.queue;
          null !== e2 && (e2.pending = null);
          d = d.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N$1 = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c || null === c.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g = c.return, h2 = c, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g, h2, f2, b2);
            y2.mode & 1 && Si$1(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si$1(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$2(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c);
    } catch (na) {
      b2 = na;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a, b2) {
  var c = K;
  K |= 2;
  var d = Jk();
  if (Q !== a || Z !== b2)
    uk = null, Kk(a, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a, e2);
    }
  while (1);
  $g();
  K = c;
  mk.current = d;
  if (null !== Y)
    throw Error(p$2(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; )
    Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); )
    Uk(Y);
}
function Uk(a) {
  var b2 = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Sk(a) : Y = b2;
  nk.current = null;
}
function Sk(a) {
  var b2 = a;
  do {
    var c = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c = Ej(c, b2, fj), null !== c) {
        Y = c;
        return;
      }
    } else {
      c = Ij(c, b2);
      if (null !== c) {
        c.flags &= 32767;
        Y = c;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a, b2, c) {
  var d = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a, b2, c, d);
  } finally {
    ok.transition = e2, C = d;
  }
  return null;
}
function Wk(a, b2, c, d) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6))
    throw Error(p$2(327));
  c = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(p$2(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Bc(a, f2);
  a === Q && (Y = Q = null, Z = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a, c);
    dk(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    hk(c);
    dc();
    K = h2;
    C = g;
    ok.transition = f2;
  } else
    a.current = c;
  vk && (vk = false, wk = a, xk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c.stateNode);
  Dk(a, B());
  if (null !== b2)
    for (d = a.onRecoverableError, c = 0; c < b2.length; c++)
      e2 = b2[c], d(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi)
    throw Oi = false, a = Pi$1, Pi$1 = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b2 = ok.transition, c = C;
    try {
      ok.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk)
        var d = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6))
          throw Error(p$2(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g)
            g.return = f2, V = g;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g = V;
          var u2 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u2)
            u2.return = g, V = u2;
          else
            b:
              for (g = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d = true;
      }
      return d;
    } finally {
      C = c, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a, b2, c) {
  b2 = Ji(c, b2);
  b2 = Ni(a, b2, 1);
  a = nh(a, b2, 1);
  b2 = R();
  null !== a && (Ac(a, 1, b2), Dk(a, b2));
}
function W(a, b2, c) {
  if (3 === a.tag)
    Xk(a, a, c);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a, c);
        break;
      } else if (1 === b2.tag) {
        var d = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a = Ji(c, a);
          a = Qi(b2, a, 1);
          b2 = nh(b2, a, 1);
          a = R();
          null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ti(a, b2, c) {
  var d = a.pingCache;
  null !== d && d.delete(b2);
  b2 = R();
  a.pingedLanes |= a.suspendedLanes & c;
  Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
  Dk(a, b2);
}
function Yk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = R();
  a = ih(a, b2);
  null !== a && (Ac(a, b2, c), Dk(a, c));
}
function uj(a) {
  var b2 = a.memoizedState, c = 0;
  null !== b2 && (c = b2.retryLane);
  Yk(a, c);
}
function bk(a, b2) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c = e2.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p$2(314));
  }
  null !== d && d.delete(b2);
  Yk(a, c);
}
var Vk;
Vk = function(a, b2, c) {
  if (null !== a)
    if (a.memoizedProps !== b2.pendingProps || Wf.current)
      dh = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b2.flags & 128))
        return dh = false, yj(a, b2, c);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d = b2.type;
      ij(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c);
      e2 = Nh(null, b2, d, a, e2, c);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d, a, c), b2 = jj(null, b2, d, true, f2, c)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c), b2 = b2.child);
      return b2;
    case 16:
      d = b2.elementType;
      a: {
        ij(a, b2);
        a = b2.pendingProps;
        e2 = d._init;
        d = e2(d._payload);
        b2.type = d;
        e2 = b2.tag = Zk(d);
        a = Ci(d, a);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d, a, c);
            break a;
          case 1:
            b2 = hj(null, b2, d, a, c);
            break a;
          case 11:
            b2 = Yi(null, b2, d, a, c);
            break a;
          case 14:
            b2 = $i(null, b2, d, Ci(d.type, a), c);
            break a;
        }
        throw Error(p$2(
          306,
          d,
          ""
        ));
      }
      return b2;
    case 0:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Ci(d, e2), cj(a, b2, d, e2, c);
    case 1:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Ci(d, e2), hj(a, b2, d, e2, c);
    case 3:
      a: {
        kj(b2);
        if (null === a)
          throw Error(p$2(387));
        d = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a, b2);
        qh(b2, d, null, c);
        var g = b2.memoizedState;
        d = g.element;
        if (f2.isDehydrated)
          if (f2 = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ji(Error(p$2(423)), b2);
            b2 = lj(a, b2, d, c, e2);
            break a;
          } else if (d !== e2) {
            e2 = Ji(Error(p$2(424)), b2);
            b2 = lj(a, b2, d, c, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c = Vg(b2, null, d, c), b2.child = c; c; )
              c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          Ig();
          if (d === e2) {
            b2 = Zi(a, b2, c);
            break a;
          }
          Xi(a, b2, d, c);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a && Eg(b2), d = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g = e2.children, Ef(d, e2) ? g = null : null !== f2 && Ef(d, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g, c), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return oj(a, b2, c);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d, c) : Xi(a, b2, d, c), b2.child;
    case 11:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Ci(d, e2), Yi(a, b2, d, e2, c);
    case 7:
      return Xi(a, b2, b2.pendingProps, c), b2.child;
    case 8:
      return Xi(a, b2, b2.pendingProps.children, c), b2.child;
    case 12:
      return Xi(a, b2, b2.pendingProps.children, c), b2.child;
    case 10:
      a: {
        d = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g = e2.value;
        G(Wg, d._currentValue);
        d._currentValue = g;
        if (null !== f2)
          if (He(f2.value, g)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = Zi(a, b2, c);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d) {
                    if (1 === f2.tag) {
                      k2 = mh(-1, c & -c);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c);
                    bh(
                      f2.return,
                      c,
                      b2
                    );
                    h2.lanes |= c;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g = f2.return;
                if (null === g)
                  throw Error(p$2(341));
                g.lanes |= c;
                h2 = g.alternate;
                null !== h2 && (h2.lanes |= c);
                bh(g, c, b2);
                g = f2.sibling;
              } else
                g = f2.child;
              if (null !== g)
                g.return = f2;
              else
                for (g = f2; null !== g; ) {
                  if (g === b2) {
                    g = null;
                    break;
                  }
                  f2 = g.sibling;
                  if (null !== f2) {
                    f2.return = g.return;
                    g = f2;
                    break;
                  }
                  g = g.return;
                }
              f2 = g;
            }
        Xi(a, b2, e2.children, c);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d = b2.pendingProps.children, ch(b2, c), e2 = eh(e2), d = d(e2), b2.flags |= 1, Xi(a, b2, d, c), b2.child;
    case 14:
      return d = b2.type, e2 = Ci(d, b2.pendingProps), e2 = Ci(d.type, e2), $i(a, b2, d, e2, c);
    case 15:
      return bj(a, b2, b2.type, b2.pendingProps, c);
    case 17:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Ci(d, e2), ij(a, b2), b2.tag = 1, Zf(d) ? (a = true, cg(b2)) : a = false, ch(b2, c), Gi(b2, d, e2), Ii(b2, d, e2, c), jj(null, b2, d, true, a, c);
    case 19:
      return xj(a, b2, c);
    case 22:
      return dj(a, b2, c);
  }
  throw Error(p$2(156, b2.tag));
};
function Fk(a, b2) {
  return ac(a, b2);
}
function $k(a, b2, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c, d) {
  return new $k(a, b2, c, d);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a)
    return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
function Pg(a, b2) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b2, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b2, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Rg(a, b2, c, d, e2, f2) {
  var g = 2;
  d = a;
  if ("function" === typeof a)
    aj(a) && (g = 1);
  else if ("string" === typeof a)
    g = 5;
  else
    a:
      switch (a) {
        case ya:
          return Tg(c.children, e2, f2, b2);
        case za:
          g = 8;
          e2 |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c, b2, e2), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c, b2, e2), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return pj(c, e2, f2, b2);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
          throw Error(p$2(130, null == a ? a : typeof a, ""));
      }
  b2 = Bg(g, c, b2, e2);
  b2.elementType = a;
  b2.type = d;
  b2.lanes = f2;
  return b2;
}
function Tg(a, b2, c, d) {
  a = Bg(7, a, d, b2);
  a.lanes = c;
  return a;
}
function pj(a, b2, c, d) {
  a = Bg(22, a, d, b2);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b2, c) {
  a = Bg(6, a, null, b2);
  a.lanes = c;
  return a;
}
function Sg(a, b2, c) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function al(a, b2, c, d, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b2, c, d, e2, f2, g, h2, k2) {
  a = new al(a, b2, c, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b2, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b2, implementation: c };
}
function dl(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p$2(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$2(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c))
      return bg(a, c, b2);
  }
  return b2;
}
function el(a, b2, c, d, e2, f2, g, h2, k2) {
  a = bl(c, d, true, a, e2, f2, g, h2, k2);
  a.context = dl(null);
  c = a.current;
  d = R();
  e2 = yi(c);
  f2 = mh(d, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d);
  Dk(a, d);
  return a;
}
function fl(a, b2, c, d) {
  var e2 = b2.current, f2 = R(), g = yi(e2);
  c = dl(c);
  null === b2.context ? b2.context = c : b2.pendingContext = c;
  b2 = mh(f2, g);
  b2.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b2.callback = d);
  a = nh(e2, b2, g);
  null !== a && (gi(a, e2, g, f2), oh(a, e2, g));
  return g;
}
function gl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b2 ? c : b2;
  }
}
function il(a, b2) {
  hl(a, b2);
  (a = a.alternate) && hl(a, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$2(409));
  fl(a, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c = 0; c < Qc.length && 0 !== b2 && b2 < Qc[c].priority; c++)
      ;
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b2, c, d, e2) {
  if (e2) {
    if ("function" === typeof d) {
      var f2 = d;
      d = function() {
        var a2 = gl(g);
        f2.call(a2);
      };
    }
    var g = el(b2, d, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g;
  }
  for (; e2 = a.lastChild; )
    a.removeChild(e2);
  if ("function" === typeof d) {
    var h2 = d;
    d = function() {
      var a2 = gl(k2);
      h2.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b2, k2, c, d);
  });
  return k2;
}
function rl(a, b2, c, d, e2) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = gl(g);
        h2.call(a2);
      };
    }
    fl(b2, g, a, e2);
  } else
    g = ql(c, b2, a, e2, d);
  return gl(g);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c = tc(b2.pendingLanes);
        0 !== c && (Cc(b2, c | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a, 1);
        if (null !== b3) {
          var c2 = R();
          gi(b3, a, 1, c2);
        }
      }), il(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = ih(a, 134217728);
    if (null !== b2) {
      var c = R();
      gi(b2, a, 134217728, c);
    }
    il(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = yi(a), c = ih(a, b2);
    if (null !== c) {
      var d = R();
      gi(c, a, b2, d);
    }
    il(a, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b2) {
  var c = C;
  try {
    return C = a, b2();
  } finally {
    C = c;
  }
};
yb = function(a, b2, c) {
  switch (b2) {
    case "input":
      bb(a, c);
      b2 = c.name;
      if ("radio" === c.type && null != b2) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c.length; b2++) {
          var d = c[b2];
          if (d !== a && d.form === a.form) {
            var e2 = Db(d);
            if (!e2)
              throw Error(p$2(90));
            Wa(d);
            bb(d, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b2 = c.value, null != b2 && fb(a, !!c.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber)
    try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b2) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2))
    throw Error(p$2(200));
  return cl(a, b2, null, c);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!nl(a))
    throw Error(p$2(299));
  var c = false, d = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c = true), void 0 !== b2.identifierPrefix && (d = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a, 1, false, null, null, c, false, d, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render)
      throw Error(p$2(188));
    a = Object.keys(a).join(",");
    throw Error(p$2(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b2, c) {
  if (!ol(b2))
    throw Error(p$2(200));
  return rl(null, a, b2, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b2, c) {
  if (!nl(a))
    throw Error(p$2(405));
  var d = null != c && c.hydratedSources || null, e2 = false, f2 = "", g = kl;
  null !== c && void 0 !== c && (true === c.unstable_strictMode && (e2 = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b2 = el(b2, null, a, 1, null != c ? c : null, e2, false, f2, g);
  a[uf] = b2.current;
  sf(a);
  if (d)
    for (a = 0; a < d.length; a++)
      c = d[a], e2 = c._getVersion, e2 = e2(c._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c, e2] : b2.mutableSourceEagerHydrationData.push(
        c,
        e2
      );
  return new ml(b2);
};
reactDom_production_min.render = function(a, b2, c) {
  if (!ol(b2))
    throw Error(p$2(200));
  return rl(null, a, b2, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a))
    throw Error(p$2(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c, d) {
  if (!ol(c))
    throw Error(p$2(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p$2(38));
  return rl(a, b2, c, false, d);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m$1 = reactDomExports;
{
  client.createRoot = m$1.createRoot;
  client.hydrateRoot = m$1.hydrateRoot;
}
const TrustWalletTransparentIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("mask", { id: "mask0_3705_16119", maskUnits: "userSpaceOnUse", x: "6", y: "5", width: "28", height: "30", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.66699 5H33.3337V34.6187H6.66699V5Z", fill: "white" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { mask: "url(#mask0_3705_16119)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M6.91309 9.2784L20.0768 5V34.6187C10.6741 30.6693 6.91309 23.0999 6.91309 18.8223V9.2784Z",
          fill: "#0400F5"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M33.2389 9.2784L20.0752 5V34.6187C29.4779 30.6693 33.2389 23.0999 33.2389 18.8223V9.2784Z",
          fill: "url(#paint0_linear_3705_16119)"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M33.2389 9.2784L20.0752 5V34.6187C29.4779 30.6693 33.2389 23.0999 33.2389 18.8223V9.2784Z",
          fill: "url(#paint1_linear_3705_16119)"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "linearGradient",
        {
          id: "paint0_linear_3705_16119",
          x1: "19.5197",
          y1: "38.3416",
          x2: "30.2945",
          y2: "-0.629981",
          gradientUnits: "userSpaceOnUse",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.26", stopColor: "#48FF91" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.66", stopColor: "#0094FF" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.8", stopColor: "#0038FF" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.89", stopColor: "#0500FF" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "linearGradient",
        {
          id: "paint1_linear_3705_16119",
          x1: "29.4966",
          y1: "3.28804",
          x2: "19.5534",
          y2: "34.5764",
          gradientUnits: "userSpaceOnUse",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.02", stopColor: "#0000FF" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.08", stopColor: "#0094FF" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.16", stopColor: "#48FF91" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.42", stopColor: "#0094FF" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.68", stopColor: "#0038FF" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.9", stopColor: "#0500FF" })
          ]
        }
      )
    ] })
  ] });
};
const TrustWalletIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "60", height: "60", viewBox: "0 0 60 60", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "60", height: "60", rx: "16", fill: "#242426" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M12.2197 15.7781L29.9971 10V50C17.2988 44.6662 12.2197 34.444 12.2197 28.6672V15.7781Z",
        fill: "#48FF91"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M47.7764 15.7781L29.999 10V50C42.6973 44.6662 47.7764 34.444 47.7764 28.6672V15.7781Z",
        fill: "url(#paint0_linear_5881_50281)"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "linearGradient",
      {
        id: "paint0_linear_5881_50281",
        x1: "29.2483",
        y1: "55.0274",
        x2: "43.7988",
        y2: "2.39678",
        gradientUnits: "userSpaceOnUse",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.26", stopColor: "#48FF91" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.66", stopColor: "#0094FF" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.8", stopColor: "#0038FF" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.89", stopColor: "#0500FF" })
        ]
      }
    ) })
  ] });
};
const trustWalletConfig = {
  name: "Trust Wallet",
  logos: {
    default: /* @__PURE__ */ jsxRuntimeExports.jsx(TrustWalletIcon, {}),
    transparent: /* @__PURE__ */ jsxRuntimeExports.jsx(TrustWalletTransparentIcon, {})
  },
  downloadUrls: {
    default: "https://trustwallet.com/"
  },
  spinnerColor: "#1098FC"
};
const version$6 = "2.21.55";
let errorConfig = {
  getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
  version: `viem@${version$6}`
};
let BaseError$2 = class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    var _a3;
    const details = (() => {
      var _a4;
      if (args.cause instanceof BaseError)
        return args.cause.details;
      if ((_a4 = args.cause) == null ? void 0 : _a4.message)
        return args.cause.message;
      return args.details;
    })();
    const docsPath = (() => {
      if (args.cause instanceof BaseError)
        return args.cause.docsPath || args.docsPath;
      return args.docsPath;
    })();
    const docsUrl = (_a3 = errorConfig.getDocsUrl) == null ? void 0 : _a3.call(errorConfig, { ...args, docsPath });
    const message2 = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsUrl ? [`Docs: ${docsUrl}`] : [],
      ...details ? [`Details: ${details}`] : [],
      ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
    ].join("\n");
    super(message2, args.cause ? { cause: args.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.name = args.name ?? this.name;
    this.shortMessage = shortMessage;
    this.version = version$6;
  }
  walk(fn) {
    return walk(this, fn);
  }
};
function walk(err, fn) {
  if (fn == null ? void 0 : fn(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
    return walk(err.cause, fn);
  return fn ? null : err;
}
class IntegerOutOfRangeError extends BaseError$2 {
  constructor({ max, min, signed, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class SizeOverflowError extends BaseError$2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
  }
}
class SizeExceedsPaddingSizeError extends BaseError$2 {
  constructor({ size: size2, targetSize, type: type2 }) {
    super(`${type2.charAt(0).toUpperCase()}${type2.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes2;
  if (bytes2.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes2.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0; i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes2[padEnd ? i : bytes2.length - i - 1];
  }
  return paddedBytes;
}
function isHex$1(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size$2(value) {
  if (isHex$1(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function toBytes$4(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex$1(value))
    return hexToBytes$3(value, opts);
  return stringToBytes$2(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { size: opts.size });
  }
  return bytes2;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes$3(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes2 = new Uint8Array(length);
  for (let index2 = 0, j = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError$2(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes$3(hex);
}
function stringToBytes$2(value, opts = {}) {
  const bytes2 = encoder$1.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}
function assertSize(hexOrBytes, { size: size2 }) {
  if (size$2(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size$2(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToNumber$3(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
const hexes$4 = /* @__PURE__ */ Array.from({ length: 256 }, (_v2, i) => i.toString(16).padStart(2, "0"));
function toHex$2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex$4(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex$4(value, opts = {}) {
  let string2 = "";
  for (let i = 0; i < value.length; i++) {
    string2 += hexes$4[value[i]];
  }
  const hex = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue2;
  if (size2) {
    if (signed)
      maxValue2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue2 = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue2 = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue2 === "bigint" && signed ? -maxValue2 - 1n : 0;
  if (maxValue2 && value > maxValue2 || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue2 ? `${maxValue2}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
const encoder = /* @__PURE__ */ new TextEncoder();
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex$4(value, opts);
}
class InvalidAddressError extends BaseError$2 {
  constructor({ address: address2 }) {
    super(`Address "${address2}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class LruMap extends Map {
  constructor(size2) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size2;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
}
function anumber$1(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function isBytes$4(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes$3(b2, ...lengths) {
  if (!isBytes$4(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function aexists$1(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput$1(out, instance2) {
  abytes$3(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
const U32_MASK64$2 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n$2 = /* @__PURE__ */ BigInt(32);
function fromBig$2(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64$2), l: Number(n2 >> _32n$2 & U32_MASK64$2) };
  return { h: Number(n2 >> _32n$2 & U32_MASK64$2) | 0, l: Number(n2 & U32_MASK64$2) | 0 };
}
function split$2(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l: l2 } = fromBig$2(lst[i], le2);
    [Ah2[i], Al[i]] = [h2, l2];
  }
  return [Ah2, Al];
}
const rotlSH$2 = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
const rotlSL$2 = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
const rotlBH$2 = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
const rotlBL$2 = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$2 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView$3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$3 = (word, shift) => word << 32 - shift | word >>> shift;
const isLE$1 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
const byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
const hexes$3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$3(bytes2) {
  abytes$3(bytes2);
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes$3[bytes2[i]];
  }
  return hex;
}
function utf8ToBytes$6(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$3(data) {
  if (typeof data === "string")
    data = utf8ToBytes$6(data);
  abytes$3(data);
  return data;
}
let Hash$3 = class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$3(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
const SHA3_PI$1 = [];
const SHA3_ROTL$1 = [];
const _SHA3_IOTA$1 = [];
const _0n$e = /* @__PURE__ */ BigInt(0);
const _1n$i = /* @__PURE__ */ BigInt(1);
const _2n$c = /* @__PURE__ */ BigInt(2);
const _7n$1 = /* @__PURE__ */ BigInt(7);
const _256n$1 = /* @__PURE__ */ BigInt(256);
const _0x71n$1 = /* @__PURE__ */ BigInt(113);
for (let round = 0, R2 = _1n$i, x2 = 1, y2 = 0; round < 24; round++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI$1.push(2 * (5 * y2 + x2));
  SHA3_ROTL$1.push((round + 1) * (round + 2) / 2 % 64);
  let t2 = _0n$e;
  for (let j = 0; j < 7; j++) {
    R2 = (R2 << _1n$i ^ (R2 >> _7n$1) * _0x71n$1) % _256n$1;
    if (R2 & _2n$c)
      t2 ^= _1n$i << (_1n$i << /* @__PURE__ */ BigInt(j)) - _1n$i;
  }
  _SHA3_IOTA$1.push(t2);
}
const [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = /* @__PURE__ */ split$2(_SHA3_IOTA$1, true);
const rotlH$1 = (h2, l2, s) => s > 32 ? rotlBH$2(h2, l2, s) : rotlSH$2(h2, l2, s);
const rotlL$1 = (h2, l2, s) => s > 32 ? rotlBL$2(h2, l2, s) : rotlSL$2(h2, l2, s);
function keccakP$1(s, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH$1(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL$1(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s[x2 + y2] ^= Th2;
        s[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL$1[t2];
      const Th2 = rotlH$1(curH, curL, shift);
      const Tl = rotlL$1(curH, curL, shift);
      const PI = SHA3_PI$1[t2];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th2;
      s[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H$1[round];
    s[1] ^= SHA3_IOTA_L$1[round];
  }
  B2.fill(0);
}
let Keccak$1 = class Keccak extends Hash$3 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    anumber$1(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32$2(this.state);
  }
  keccak() {
    if (!isLE$1)
      byteSwap32(this.state32);
    keccakP$1(this.state32, this.rounds);
    if (!isLE$1)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists$1(this);
    const { blockLen, state } = this;
    data = toBytes$3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists$1(this, false);
    abytes$3(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber$1(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput$1(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
const gen$1 = (suffix, blockLen, outputLen) => wrapConstructor$3(() => new Keccak$1(blockLen, suffix, outputLen));
const keccak_256$1 = /* @__PURE__ */ gen$1(1, 136, 256 / 8);
function keccak256$1(value, to_) {
  const to = to_ || "hex";
  const bytes2 = keccak_256$1(isHex$1(value, { strict: false }) ? toBytes$4(value) : value);
  if (to === "bytes")
    return bytes2;
  return toHex$2(bytes2);
}
const checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256$1(stringToBytes$2(hexAddress), "bytes");
  const address2 = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && address2[i]) {
      address2[i] = address2[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && address2[i + 1]) {
      address2[i + 1] = address2[i + 1].toUpperCase();
    }
  }
  const result = `0x${address2.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function getAddress$2(address2, chainId) {
  if (!isAddress$1(address2, { strict: false }))
    throw new InvalidAddressError({ address: address2 });
  return checksumAddress(address2, chainId);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
const isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress$1(address2, options) {
  const { strict = true } = options ?? {};
  const cacheKey = `${address2}.${strict}`;
  if (isAddressCache.has(cacheKey))
    return isAddressCache.get(cacheKey);
  const result = (() => {
    if (!addressRegex.test(address2))
      return false;
    if (address2.toLowerCase() === address2)
      return true;
    if (strict)
      return checksumAddress(address2) === address2;
    return true;
  })();
  isAddressCache.set(cacheKey, result);
  return result;
}
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link2 = links[i];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const stringify$2 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);
const getUrl = (url) => url;
class HttpRequestError extends BaseError$2 {
  constructor({ body, cause, details, headers, status, url }) {
    super("HTTP request failed.", {
      cause,
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body && `Request body: ${stringify$2(body)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}
class RpcRequestError extends BaseError$2 {
  constructor({ body, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$2(body)}`],
      name: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
  }
}
class TimeoutError extends BaseError$2 {
  constructor({ body, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$2(body)}`],
      name: "TimeoutError"
    });
  }
}
const unknownErrorCode = -1;
class RpcError extends BaseError$2 {
  constructor(cause, { code: code2, docsPath, metaMessages, name, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath,
      metaMessages: metaMessages || (cause == null ? void 0 : cause.metaMessages),
      name: name || "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name || cause.name;
    this.code = cause instanceof RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${method ? ` "${method}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
function setBigUint64$3(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi$3 = (a, b2, c) => a & b2 ^ ~a & c;
const Maj$3 = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
let HashMD$2 = class HashMD extends Hash$3 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$3(this.buffer);
  }
  update(data) {
    aexists$1(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes$3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$3(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists$1(this);
    aoutput$1(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64$3(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$3(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished: finished2, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};
const SHA256_K$3 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV$2 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$3 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$4 = class SHA256 extends HashMD$2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV$2[0] | 0;
    this.B = SHA256_IV$2[1] | 0;
    this.C = SHA256_IV$2[2] | 0;
    this.D = SHA256_IV$2[3] | 0;
    this.E = SHA256_IV$2[4] | 0;
    this.F = SHA256_IV$2[5] | 0;
    this.G = SHA256_IV$2[6] | 0;
    this.H = SHA256_IV$2[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W$3[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$3[i - 15];
      const W2 = SHA256_W$3[i - 2];
      const s0 = rotr$3(W15, 7) ^ rotr$3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$3(W2, 17) ^ rotr$3(W2, 19) ^ W2 >>> 10;
      SHA256_W$3[i] = s1 + SHA256_W$3[i - 7] + s0 + SHA256_W$3[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$3(E2, 6) ^ rotr$3(E2, 11) ^ rotr$3(E2, 25);
      const T12 = H2 + sigma1 + Chi$3(E2, F2, G2) + SHA256_K$3[i] + SHA256_W$3[i] | 0;
      const sigma0 = rotr$3(A2, 2) ^ rotr$3(A2, 13) ^ rotr$3(A2, 22);
      const T22 = sigma0 + Maj$3(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T12 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W$3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$4 = /* @__PURE__ */ wrapConstructor$3(() => new SHA256$4());
function withResolvers() {
  let resolve = () => void 0;
  let reject = () => void 0;
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise, resolve, reject };
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn, id: id2, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler2 = getScheduler();
    flush();
    const args = scheduler2.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data) => {
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (let i = 0; i < scheduler2.length; i++) {
        const { resolve } = scheduler2[i];
        resolve == null ? void 0 : resolve([data[i], data]);
      }
    }).catch((err) => {
      for (let i = 0; i < scheduler2.length; i++) {
        const { reject } = scheduler2[i];
        reject == null ? void 0 : reject(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id2);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id2) || [];
  const setScheduler = (item) => schedulerCache.set(id2, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const { promise, resolve, reject } = withResolvers();
      const split2 = shouldSplitBatch == null ? void 0 : shouldSplitBatch([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, resolve, reject });
        return promise;
      }
      setScheduler({ args, resolve, reject });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}
const promiseCache = /* @__PURE__ */ new LruMap(8192);
function withDedupe(fn, { enabled = true, id: id2 }) {
  if (!enabled || !id2)
    return fn();
  if (promiseCache.get(id2))
    return promiseCache.get(id2);
  const promise = fn().finally(() => promiseCache.delete(id2));
  promiseCache.set(id2, promise);
  return promise;
}
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count < retryCount && await shouldRetry2({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const requestId = dedupe ? keccak256$1(stringToHex(`${uid2}.${stringify$2(args)}`)) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err, { method: args.method });
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err, {
              method: args.method
            });
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case 5e3:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError$2)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        var _a3;
        if (error && error instanceof HttpRequestError) {
          const retryAfter = (_a3 = error == null ? void 0 : error.headers) == null ? void 0 : _a3.get("Retry-After");
          if (retryAfter == null ? void 0 : retryAfter.match(/\d/))
            return Number.parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: (controller == null ? void 0 : controller.signal) || null }));
      } catch (err) {
        if ((err == null ? void 0 : err.name) === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      var _a3;
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify$2(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify$2({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init);
          const args = await (onRequest == null ? void 0 : onRequest(request, init)) ?? { ...init, url };
          const response2 = await fetch(args.url ?? url, args);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if ((_a3 = response.headers.get("Content-Type")) == null ? void 0 : _a3.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          try {
            data = JSON.parse(data || "{}");
          } catch (err) {
            if (response.ok)
              throw err;
            data = { error: data };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify$2(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError)
          throw err;
        throw new HttpRequestError({
          body,
          cause: err,
          url
        });
      }
    }
  };
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function isBytes$3(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes$2(b2, ...lengths) {
  if (!isBytes$3(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(h2.outputLen);
  anumber(h2.blockLen);
}
function aexists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance2) {
  abytes$2(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
const crypto$5 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const createView$2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$2 = (word, shift) => word << 32 - shift | word >>> shift;
function utf8ToBytes$5(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$2(data) {
  if (typeof data === "string")
    data = utf8ToBytes$5(data);
  abytes$2(data);
  return data;
}
function concatBytes$5(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes$2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
let Hash$2 = class Hash2 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$4(bytesLength = 32) {
  if (crypto$5 && typeof crypto$5.getRandomValues === "function") {
    return crypto$5.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto$5 && typeof crypto$5.randomBytes === "function") {
    return crypto$5.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$2(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi$2 = (a, b2, c) => a & b2 ^ ~a & c;
const Maj$2 = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
let HashMD$1 = class HashMD2 extends Hash$2 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$2(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes$2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64$2(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished: finished2, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};
const SHA256_K$2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$2 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$3 = class SHA2562 extends HashMD$1 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV$1[0] | 0;
    this.B = SHA256_IV$1[1] | 0;
    this.C = SHA256_IV$1[2] | 0;
    this.D = SHA256_IV$1[3] | 0;
    this.E = SHA256_IV$1[4] | 0;
    this.F = SHA256_IV$1[5] | 0;
    this.G = SHA256_IV$1[6] | 0;
    this.H = SHA256_IV$1[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W$2[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$2[i - 15];
      const W2 = SHA256_W$2[i - 2];
      const s0 = rotr$2(W15, 7) ^ rotr$2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$2(W2, 17) ^ rotr$2(W2, 19) ^ W2 >>> 10;
      SHA256_W$2[i] = s1 + SHA256_W$2[i - 7] + s0 + SHA256_W$2[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$2(E2, 6) ^ rotr$2(E2, 11) ^ rotr$2(E2, 25);
      const T12 = H2 + sigma1 + Chi$2(E2, F2, G2) + SHA256_K$2[i] + SHA256_W$2[i] | 0;
      const sigma0 = rotr$2(A2, 2) ^ rotr$2(A2, 13) ^ rotr$2(A2, 22);
      const T22 = sigma0 + Maj$2(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T12 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$3 = /* @__PURE__ */ wrapConstructor$2(() => new SHA256$3());
let HMAC$2 = class HMAC extends Hash$2 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash2);
    const key = toBytes$2(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash2.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes$2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
const hmac$2 = (hash2, key, message2) => new HMAC$2(hash2, key).update(message2).digest();
hmac$2.create = (hash2, key) => new HMAC$2(hash2, key);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$d = /* @__PURE__ */ BigInt(0);
const _1n$h = /* @__PURE__ */ BigInt(1);
const _2n$b = /* @__PURE__ */ BigInt(2);
function isBytes$2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes$1(item) {
  if (!isBytes$2(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$2(bytes2) {
  abytes$1(bytes2);
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes$2[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded$2(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber$2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n$d : BigInt("0x" + hex);
}
const asciis$1 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16$1(ch2) {
  if (ch2 >= asciis$1._0 && ch2 <= asciis$1._9)
    return ch2 - asciis$1._0;
  if (ch2 >= asciis$1.A && ch2 <= asciis$1.F)
    return ch2 - (asciis$1.A - 10);
  if (ch2 >= asciis$1.a && ch2 <= asciis$1.f)
    return ch2 - (asciis$1.a - 10);
  return;
}
function hexToBytes$2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl2 = hex.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n1 = asciiToBase16$1(hex.charCodeAt(hi2));
    const n2 = asciiToBase16$1(hex.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi2] + hex[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array2[ai2] = n1 * 16 + n2;
  }
  return array2;
}
function bytesToNumberBE$2(bytes2) {
  return hexToNumber$2(bytesToHex$2(bytes2));
}
function bytesToNumberLE$2(bytes2) {
  abytes$1(bytes2);
  return hexToNumber$2(bytesToHex$2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE$2(n2, len) {
  return hexToBytes$2(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE$2(n2, len) {
  return numberToBytesBE$2(n2, len).reverse();
}
function numberToVarBytesBE$2(n2) {
  return hexToBytes$2(numberToHexUnpadded$2(n2));
}
function ensureBytes$2(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes$2(hex);
    } catch (e2) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e2);
    }
  } else if (isBytes$2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes$4(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes$1(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
function equalBytes$2(a, b2) {
  if (a.length !== b2.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b2[i];
  return diff === 0;
}
function utf8ToBytes$4(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
const isPosBig = (n2) => typeof n2 === "bigint" && _0n$d <= n2;
function inRange$1(n2, min, max) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
}
function aInRange(title, n2, min, max) {
  if (!inRange$1(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
function bitLen$2(n2) {
  let len;
  for (len = 0; n2 > _0n$d; n2 >>= _1n$h, len += 1)
    ;
  return len;
}
function bitGet$2(n2, pos) {
  return n2 >> BigInt(pos) & _1n$h;
}
function bitSet$2(n2, pos, value) {
  return n2 | (value ? _1n$h : _0n$d) << BigInt(pos);
}
const bitMask$2 = (n2) => (_2n$b << BigInt(n2 - 1)) - _1n$h;
const u8n$2 = (data) => new Uint8Array(data);
const u8fr$2 = (arr) => Uint8Array.from(arr);
function createHmacDrbg$2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n$2(hashLen);
  let k2 = u8n$2(hashLen);
  let i = 0;
  const reset = () => {
    v2.fill(1);
    k2.fill(0);
    i = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed = u8n$2()) => {
    k2 = h2(u8fr$2([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr$2([1]), seed);
    v2 = h2();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl2 = v2.slice();
      out.push(sl2);
      len += v2.length;
    }
    return concatBytes$4(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns$2 = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes$2(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject$2(object, validators2, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns$2[type2];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators2))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object;
}
const notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
const ut$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange,
  abool,
  abytes: abytes$1,
  bitGet: bitGet$2,
  bitLen: bitLen$2,
  bitMask: bitMask$2,
  bitSet: bitSet$2,
  bytesToHex: bytesToHex$2,
  bytesToNumberBE: bytesToNumberBE$2,
  bytesToNumberLE: bytesToNumberLE$2,
  concatBytes: concatBytes$4,
  createHmacDrbg: createHmacDrbg$2,
  ensureBytes: ensureBytes$2,
  equalBytes: equalBytes$2,
  hexToBytes: hexToBytes$2,
  hexToNumber: hexToNumber$2,
  inRange: inRange$1,
  isBytes: isBytes$2,
  memoized,
  notImplemented,
  numberToBytesBE: numberToBytesBE$2,
  numberToBytesLE: numberToBytesLE$2,
  numberToHexUnpadded: numberToHexUnpadded$2,
  numberToVarBytesBE: numberToVarBytesBE$2,
  utf8ToBytes: utf8ToBytes$4,
  validateObject: validateObject$2
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$c = BigInt(0), _1n$g = BigInt(1), _2n$a = /* @__PURE__ */ BigInt(2), _3n$5 = /* @__PURE__ */ BigInt(3);
const _4n$2 = /* @__PURE__ */ BigInt(4), _5n$3 = /* @__PURE__ */ BigInt(5), _8n$4 = /* @__PURE__ */ BigInt(8);
function mod$2(a, b2) {
  const result = a % b2;
  return result >= _0n$c ? result : b2 + result;
}
function pow$2(num, power, modulo) {
  if (power < _0n$c)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n$c)
    throw new Error("invalid modulus");
  if (modulo === _1n$g)
    return _0n$c;
  let res = _1n$g;
  while (power > _0n$c) {
    if (power & _1n$g)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$g;
  }
  return res;
}
function pow2$2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$c) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert$2(number2, modulo) {
  if (number2 === _0n$c)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n$c)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod$2(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$c, u2 = _1n$g;
  while (a !== _0n$c) {
    const q2 = b2 / a;
    const r2 = b2 % a;
    const m2 = x2 - u2 * q2;
    b2 = a, a = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$g)
    throw new Error("invert: does not exist");
  return mod$2(x2, modulo);
}
function tonelliShanks$2(P2) {
  const legendreC = (P2 - _1n$g) / _2n$a;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n$g, S2 = 0; Q2 % _2n$a === _0n$c; Q2 /= _2n$a, S2++)
    ;
  for (Z2 = _2n$a; Z2 < P2 && pow$2(Z2, legendreC, P2) !== P2 - _1n$g; Z2++) {
    if (Z2 > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$g) / _4n$2;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n$g) / _2n$a;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q2);
    let x2 = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n$g << BigInt(r2 - m2 - 1));
      g = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt$2(P2) {
  if (P2 % _4n$2 === _3n$5) {
    const p1div4 = (P2 + _1n$g) / _4n$2;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n$4 === _5n$3) {
    const c1 = (P2 - _5n$3) / _8n$4;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$a);
      const v2 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v2);
      const i = Fp2.mul(Fp2.mul(nv, _2n$a), v2);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks$2(P2);
}
const isNegativeLE = (num, modulo) => (mod$2(num, modulo) & _1n$g) === _1n$g;
const FIELD_FIELDS$2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS$2.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject$2(field, opts);
}
function FpPow$2(f2, num, power) {
  if (power < _0n$c)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n$c)
    return f2.ONE;
  if (power === _1n$g)
    return num;
  let p2 = f2.ONE;
  let d = num;
  while (power > _0n$c) {
    if (power & _1n$g)
      p2 = f2.mul(p2, d);
    d = f2.sqr(d);
    power >>= _1n$g;
  }
  return p2;
}
function FpInvertBatch$2(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength$2(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field$2(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$c)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength$2(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask$2(BITS),
    ZERO: _0n$c,
    ONE: _1n$g,
    create: (num) => mod$2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n$c <= num && num < ORDER;
    },
    is0: (num) => num === _0n$c,
    isOdd: (num) => (num & _1n$g) === _1n$g,
    neg: (num) => mod$2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod$2(num * num, ORDER),
    add: (lhs, rhs) => mod$2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod$2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod$2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow$2(f2, num, power),
    div: (lhs, rhs) => mod$2(lhs * invert$2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert$2(num, ORDER),
    sqrt: redef.sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt$2(ORDER);
      return sqrtP(f2, n2);
    }),
    invertBatch: (lst) => FpInvertBatch$2(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE$2(num, BYTES) : numberToBytesBE$2(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE2 ? bytesToNumberLE$2(bytes2) : bytesToNumberBE$2(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength$2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength$2(fieldOrder) {
  const length = getFieldBytesLength$2(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField$2(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength$2(fieldOrder);
  const minLen = getMinHashLength$2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberBE$2(key) : bytesToNumberLE$2(key);
  const reduced = mod$2(num, fieldOrder - _1n$g) + _1n$g;
  return isLE2 ? numberToBytesLE$2(reduced, fieldLen) : numberToBytesBE$2(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$b = BigInt(0);
const _1n$f = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W2, bits) {
  if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W2);
}
function calcWOpts(W2, bits) {
  validateW(W2, bits);
  const windows = Math.ceil(bits / W2) + 1;
  const windowSize = 2 ** (W2 - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p2, i) => {
    if (!(p2 instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
const pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P2) {
  return pointWindowSizes.get(P2) || 1;
}
function wNAF$2(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n2, p2 = c.ZERO) {
      let d = elm;
      while (n2 > _0n$b) {
        if (n2 & _1n$f)
          p2 = p2.add(d);
        d = d.double();
        n2 >>= _1n$f;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = calcWOpts(W2, bits);
      const points = [];
      let p2 = elm;
      let base2 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p2;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p2);
          points.push(base2);
        }
        p2 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = calcWOpts(W2, bits);
      let p2 = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$f;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W2, precomputes, n2, acc = c.ZERO) {
      const { windows, windowSize } = calcWOpts(W2, bits);
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        if (n2 === _0n$b)
          break;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$f;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset2 + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W2, P2, transform) {
      let comp = pointPrecomputes.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1)
          pointPrecomputes.set(P2, transform(comp));
      }
      return comp;
    },
    wNAFCached(P2, n2, transform) {
      const W2 = getW(P2);
      return this.wNAF(W2, this.getPrecomputes(W2, P2, transform), n2);
    },
    wNAFCachedUnsafe(P2, n2, transform, prev) {
      const W2 = getW(P2);
      if (W2 === 1)
        return this.unsafeLadder(P2, n2, prev);
      return this.wNAFUnsafe(W2, this.getPrecomputes(W2, P2, transform), n2, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P2, W2) {
      validateW(W2, bits);
      pointWindowSizes.set(P2, W2);
      pointPrecomputes.delete(P2);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen$2(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic$2(curve) {
  validateField$2(curve.Fp);
  validateObject$2(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength$2(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts$2(curve) {
  const opts = validateBasic$2(curve);
  validateObject$2(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n$2, hexToBytes: h2b$2 } = ut$2;
const DER$2 = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E2 } = DER$2;
      if (tag < 0 || tag > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E2("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded$2(dataLen);
      if (len.length / 2 & 128)
        throw new E2("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded$2(len.length / 2 | 128) : "";
      const t2 = numberToHexUnpadded$2(tag);
      return t2 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E2 } = DER$2;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E2("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E2("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E2("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E2("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E2("tlv.decode(long): zero leftmost byte");
        for (const b2 of lengthBytes)
          length = length << 8 | b2;
        pos += lenLen;
        if (length < 128)
          throw new E2("tlv.decode(long): not minimal encoding");
      }
      const v2 = data.subarray(pos, pos + length);
      if (v2.length !== length)
        throw new E2("tlv.decode: wrong value length");
      return { v: v2, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E2 } = DER$2;
      if (num < _0n$a)
        throw new E2("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded$2(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E2("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E2 } = DER$2;
      if (data[0] & 128)
        throw new E2("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E2("invalid signature integer: unnecessary leading zero");
      return b2n$2(data);
    }
  },
  toSig(hex) {
    const { Err: E2, _int: int, _tlv: tlv } = DER$2;
    const data = typeof hex === "string" ? h2b$2(hex) : hex;
    abytes$1(data);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER$2;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq2 = rs + ss;
    return tlv.encode(48, seq2);
  }
};
const _0n$a = BigInt(0), _1n$e = BigInt(1);
BigInt(2);
const _3n$4 = BigInt(3);
BigInt(4);
function weierstrassPoints$2(opts) {
  const CURVE = validatePointOpts$2(opts);
  const { Fp: Fp2 } = CURVE;
  const Fn = Field$2(CURVE.n, CURVE.nBitLength);
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes$4(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange$1(num, _1n$e, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes$2(key))
        key = bytesToHex$2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE$2(ensureBytes$2("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod$2(num, N2);
    aInRange("private key", num, _1n$e, N2);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { px: x2, py: y2, pz: z2 } = p2;
    if (Fp2.eql(z2, Fp2.ONE))
      return { x: x2, y: y2 };
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? Fp2.ONE : Fp2.inv(z2);
    const ax = Fp2.mul(x2, iz);
    const ay = Fp2.mul(y2, iz);
    const zz = Fp2.mul(z2, iz);
    if (is0)
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    if (!Fp2.eql(zz, Fp2.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p2) => {
    if (p2.is0()) {
      if (CURVE.allowInfinityPoint && !Fp2.is0(p2.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y: y2 } = p2.toAffine();
    if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
      throw new Error("bad point: x or y not FE");
    const left = Fp2.sqr(y2);
    const right = weierstrassEquation(x2);
    if (!Fp2.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes$2("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n$4);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n$4);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, n2, Point.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc2) {
      const { endo, n: N2 } = CURVE;
      aInRange("scalar", sc2, _0n$a, N2);
      const I2 = Point.ZERO;
      if (sc2 === _0n$a)
        return I2;
      if (this.is0() || sc2 === _1n$e)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc2, Point.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc2);
      let k1p = I2;
      let k2p = I2;
      let d = this;
      while (k1 > _0n$a || k2 > _0n$a) {
        if (k1 & _1n$e)
          k1p = k1p.add(d);
        if (k2 & _1n$e)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$e;
        k2 >>= _1n$e;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N2 } = CURVE;
      aInRange("scalar", scalar, _1n$e, N2);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(scalar);
        point = p2;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a, b2) {
      const G2 = Point.BASE;
      const mul2 = (P2, a2) => a2 === _0n$a || a2 === _1n$e || !P2.equals(G2) ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
      const sum = mul2(this, a).add(mul2(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$e)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$e)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex$2(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF$2(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts$3(curve) {
  const opts = validateBasic$2(curve);
  validateObject$2(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass$2(curveDef) {
  const CURVE = validateOpts$3(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function modN(a) {
    return mod$2(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert$2(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints$2({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a = point.toAffine();
      const x2 = Fp2.toBytes(a.x);
      const cat = concatBytes$4;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE$2(tail);
        if (!inRange$1(x2, _1n$e, Fp2.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3;
        try {
          y3 = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n$e) === _1n$e;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        const cl2 = compressedLen;
        const ul2 = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl2 + ", or uncompressed " + ul2 + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex$2(numberToBytesBE$2(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$e;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE$2(b2.slice(from, to));
  class Signature2 {
    constructor(r2, s, recovery) {
      this.r = r2;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes$2("compactSignature", hex, l2 * 2);
      return new Signature2(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r2, s } = DER$2.toSig(ensureBytes$2("DER", hex));
      return new Signature2(r2, s);
    }
    assertValidity() {
      aInRange("r", this.r, _1n$e, CURVE_ORDER);
      aInRange("s", this.s, _1n$e, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes$2("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$2(this.toDERHex());
    }
    toDERHex() {
      return DER$2.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength$2(CURVE.n);
      return mapHashToField$2(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes$2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE$2(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask$2(CURVE.nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + CURVE.nBitLength, num, _0n$a, ORDER_MASK);
    return numberToBytesBE$2(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes$2("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes$2("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes$2("extraEntropy", e2));
    }
    const seed = concatBytes$4(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q2 = Point.BASE.multiply(k2).toAffine();
      const r2 = modN(q2.x);
      if (r2 === _0n$a)
        return;
      const s = modN(ik2 * modN(m2 + r2 * d));
      if (s === _0n$a)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n$e);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg$2(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify2(signature2, msgHash, publicKey2, opts = defaultVerOpts) {
    var _a3;
    const sg2 = signature2;
    msgHash = ensureBytes$2("msgHash", msgHash);
    publicKey2 = ensureBytes$2("publicKey", publicKey2);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex2 = typeof sg2 === "string" || isBytes$2(sg2);
    const isObj = !isHex2 && !format && typeof sg2 === "object" && sg2 !== null && typeof sg2.r === "bigint" && typeof sg2.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig2 = void 0;
    let P2;
    try {
      if (isObj)
        _sig2 = new Signature2(sg2.r, sg2.s);
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig2 = Signature2.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER$2.Err))
            throw derError;
        }
        if (!_sig2 && format !== "der")
          _sig2 = Signature2.fromCompact(sg2);
      }
      P2 = Point.fromHex(publicKey2);
    } catch (error) {
      return false;
    }
    if (!_sig2)
      return false;
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s } = _sig2;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN(h2 * is2);
    const u2 = modN(r2 * is2);
    const R2 = (_a3 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a3.toAffine();
    if (!R2)
      return false;
    const v2 = modN(R2.x);
    return v2 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify: verify2,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$2(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac$2(hash2, key, concatBytes$5(...msgs)),
    randomBytes: randomBytes$4
  };
}
function createCurve$2(curveDef, defHash) {
  const create3 = (hash2) => weierstrass$2({ ...curveDef, ...getHash$2(hash2) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$2 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N$2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n$d = BigInt(1);
const _2n$9 = BigInt(2);
const divNearest$2 = (a, b2) => (a + b2 / _2n$9) / b2;
function sqrtMod$2(y2) {
  const P2 = secp256k1P$2;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2$2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2$2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2$2(b9, _2n$9, P2) * b2 % P2;
  const b22 = pow2$2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2$2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2$2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2$2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2$2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2$2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2$2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2$2(t1, _6n, P2) * b2 % P2;
  const root = pow2$2(t2, _2n$9, P2);
  if (!Fpk1.eql(Fpk1.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
const Fpk1 = Field$2(secp256k1P$2, void 0, void 0, { sqrt: sqrtMod$2 });
const secp256k1$2 = createCurve$2({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fpk1,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N$2,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N$2;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n$d * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest$2(b2 * k2, n2);
      const c2 = divNearest$2(-b1 * k2, n2);
      let k1 = mod$2(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod$2(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$3);
BigInt(0);
secp256k1$2.ProjectivePoint;
const version$5 = "2.16.0";
const getVersion$1 = () => `@wagmi/core@${version$5}`;
var __classPrivateFieldGet$4 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _BaseError_instances, _BaseError_walk;
let BaseError$1 = class BaseError2 extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return getVersion$1();
  }
  constructor(shortMessage, options = {}) {
    var _a3;
    super();
    _BaseError_instances.add(this);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiCoreError"
    });
    const details = options.cause instanceof BaseError2 ? options.cause.details : ((_a3 = options.cause) == null ? void 0 : _a3.message) ? options.cause.message : options.details;
    const docsPath = options.cause instanceof BaseError2 ? options.cause.docsPath || options.docsPath : options.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...options.metaMessages ? [...options.metaMessages, ""] : [],
      ...docsPath ? [
        `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (options.cause)
      this.cause = options.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = options.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return __classPrivateFieldGet$4(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn);
  }
};
_BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function _BaseError_walk2(err, fn) {
  if (fn == null ? void 0 : fn(err))
    return err;
  if (err.cause)
    return __classPrivateFieldGet$4(this, _BaseError_instances, "m", _BaseError_walk2).call(this, err.cause, fn);
  return err;
};
class ChainNotConfiguredError extends BaseError$1 {
  constructor() {
    super("Chain not configured.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotConfiguredError"
    });
  }
}
class ConnectorAlreadyConnectedError extends BaseError$1 {
  constructor() {
    super("Connector already connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAlreadyConnectedError"
    });
  }
}
async function connect(config2, parameters) {
  var _a3;
  let connector;
  if (typeof parameters.connector === "function") {
    connector = config2._internal.connectors.setup(parameters.connector);
  } else
    connector = parameters.connector;
  if (connector.uid === config2.state.current)
    throw new ConnectorAlreadyConnectedError();
  try {
    config2.setState((x2) => ({ ...x2, status: "connecting" }));
    connector.emitter.emit("message", { type: "connecting" });
    const { connector: _, ...rest } = parameters;
    const data = await connector.connect(rest);
    const accounts2 = data.accounts;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    await ((_a3 = config2.storage) == null ? void 0 : _a3.setItem("recentConnectorId", connector.id));
    config2.setState((x2) => ({
      ...x2,
      connections: new Map(x2.connections).set(connector.uid, {
        accounts: accounts2,
        chainId: data.chainId,
        connector
      }),
      current: connector.uid,
      status: "connected"
    }));
    return { accounts: accounts2, chainId: data.chainId };
  } catch (error) {
    config2.setState((x2) => ({
      ...x2,
      // Keep existing connector connected in case of error
      status: x2.current ? "connected" : "disconnected"
    }));
    throw error;
  }
}
const size$1 = 256;
let index$1 = size$1;
let buffer$2;
function uid$1(length = 11) {
  if (!buffer$2 || index$1 + length > size$1 * 2) {
    buffer$2 = "";
    index$1 = 0;
    for (let i = 0; i < size$1; i++) {
      buffer$2 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$2.substring(index$1, index$1++ + length);
}
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, ccipRead, key = "base", name = "Base Client", pollingInterval = 4e3, type: type2 = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config2, ...value };
  const client2 = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type: type2,
    uid: uid$1()
  };
  function extend2(base2) {
    return (extendFn) => {
      const extended = extendFn(base2);
      for (const key2 in client2)
        delete extended[key2];
      const combined = { ...base2, ...extended };
      return Object.assign(combined, { extend: extend2(combined) });
    };
  }
  return Object.assign(client2, { extend: extend2(client2) });
}
function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type: type2 }, value) {
  const uid2 = uid$1();
  return {
    config: {
      key,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type: type2
    },
    request: buildRequest(request, { retryCount, retryDelay, uid: uid2 }),
    value
  };
}
class UrlRequiredError extends BaseError$2 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function http(url, config2 = {}) {
  const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a, b2) => a.id - b2.id
        });
        const fn = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
async function disconnect(config2, parameters = {}) {
  var _a3, _b2;
  let connector;
  if (parameters.connector)
    connector = parameters.connector;
  else {
    const { connections: connections2, current } = config2.state;
    const connection = connections2.get(current);
    connector = connection == null ? void 0 : connection.connector;
  }
  const connections = config2.state.connections;
  if (connector) {
    await connector.disconnect();
    connector.emitter.off("change", config2._internal.events.change);
    connector.emitter.off("disconnect", config2._internal.events.disconnect);
    connector.emitter.on("connect", config2._internal.events.connect);
    connections.delete(connector.uid);
  }
  config2.setState((x2) => {
    if (connections.size === 0)
      return {
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      };
    const nextConnection = connections.values().next().value;
    return {
      ...x2,
      connections: new Map(connections),
      current: nextConnection.connector.uid
    };
  });
  {
    const current = config2.state.current;
    if (!current)
      return;
    const connector2 = (_a3 = config2.state.connections.get(current)) == null ? void 0 : _a3.connector;
    if (!connector2)
      return;
    await ((_b2 = config2.storage) == null ? void 0 : _b2.setItem("recentConnectorId", connector2.id));
  }
}
function getAccount(config2) {
  const uid2 = config2.state.current;
  const connection = config2.state.connections.get(uid2);
  const addresses = connection == null ? void 0 : connection.accounts;
  const address2 = addresses == null ? void 0 : addresses[0];
  const chain = config2.chains.find((chain2) => chain2.id === (connection == null ? void 0 : connection.chainId));
  const status = config2.state.status;
  switch (status) {
    case "connected":
      return {
        address: address2,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address: address2,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: !!address2,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address: address2,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function deepEqual(a, b2) {
  if (a === b2)
    return true;
  if (a && b2 && typeof a === "object" && typeof b2 === "object") {
    if (a.constructor !== b2.constructor)
      return false;
    let length;
    let i;
    if (Array.isArray(a) && Array.isArray(b2)) {
      length = a.length;
      if (length !== b2.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!deepEqual(a[i], b2[i]))
          return false;
      return true;
    }
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b2.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b2.toString();
    const keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key && !deepEqual(a[key], b2[key]))
        return false;
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
let previousChains = [];
function getChains(config2) {
  const chains = config2.chains;
  if (deepEqual(previousChains, chains))
    return previousChains;
  previousChains = chains;
  return chains;
}
let previousConnections = [];
function getConnections(config2) {
  const connections = [...config2.state.connections.values()];
  if (config2.state.status === "reconnecting")
    return previousConnections;
  if (deepEqual(previousConnections, connections))
    return previousConnections;
  previousConnections = connections;
  return connections;
}
let previousConnectors = [];
function getConnectors(config2) {
  const connectors = config2.connectors;
  if (deepEqual(previousConnectors, connectors))
    return previousConnectors;
  previousConnectors = connectors;
  return connectors;
}
let isReconnecting = false;
async function reconnect(config2, parameters = {}) {
  var _a3, _b2;
  if (isReconnecting)
    return [];
  isReconnecting = true;
  config2.setState((x2) => ({
    ...x2,
    status: x2.current ? "reconnecting" : "connecting"
  }));
  const connectors = [];
  if ((_a3 = parameters.connectors) == null ? void 0 : _a3.length) {
    for (const connector_ of parameters.connectors) {
      let connector;
      if (typeof connector_ === "function")
        connector = config2._internal.connectors.setup(connector_);
      else
        connector = connector_;
      connectors.push(connector);
    }
  } else
    connectors.push(...config2.connectors);
  let recentConnectorId;
  try {
    recentConnectorId = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem("recentConnectorId"));
  } catch {
  }
  const scores = {};
  for (const [, connection] of config2.state.connections) {
    scores[connection.connector.id] = 1;
  }
  if (recentConnectorId)
    scores[recentConnectorId] = 0;
  const sorted = Object.keys(scores).length > 0 ? (
    // .toSorted()
    [...connectors].sort((a, b2) => (scores[a.id] ?? 10) - (scores[b2.id] ?? 10))
  ) : connectors;
  let connected = false;
  const connections = [];
  const providers2 = [];
  for (const connector of sorted) {
    const provider = await connector.getProvider().catch(() => void 0);
    if (!provider)
      continue;
    if (providers2.some((x2) => x2 === provider))
      continue;
    const isAuthorized = await connector.isAuthorized();
    if (!isAuthorized)
      continue;
    const data = await connector.connect({ isReconnecting: true }).catch(() => null);
    if (!data)
      continue;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    config2.setState((x2) => {
      const connections2 = new Map(connected ? x2.connections : /* @__PURE__ */ new Map()).set(connector.uid, { accounts: data.accounts, chainId: data.chainId, connector });
      return {
        ...x2,
        current: connected ? x2.current : connector.uid,
        connections: connections2
      };
    });
    connections.push({
      accounts: data.accounts,
      chainId: data.chainId,
      connector
    });
    providers2.push(provider);
    connected = true;
  }
  if (config2.state.status === "reconnecting" || config2.state.status === "connecting") {
    if (!connected)
      config2.setState((x2) => ({
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      }));
    else
      config2.setState((x2) => ({ ...x2, status: "connected" }));
  }
  isReconnecting = false;
  return connections;
}
class ProviderNotFoundError extends BaseError$1 {
  constructor() {
    super("Provider not found.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderNotFoundError"
    });
  }
}
function watchAccount(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getAccount(config2), onChange, {
    equalityFn(a, b2) {
      const { connector: aConnector, ...aRest } = a;
      const { connector: bConnector, ...bRest } = b2;
      return deepEqual(aRest, bRest) && // check connector separately
      (aConnector == null ? void 0 : aConnector.id) === (bConnector == null ? void 0 : bConnector.id) && (aConnector == null ? void 0 : aConnector.uid) === (bConnector == null ? void 0 : bConnector.uid);
    }
  });
}
function watchConnections(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getConnections(config2), onChange, {
    equalityFn: deepEqual
  });
}
function watchConnectors(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.connectors.subscribe((connectors, prevConnectors) => {
    onChange(Object.values(connectors), prevConnectors);
  });
}
function createConnector(createConnectorFn) {
  return createConnectorFn;
}
injected$1.type = "injected";
function injected$1(parameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap$1[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      provider(window2) {
        return window2 == null ? void 0 : window2.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect2;
  let disconnect2;
  return createConnector((config2) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    /** @deprecated */
    get supportsSimulation() {
      return true;
    },
    type: injected$1.type,
    async setup() {
      const provider = await this.getProvider();
      if ((provider == null ? void 0 : provider.on) && parameters.target) {
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider.on("connect", connect2);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      var _a3, _b2, _c2, _d2, _e2, _f2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      let accounts2 = [];
      if (isReconnecting2)
        accounts2 = await this.getAccounts().catch(() => []);
      else if (shimDisconnect) {
        try {
          const permissions = await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts2 = (_d2 = (_c2 = (_b2 = (_a3 = permissions[0]) == null ? void 0 : _a3.caveats) == null ? void 0 : _b2[0]) == null ? void 0 : _c2.value) == null ? void 0 : _d2.map((x2) => getAddress$2(x2));
          if (accounts2.length > 0) {
            const sortedAccounts = await this.getAccounts();
            accounts2 = sortedAccounts;
          }
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!(accounts2 == null ? void 0 : accounts2.length) && !isReconnecting2) {
          const requestedAccounts = await provider.request({
            method: "eth_requestAccounts"
          });
          accounts2 = requestedAccounts.map((x2) => getAddress$2(x2));
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        if (shimDisconnect)
          await ((_e2 = config2.storage) == null ? void 0 : _e2.removeItem(`${this.id}.disconnected`));
        if (!parameters.target)
          await ((_f2 = config2.storage) == null ? void 0 : _f2.setItem("injected.connected", true));
        return { accounts: accounts2, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a3, _b2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      try {
        await withTimeout(() => (
          // TODO: Remove explicit type for viem@3
          provider.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      if (shimDisconnect) {
        await ((_a3 = config2.storage) == null ? void 0 : _a3.setItem(`${this.id}.disconnected`, true));
      }
      if (!parameters.target)
        await ((_b2 = config2.storage) == null ? void 0 : _b2.removeItem("injected.connected"));
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const accounts2 = await provider.request({ method: "eth_accounts" });
      return accounts2.map((x2) => getAddress$2(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider = target.provider(window);
      else if (typeof target.provider === "string")
        provider = findProvider$1(window, target.provider);
      else
        provider = target.provider;
      if (provider && !provider.removeListener) {
        if ("off" in provider && typeof provider.off === "function")
          provider.removeListener = provider.off;
        else
          provider.removeListener = () => {
          };
      }
      return provider;
    },
    async isAuthorized() {
      var _a3, _b2;
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await ((_a3 = config2.storage) == null ? void 0 : _a3.getItem(`${this.id}.disconnected`));
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem("injected.connected"));
          if (!connected)
            return false;
        }
        const provider = await this.getProvider();
        if (!provider) {
          if (unstable_shimAsyncInject !== void 0 && unstable_shimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider2 = await this.getProvider();
              return !!provider2;
            };
            const timeout = typeof unstable_shimAsyncInject === "number" ? unstable_shimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise((resolve) => window.addEventListener("ethereum#initialized", () => resolve(handleEthereum()), { once: true }))
              ] : [],
              new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout))
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError();
        }
        const accounts2 = await withRetry(() => this.getAccounts());
        return !!accounts2.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a3, _b2, _c2, _d2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const promise = new Promise((resolve) => {
        const listener = (data) => {
          if ("chainId" in data && data.chainId === chainId) {
            config2.emitter.off("change", listener);
            resolve();
          }
        };
        config2.emitter.on("change", listener);
      });
      try {
        await Promise.all([
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config2.emitter.emit("change", { chainId });
          }),
          promise
        ]);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b2 = (_a3 = error == null ? void 0 : error.data) == null ? void 0 : _a3.originalError) == null ? void 0 : _b2.code) === 4902) {
          try {
            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x2) => x2.url)
              ];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await Promise.all([
              provider.request({
                method: "wallet_addEthereumChain",
                params: [addEthereumChain]
              }).then(async () => {
                const currentChainId = await this.getChainId();
                if (currentChainId === chainId)
                  config2.emitter.emit("change", { chainId });
                else
                  throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
              }),
              promise
            ]);
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts2) {
      var _a3;
      if (accounts2.length === 0)
        this.onDisconnect();
      else if (config2.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await ((_a3 = config2.storage) == null ? void 0 : _a3.removeItem(`${this.id}.disconnected`));
      } else
        config2.emitter.emit("change", {
          accounts: accounts2.map((x2) => getAddress$2(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts2 = await this.getAccounts();
      if (accounts2.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config2.emitter.emit("connect", { accounts: accounts2, chainId });
      const provider = await this.getProvider();
      if (provider) {
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider && !!(await this.getAccounts()).length)
          return;
      }
      config2.emitter.emit("disconnect");
      if (provider) {
        if (chainChanged) {
          provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider.on("connect", connect2);
        }
      }
    }
  }));
}
const targetMap$1 = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (window2 == null ? void 0 : window2.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider$1(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(window2) {
      return findProvider$1(window2, (provider) => {
        if (!provider.isMetaMask)
          return false;
        if (provider.isBraveWallet && !provider._events && !provider._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      var _a3, _b2;
      if ((_a3 = window2 == null ? void 0 : window2.phantom) == null ? void 0 : _a3.ethereum)
        return (_b2 = window2.phantom) == null ? void 0 : _b2.ethereum;
      return findProvider$1(window2, "isPhantom");
    }
  }
};
function findProvider$1(window2, select) {
  function isProvider(provider) {
    if (typeof select === "function")
      return select(provider);
    if (typeof select === "string")
      return provider[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum == null ? void 0 : ethereum.providers)
    return ethereum.providers.find((provider) => isProvider(provider));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}
function requestProviders(listener) {
  if (typeof window === "undefined")
    return;
  const handler = (event) => listener(event.detail);
  window.addEventListener("eip6963:announceProvider", handler);
  window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
  return () => window.removeEventListener("eip6963:announceProvider", handler);
}
function createStore$1() {
  const listeners2 = /* @__PURE__ */ new Set();
  let providerDetails = [];
  const request = () => requestProviders((providerDetail) => {
    if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
      return;
    providerDetails = [...providerDetails, providerDetail];
    listeners2.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
  });
  let unwatch = request();
  return {
    _listeners() {
      return listeners2;
    },
    clear() {
      listeners2.forEach((listener) => listener([], { removed: [...providerDetails] }));
      providerDetails = [];
    },
    destroy() {
      this.clear();
      listeners2.clear();
      unwatch == null ? void 0 : unwatch();
    },
    findProvider({ rdns }) {
      return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
    },
    getProviders() {
      return providerDetails;
    },
    reset() {
      this.clear();
      unwatch == null ? void 0 : unwatch();
      unwatch = request();
    },
    subscribe(listener, { emitImmediately } = {}) {
      listeners2.add(listener);
      if (emitImmediately)
        listener(providerDetails, { added: providerDetails });
      return () => listeners2.delete(listener);
    }
  };
}
const subscribeWithSelectorImpl = (fn) => (set, get2, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState2 = fn(set, get2, api);
  return initialState2;
};
const subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a3;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a3 = storage.getItem(name)) != null ? _a3 : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const persistImpl = (config2, baseOptions) => (set, get2, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get2,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get2() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get2,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate2 = () => {
    var _a3, _b2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => {
      var _a22;
      return cb2((_a22 = get2()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b2 = options.onRehydrateStorage) == null ? void 0 : _b2.call(options, (_a3 = get2()) != null ? _a3 : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return [
              true,
              options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              )
            ];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a22;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get2()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get2();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate2();
  }
  return stateFromStorage || configResult;
};
const persist = persistImpl;
const createStoreImpl = (createState) => {
  let state;
  const listeners2 = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners2.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState2;
  const subscribe = (listener) => {
    listeners2.add(listener);
    return () => listeners2.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState2 = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var eventemitter3$2 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE2(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE2(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners2.length; i < length; i++) {
        if (listeners2[i].fn !== fn || once && !listeners2[i].once || context && listeners2[i].context !== context) {
          events.push(listeners2[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3$2);
var eventemitter3Exports$2 = eventemitter3$2.exports;
const EventEmitter$3 = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports$2);
class Emitter {
  constructor(uid2) {
    Object.defineProperty(this, "uid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: uid2
    });
    Object.defineProperty(this, "_emitter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new EventEmitter$3()
    });
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, ...params) {
    const data = params[0];
    this._emitter.emit(eventName, { uid: this.uid, ...data });
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
}
function createEmitter(uid2) {
  return new Emitter(uid2);
}
function deserialize$1(value, reviver) {
  return JSON.parse(value, (key, value_) => {
    let value2 = value_;
    if ((value2 == null ? void 0 : value2.__type) === "bigint")
      value2 = BigInt(value2.value);
    if ((value2 == null ? void 0 : value2.__type) === "Map")
      value2 = new Map(value2.value);
    return (reviver == null ? void 0 : reviver(key, value2)) ?? value2;
  });
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array2, value) {
  const { length } = array2;
  for (let index2 = 0; index2 < length; ++index2) {
    if (array2[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize$1(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer((key, value_) => {
    let value2 = value_;
    if (typeof value2 === "bigint")
      value2 = { __type: "bigint", value: value_.toString() };
    if (value2 instanceof Map)
      value2 = { __type: "Map", value: Array.from(value_.entries()) };
    return (replacer == null ? void 0 : replacer(key, value2)) ?? value2;
  }, circularReplacer), indent ?? void 0);
}
function createStorage(parameters) {
  const { deserialize: deserialize2 = deserialize$1, key: prefix = "wagmi", serialize: serialize2 = serialize$1, storage = noopStorage } = parameters;
  function unwrap(value) {
    if (value instanceof Promise)
      return value.then((x2) => x2).catch(() => null);
    return value;
  }
  return {
    ...storage,
    key: prefix,
    async getItem(key, defaultValue) {
      const value = storage.getItem(`${prefix}.${key}`);
      const unwrapped = await unwrap(value);
      if (unwrapped)
        return deserialize2(unwrapped) ?? null;
      return defaultValue ?? null;
    },
    async setItem(key, value) {
      const storageKey = `${prefix}.${key}`;
      if (value === null)
        await unwrap(storage.removeItem(storageKey));
      else
        await unwrap(storage.setItem(storageKey, serialize2(value)));
    },
    async removeItem(key) {
      await unwrap(storage.removeItem(`${prefix}.${key}`));
    }
  };
}
const noopStorage = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
};
const size = 256;
let index = size;
let buffer$1;
function uid(length = 11) {
  if (!buffer$1 || index + length > size * 2) {
    buffer$1 = "";
    index = 0;
    for (let i = 0; i < size; i++) {
      buffer$1 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$1.substring(index, index++ + length);
}
function createConfig(parameters) {
  const { multiInjectedProviderDiscovery = true, storage = createStorage({
    storage: typeof window !== "undefined" && window.localStorage ? window.localStorage : noopStorage
  }), syncConnectedChain = true, ssr = false, ...rest } = parameters;
  const mipd = typeof window !== "undefined" && multiInjectedProviderDiscovery ? createStore$1() : void 0;
  const chains = createStore(() => rest.chains);
  const connectors = createStore(() => {
    const collection = [];
    const rdnsSet = /* @__PURE__ */ new Set();
    for (const connectorFns of rest.connectors ?? []) {
      const connector = setup(connectorFns);
      collection.push(connector);
      if (!ssr && connector.rdns) {
        const rdnsValues = typeof connector.rdns === "string" ? [connector.rdns] : connector.rdns;
        for (const rdns of rdnsValues) {
          rdnsSet.add(rdns);
        }
      }
    }
    if (!ssr && mipd) {
      const providers2 = mipd.getProviders();
      for (const provider of providers2) {
        if (rdnsSet.has(provider.info.rdns))
          continue;
        collection.push(setup(providerDetailToConnector(provider)));
      }
    }
    return collection;
  });
  function setup(connectorFn) {
    var _a3;
    const emitter = createEmitter(uid());
    const connector = {
      ...connectorFn({
        emitter,
        chains: chains.getState(),
        storage,
        transports: rest.transports
      }),
      emitter,
      uid: emitter.uid
    };
    emitter.on("connect", connect2);
    (_a3 = connector.setup) == null ? void 0 : _a3.call(connector);
    return connector;
  }
  function providerDetailToConnector(providerDetail) {
    const { info } = providerDetail;
    const provider = providerDetail.provider;
    return injected$1({ target: { ...info, id: info.rdns, provider } });
  }
  const clients = /* @__PURE__ */ new Map();
  function getClient(config2 = {}) {
    const chainId = config2.chainId ?? store.getState().chainId;
    const chain = chains.getState().find((x2) => x2.id === chainId);
    if (config2.chainId && !chain)
      throw new ChainNotConfiguredError();
    {
      const client3 = clients.get(store.getState().chainId);
      if (client3 && !chain)
        return client3;
      if (!chain)
        throw new ChainNotConfiguredError();
    }
    {
      const client3 = clients.get(chainId);
      if (client3)
        return client3;
    }
    let client2;
    if (rest.client)
      client2 = rest.client({ chain });
    else {
      const chainId2 = chain.id;
      const chainIds = chains.getState().map((x2) => x2.id);
      const properties = {};
      const entries = Object.entries(rest);
      for (const [key, value] of entries) {
        if (key === "chains" || key === "client" || key === "connectors" || key === "transports")
          continue;
        if (typeof value === "object") {
          if (chainId2 in value)
            properties[key] = value[chainId2];
          else {
            const hasChainSpecificValue = chainIds.some((x2) => x2 in value);
            if (hasChainSpecificValue)
              continue;
            properties[key] = value;
          }
        } else
          properties[key] = value;
      }
      client2 = createClient({
        ...properties,
        chain,
        batch: properties.batch ?? { multicall: true },
        transport: (parameters2) => rest.transports[chainId2]({ ...parameters2, connectors })
      });
    }
    clients.set(chainId, client2);
    return client2;
  }
  function getInitialState() {
    return {
      chainId: chains.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: null,
      status: "disconnected"
    };
  }
  let currentVersion;
  const prefix = "0.0.0-canary-";
  if (version$5.startsWith(prefix))
    currentVersion = Number.parseInt(version$5.replace(prefix, ""));
  else
    currentVersion = Number.parseInt(version$5.split(".")[0] ?? "0");
  const store = createStore(subscribeWithSelector(
    // only use persist middleware if storage exists
    storage ? persist(getInitialState, {
      migrate(persistedState, version2) {
        if (version2 === currentVersion)
          return persistedState;
        const initialState2 = getInitialState();
        const chainId = validatePersistedChainId(persistedState, initialState2.chainId);
        return { ...initialState2, chainId };
      },
      name: "store",
      partialize(state) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(state.connections.entries()).map(([key, connection]) => {
              const { id: id2, name, type: type2, uid: uid2 } = connection.connector;
              const connector = { id: id2, name, type: type2, uid: uid2 };
              return [key, { ...connection, connector }];
            })
          },
          chainId: state.chainId,
          current: state.current
        };
      },
      merge(persistedState, currentState) {
        if (typeof persistedState === "object" && persistedState && "status" in persistedState)
          delete persistedState.status;
        const chainId = validatePersistedChainId(persistedState, currentState.chainId);
        return {
          ...currentState,
          ...persistedState,
          chainId
        };
      },
      skipHydration: ssr,
      storage,
      version: currentVersion
    }) : getInitialState
  ));
  store.setState(getInitialState());
  function validatePersistedChainId(persistedState, defaultChainId) {
    return persistedState && typeof persistedState === "object" && "chainId" in persistedState && typeof persistedState.chainId === "number" && chains.getState().some((x2) => x2.id === persistedState.chainId) ? persistedState.chainId : defaultChainId;
  }
  if (syncConnectedChain)
    store.subscribe(({ connections, current }) => {
      var _a3;
      return current ? (_a3 = connections.get(current)) == null ? void 0 : _a3.chainId : void 0;
    }, (chainId) => {
      const isChainConfigured = chains.getState().some((x2) => x2.id === chainId);
      if (!isChainConfigured)
        return;
      return store.setState((x2) => ({
        ...x2,
        chainId: chainId ?? x2.chainId
      }));
    });
  mipd == null ? void 0 : mipd.subscribe((providerDetails) => {
    const connectorIdSet = /* @__PURE__ */ new Set();
    const connectorRdnsSet = /* @__PURE__ */ new Set();
    for (const connector of connectors.getState()) {
      connectorIdSet.add(connector.id);
      if (connector.rdns) {
        const rdnsValues = typeof connector.rdns === "string" ? [connector.rdns] : connector.rdns;
        for (const rdns of rdnsValues) {
          connectorRdnsSet.add(rdns);
        }
      }
    }
    const newConnectors = [];
    for (const providerDetail of providerDetails) {
      if (connectorRdnsSet.has(providerDetail.info.rdns))
        continue;
      const connector = setup(providerDetailToConnector(providerDetail));
      if (connectorIdSet.has(connector.id))
        continue;
      newConnectors.push(connector);
    }
    if (storage && !store.persist.hasHydrated())
      return;
    connectors.setState((x2) => [...x2, ...newConnectors], true);
  });
  function change(data) {
    store.setState((x2) => {
      const connection = x2.connections.get(data.uid);
      if (!connection)
        return x2;
      return {
        ...x2,
        connections: new Map(x2.connections).set(data.uid, {
          accounts: data.accounts ?? connection.accounts,
          chainId: data.chainId ?? connection.chainId,
          connector: connection.connector
        })
      };
    });
  }
  function connect2(data) {
    if (store.getState().status === "connecting" || store.getState().status === "reconnecting")
      return;
    store.setState((x2) => {
      const connector = connectors.getState().find((x3) => x3.uid === data.uid);
      if (!connector)
        return x2;
      if (connector.emitter.listenerCount("connect"))
        connector.emitter.off("connect", change);
      if (!connector.emitter.listenerCount("change"))
        connector.emitter.on("change", change);
      if (!connector.emitter.listenerCount("disconnect"))
        connector.emitter.on("disconnect", disconnect2);
      return {
        ...x2,
        connections: new Map(x2.connections).set(data.uid, {
          accounts: data.accounts,
          chainId: data.chainId,
          connector
        }),
        current: data.uid,
        status: "connected"
      };
    });
  }
  function disconnect2(data) {
    store.setState((x2) => {
      const connection = x2.connections.get(data.uid);
      if (connection) {
        const connector = connection.connector;
        if (connector.emitter.listenerCount("change"))
          connection.connector.emitter.off("change", change);
        if (connector.emitter.listenerCount("disconnect"))
          connection.connector.emitter.off("disconnect", disconnect2);
        if (!connector.emitter.listenerCount("connect"))
          connection.connector.emitter.on("connect", connect2);
      }
      x2.connections.delete(data.uid);
      if (x2.connections.size === 0)
        return {
          ...x2,
          connections: /* @__PURE__ */ new Map(),
          current: null,
          status: "disconnected"
        };
      const nextConnection = x2.connections.values().next().value;
      return {
        ...x2,
        connections: new Map(x2.connections),
        current: nextConnection.connector.uid
      };
    });
  }
  return {
    get chains() {
      return chains.getState();
    },
    get connectors() {
      return connectors.getState();
    },
    storage,
    getClient,
    get state() {
      return store.getState();
    },
    setState(value) {
      let newState;
      if (typeof value === "function")
        newState = value(store.getState());
      else
        newState = value;
      const initialState2 = getInitialState();
      if (typeof newState !== "object")
        newState = initialState2;
      const isCorrupt = Object.keys(initialState2).some((x2) => !(x2 in newState));
      if (isCorrupt)
        newState = initialState2;
      store.setState(newState, true);
    },
    subscribe(selector, listener, options) {
      return store.subscribe(selector, listener, options ? {
        ...options,
        fireImmediately: options.emitImmediately
        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`
      } : void 0);
    },
    _internal: {
      mipd,
      store,
      ssr: Boolean(ssr),
      syncConnectedChain,
      transports: rest.transports,
      chains: {
        setState(value) {
          const nextChains = typeof value === "function" ? value(chains.getState()) : value;
          if (nextChains.length === 0)
            return;
          return chains.setState(nextChains, true);
        },
        subscribe(listener) {
          return chains.subscribe(listener);
        }
      },
      connectors: {
        providerDetailToConnector,
        setup,
        setState(value) {
          return connectors.setState(typeof value === "function" ? value(connectors.getState()) : value, true);
        },
        subscribe(listener) {
          return connectors.subscribe(listener);
        }
      },
      events: { change, connect: connect2, disconnect: disconnect2 }
    }
  };
}
function hydrate(config2, parameters) {
  const { initialState: initialState2, reconnectOnMount } = parameters;
  if (initialState2 && !config2._internal.store.persist.hasHydrated())
    config2.setState({
      ...initialState2,
      chainId: config2.chains.some((x2) => x2.id === initialState2.chainId) ? initialState2.chainId : config2.chains[0].id,
      connections: reconnectOnMount ? initialState2.connections : /* @__PURE__ */ new Map(),
      status: reconnectOnMount ? "reconnecting" : "disconnected"
    });
  return {
    async onMount() {
      if (config2._internal.ssr) {
        await config2._internal.store.persist.rehydrate();
        if (config2._internal.mipd) {
          config2._internal.connectors.setState((connectors) => {
            var _a3;
            const rdnsSet = /* @__PURE__ */ new Set();
            for (const connector of connectors ?? []) {
              if (connector.rdns) {
                const rdnsValues = Array.isArray(connector.rdns) ? connector.rdns : [connector.rdns];
                for (const rdns of rdnsValues) {
                  rdnsSet.add(rdns);
                }
              }
            }
            const mipdConnectors = [];
            const providers2 = ((_a3 = config2._internal.mipd) == null ? void 0 : _a3.getProviders()) ?? [];
            for (const provider of providers2) {
              if (rdnsSet.has(provider.info.rdns))
                continue;
              const connectorFn = config2._internal.connectors.providerDetailToConnector(provider);
              const connector = config2._internal.connectors.setup(connectorFn);
              mipdConnectors.push(connector);
            }
            return [...connectors, ...mipdConnectors];
          });
        }
      }
      if (reconnectOnMount)
        reconnect(config2);
      else if (config2.storage)
        config2.setState((x2) => ({
          ...x2,
          connections: /* @__PURE__ */ new Map()
        }));
    }
  };
}
function extractRpcUrls(parameters) {
  var _a3, _b2, _c2;
  const { chain } = parameters;
  const fallbackUrl = chain.rpcUrls.default.http[0];
  if (!parameters.transports)
    return [fallbackUrl];
  const transport = (_b2 = (_a3 = parameters.transports) == null ? void 0 : _a3[chain.id]) == null ? void 0 : _b2.call(_a3, { chain });
  const transports = ((_c2 = transport == null ? void 0 : transport.value) == null ? void 0 : _c2.transports) || [transport];
  return transports.map(({ value }) => (value == null ? void 0 : value.url) || fallbackUrl);
}
coinbaseWallet$1.type = "coinbaseWallet";
function coinbaseWallet$1(parameters = {}) {
  if (parameters.version === "3" || parameters.headlessMode)
    return version3(parameters);
  return version4(parameters);
}
function version4(parameters) {
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    type: coinbaseWallet$1.type,
    async connect({ chainId, ...rest } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts2 = (await provider.request({
          method: "eth_requestAccounts",
          params: "instantOnboarding" in rest && rest.instantOnboarding ? [{ onboarding: "instant" }] : []
        })).map((x2) => getAddress$2(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return { accounts: accounts2, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a3;
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider.disconnect();
      (_a3 = provider.close) == null ? void 0 : _a3.call(provider);
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x2) => getAddress$2(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const preference = (() => {
          var _a3;
          if (typeof parameters.preference === "string")
            return { options: parameters.preference };
          return {
            ...parameters.preference,
            options: ((_a3 = parameters.preference) == null ? void 0 : _a3.options) ?? "all"
          };
        })();
        const { createCoinbaseWalletSDK } = await __vitePreload(() => import("./index-a7a8fa80.js"), true ? ["./index-a7a8fa80.js","./hooks.module-1f3364a3.js"] : void 0, import.meta.url);
        const sdk = createCoinbaseWalletSDK({
          ...parameters,
          appChainIds: config2.chains.map((x2) => x2.id),
          preference
        });
        walletProvider = sdk.getProvider();
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts2 = await this.getAccounts();
        return !!accounts2.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a3, _b2, _c2, _d2;
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a3 = chain.blockExplorers) == null ? void 0 : _a3.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts2) {
      if (accounts2.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts2.map((x2) => getAddress$2(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config2.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
function version3(parameters) {
  const reloadOnDisconnect = false;
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    type: coinbaseWallet$1.type,
    async connect({ chainId } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts2 = (await provider.request({
          method: "eth_requestAccounts"
        })).map((x2) => getAddress$2(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return { accounts: accounts2, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider.disconnect();
      provider.close();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x2) => getAddress$2(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      var _a3;
      if (!walletProvider) {
        const CoinbaseWalletSDK = await (async () => {
          const { default: SDK } = await __vitePreload(() => import("./index-6d5852cd.js").then((n2) => n2.i), true ? ["./index-6d5852cd.js","./events-edb4eccf.js","./hooks.module-1f3364a3.js","./browser-bf71d691.js"] : void 0, import.meta.url);
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect });
        const walletExtensionChainId = (_a3 = sdk.walletExtension) == null ? void 0 : _a3.getChainId();
        const chain = config2.chains.find((chain2) => parameters.chainId ? chain2.id === parameters.chainId : chain2.id === walletExtensionChainId) || config2.chains[0];
        const chainId = parameters.chainId || (chain == null ? void 0 : chain.id);
        const jsonRpcUrl = parameters.jsonRpcUrl || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts2 = await this.getAccounts();
        return !!accounts2.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a3, _b2, _c2, _d2;
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a3 = chain.blockExplorers) == null ? void 0 : _a3.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts2) {
      if (accounts2.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts2.map((x2) => getAddress$2(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config2.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
metaMask$1.type = "metaMask";
function metaMask$1(parameters = {}) {
  let sdk;
  let provider;
  let providerPromise;
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let disconnect2;
  return createConnector((config2) => ({
    id: "metaMaskSDK",
    name: "MetaMask",
    rdns: ["io.metamask", "io.metamask.mobile"],
    type: metaMask$1.type,
    async setup() {
      const provider2 = await this.getProvider();
      if (provider2 == null ? void 0 : provider2.on) {
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider2.on("connect", connect2);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      const provider2 = await this.getProvider();
      if (!displayUri) {
        displayUri = this.onDisplayUri;
        provider2.on("display_uri", displayUri);
      }
      let accounts2 = [];
      if (isReconnecting2)
        accounts2 = await this.getAccounts().catch(() => []);
      try {
        let signResponse;
        let connectWithResponse;
        if (!(accounts2 == null ? void 0 : accounts2.length)) {
          if (parameters.connectAndSign || parameters.connectWith) {
            if (parameters.connectAndSign)
              signResponse = await sdk.connectAndSign({
                msg: parameters.connectAndSign
              });
            else if (parameters.connectWith)
              connectWithResponse = await sdk.connectWith({
                method: parameters.connectWith.method,
                params: parameters.connectWith.params
              });
            accounts2 = await this.getAccounts();
          } else {
            const requestedAccounts = await sdk.connect();
            accounts2 = requestedAccounts.map((x2) => getAddress$2(x2));
          }
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        if (displayUri) {
          provider2.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (signResponse)
          provider2.emit("connectAndSign", {
            accounts: accounts2,
            chainId: currentChainId,
            signResponse
          });
        else if (connectWithResponse)
          provider2.emit("connectWith", {
            accounts: accounts2,
            chainId: currentChainId,
            connectWithResponse
          });
        if (connect2) {
          provider2.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        return { accounts: accounts2, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
      await sdk.terminate();
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      const accounts2 = await provider2.request({
        method: "eth_accounts"
      });
      return accounts2.map((x2) => getAddress$2(x2));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = provider2.getChainId() || await (provider2 == null ? void 0 : provider2.request({ method: "eth_chainId" }));
      return Number(chainId);
    },
    async getProvider() {
      async function initProvider() {
        var _a3, _b2, _c2, _d2, _e2;
        const MetaMaskSDK = await (async () => {
          const { default: SDK } = await __vitePreload(() => import("./metamask-sdk-49631450.js"), true ? ["./metamask-sdk-49631450.js","./browser-bf71d691.js"] : void 0, import.meta.url);
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        const readonlyRPCMap = {};
        for (const chain of config2.chains)
          readonlyRPCMap[numberToHex(chain.id)] = (_a3 = extractRpcUrls({
            chain,
            transports: config2.transports
          })) == null ? void 0 : _a3[0];
        sdk = new MetaMaskSDK({
          _source: "wagmi",
          forceDeleteProvider: false,
          forceInjectProvider: false,
          injectProvider: false,
          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`
          ...parameters,
          readonlyRPCMap,
          dappMetadata: {
            ...parameters.dappMetadata,
            // Test if name and url are set AND not empty
            name: ((_b2 = parameters.dappMetadata) == null ? void 0 : _b2.name) ? (_c2 = parameters.dappMetadata) == null ? void 0 : _c2.name : "wagmi",
            url: ((_d2 = parameters.dappMetadata) == null ? void 0 : _d2.url) ? (_e2 = parameters.dappMetadata) == null ? void 0 : _e2.url : typeof window !== "undefined" ? window.location.origin : "https://wagmi.sh"
          },
          useDeeplink: parameters.useDeeplink ?? true
        });
        const result = await sdk.init();
        const provider2 = (() => {
          if (result == null ? void 0 : result.activeProvider)
            return result.activeProvider;
          return sdk.getProvider();
        })();
        if (!provider2)
          throw new ProviderNotFoundError();
        return provider2;
      }
      if (!provider) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider = await providerPromise;
      }
      return provider;
    },
    async isAuthorized() {
      try {
        const timeout = 200;
        const accounts2 = await withRetry(() => withTimeout(() => this.getAccounts(), { timeout }), {
          delay: timeout + 1,
          retryCount: 3
        });
        return !!accounts2.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider2 = await this.getProvider();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const isDefaultChain = (() => {
        const metaMaskDefaultChains = [
          1,
          11155111,
          59144,
          59141
        ];
        return metaMaskDefaultChains.find((x2) => x2 === chainId);
      })();
      if (!isDefaultChain)
        try {
          const blockExplorerUrls = (() => {
            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              return addEthereumChainParameter.blockExplorerUrls;
            if (blockExplorer)
              return [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x2) => x2.url)
              ];
            return;
          })();
          const rpcUrls = (() => {
            var _a3, _b2;
            if ((_a3 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _a3.length)
              return addEthereumChainParameter.rpcUrls;
            return [((_b2 = chain.rpcUrls.default) == null ? void 0 : _b2.http[0]) ?? ""];
          })();
          await provider2.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                blockExplorerUrls,
                chainId: numberToHex(chainId),
                chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
                iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
                nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
                rpcUrls
              }
            ]
          });
          let retryCount = 0;
          const currentChainId = await withRetry(async () => {
            retryCount += 1;
            const value = hexToNumber$3(
              // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks
              await provider2.request({ method: "eth_chainId" })
            );
            if (value !== chainId) {
              if (retryCount === 5)
                return -1;
              throw new Error("Chain ID mismatch");
            }
            return value;
          }, {
            delay: 100,
            retryCount: 5
            // android device encryption is slower
          });
          if (currentChainId !== chainId)
            throw new Error("User rejected switch after adding network.");
          return chain;
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          throw new SwitchChainError(error);
        }
      try {
        await Promise.all([
          provider2.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config2.emitter.emit("change", { chainId });
          }),
          new Promise((resolve) => {
            const listener = (data) => {
              if ("chainId" in data && data.chainId === chainId) {
                config2.emitter.off("change", listener);
                resolve();
              }
            };
            config2.emitter.on("change", listener);
          })
        ]);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts2) {
      if (accounts2.length === 0) {
        if (sdk.isExtensionActive())
          this.onDisconnect();
        else
          return;
      } else if (config2.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
      } else
        config2.emitter.emit("change", {
          accounts: accounts2.map((x2) => getAddress$2(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts2 = await this.getAccounts();
      if (accounts2.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config2.emitter.emit("connect", { accounts: accounts2, chainId });
      const provider2 = await this.getProvider();
      if (connect2) {
        provider2.removeListener("connect", connect2);
        connect2 = void 0;
      }
      if (!accountsChanged) {
        accountsChanged = this.onAccountsChanged.bind(this);
        provider2.on("accountsChanged", accountsChanged);
      }
      if (!chainChanged) {
        chainChanged = this.onChainChanged.bind(this);
        provider2.on("chainChanged", chainChanged);
      }
      if (!disconnect2) {
        disconnect2 = this.onDisconnect.bind(this);
        provider2.on("disconnect", disconnect2);
      }
    },
    async onDisconnect(error) {
      const provider2 = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider2 && !!(await this.getAccounts()).length)
          return;
      }
      config2.emitter.emit("disconnect");
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config2.emitter.emit("message", { type: "display_uri", data: uri });
    }
  }));
}
walletConnect$1.type = "walletConnect";
function walletConnect$1(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  const NAMESPACE = "eip155";
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config2) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect$1.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider)
        return;
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ chainId, ...rest } = {}) {
      var _a3, _b2;
      try {
        const provider = await this.getProvider();
        if (!provider)
          throw new ProviderNotFoundError();
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        let targetChainId = chainId;
        if (!targetChainId) {
          const state = await ((_a3 = config2.storage) == null ? void 0 : _a3.getItem("state")) ?? {};
          const isChainSupported = config2.chains.some((x2) => x2.id === state.chainId);
          if (isChainSupported)
            targetChainId = state.chainId;
          else
            targetChainId = (_b2 = config2.chains[0]) == null ? void 0 : _b2.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale)
          await provider.disconnect();
        if (!provider.session || isChainsStale) {
          const optionalChains = config2.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
          await provider.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(config2.chains.map((x2) => x2.id));
        }
        const accounts2 = (await provider.enable()).map((x2) => getAddress$2(x2));
        const currentChainId = await this.getChainId();
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        return { accounts: accounts2, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await (provider == null ? void 0 : provider.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        if (chainChanged) {
          provider == null ? void 0 : provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider == null ? void 0 : provider.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider == null ? void 0 : provider.on("connect", connect2);
        }
        if (accountsChanged) {
          provider == null ? void 0 : provider.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider == null ? void 0 : provider.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return provider.accounts.map((x2) => getAddress$2(x2));
    },
    async getProvider({ chainId } = {}) {
      var _a3;
      async function initProvider() {
        const optionalChains = config2.chains.map((x2) => x2.id);
        if (!optionalChains.length)
          return;
        const { EthereumProvider } = await __vitePreload(() => import("./index.es-f6ad75c9.js"), true ? ["./index.es-f6ad75c9.js","./events-edb4eccf.js"] : void 0, import.meta.url);
        return await EthereumProvider.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: parameters.projectId,
          rpcMap: Object.fromEntries(config2.chains.map((chain) => {
            const [url] = extractRpcUrls({
              chain,
              transports: config2.transports
            });
            return [chain.id, url];
          })),
          showQrModal: parameters.showQrModal ?? true
        });
      }
      if (!provider_) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider_ = await providerPromise;
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      if (chainId)
        await ((_a3 = this.switchChain) == null ? void 0 : _a3.call(this, { chainId }));
      return provider_;
    },
    async getChainId() {
      const provider = await this.getProvider();
      return provider.chainId;
    },
    async isAuthorized() {
      try {
        const [accounts2, provider] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        if (!accounts2.length)
          return false;
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a3, _b2, _c2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          new Promise((resolve) => {
            const listener = ({ chainId: currentChainId }) => {
              if (currentChainId === chainId) {
                config2.emitter.off("change", listener);
                resolve();
              }
            };
            config2.emitter.on("change", listener);
          }),
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          })
        ]);
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return chain;
      } catch (err) {
        const error = err;
        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          else
            blockExplorerUrls = ((_a3 = chain.blockExplorers) == null ? void 0 : _a3.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
          let rpcUrls;
          if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
            rpcUrls = addEthereumChainParameter.rpcUrls;
          else
            rpcUrls = [...chain.rpcUrls.default.http];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
    },
    onAccountsChanged(accounts2) {
      if (accounts2.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts2.map((x2) => getAddress$2(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts2 = await this.getAccounts();
      config2.emitter.emit("connect", { accounts: accounts2, chainId });
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config2.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config2.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a3, _b2, _c2;
      if (!provider_)
        return [];
      const chainIds = (_c2 = (_b2 = (_a3 = provider_.session) == null ? void 0 : _a3.namespaces[NAMESPACE]) == null ? void 0 : _b2.accounts) == null ? void 0 : _c2.map((account) => Number.parseInt(account.split(":")[1] || ""));
      return chainIds ?? [];
    },
    async getRequestedChainsIds() {
      var _a3;
      return await ((_a3 = config2.storage) == null ? void 0 : _a3.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!isNewChainsStale)
        return false;
      const connectorChains = config2.chains.map((x2) => x2.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id2) => connectorChains.includes(id2)))
        return false;
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id2) => requestedChains.includes(id2));
    },
    async setRequestedChainsIds(chains) {
      var _a3;
      await ((_a3 = config2.storage) == null ? void 0 : _a3.setItem(this.requestedChainsStorageKey, chains));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}
function Hydrate(parameters) {
  const { children, config: config2, initialState: initialState2, reconnectOnMount = true } = parameters;
  const { onMount } = hydrate(config2, {
    initialState: initialState2,
    reconnectOnMount
  });
  if (!config2._internal.ssr)
    onMount();
  const active = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (!active.current)
      return;
    if (!config2._internal.ssr)
      return;
    onMount();
    return () => {
      active.current = false;
    };
  }, []);
  return children;
}
const WagmiContext = reactExports.createContext(void 0);
function WagmiProvider(parameters) {
  const { children, config: config2 } = parameters;
  const props = { value: config2 };
  return reactExports.createElement(Hydrate, parameters, reactExports.createElement(WagmiContext.Provider, props, children));
}
const version$4 = "2.14.3";
const getVersion = () => `wagmi@${version$4}`;
class BaseError3 extends BaseError$1 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return getVersion();
  }
}
class WagmiProviderNotFoundError extends BaseError3 {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiProviderNotFoundError"
    });
  }
}
function useConfig(parameters = {}) {
  const config2 = parameters.config ?? reactExports.useContext(WagmiContext);
  if (!config2)
    throw new WagmiProviderNotFoundError();
  return config2;
}
function watchChains(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.chains.subscribe((chains, prevChains) => {
    onChange(chains, prevChains);
  });
}
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e = reactExports;
function h$1(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var k = "function" === typeof Object.is ? Object.is : h$1, l = e.useState, m = e.useEffect, n$2 = e.useLayoutEffect, p$1 = e.useDebugValue;
function q$1(a, b2) {
  var d = b2(), f2 = l({ inst: { value: d, getSnapshot: b2 } }), c = f2[0].inst, g = f2[1];
  n$2(function() {
    c.value = d;
    c.getSnapshot = b2;
    r$1(c) && g({ inst: c });
  }, [a, d, b2]);
  m(function() {
    r$1(c) && g({ inst: c });
    return a(function() {
      r$1(c) && g({ inst: c });
    });
  }, [a]);
  p$1(d);
  return d;
}
function r$1(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var d = b2();
    return !k(a, d);
  } catch (f2) {
    return true;
  }
}
function t$1(a, b2) {
  return b2();
}
var u$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$1 : q$1;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u$1;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h = reactExports, n$1 = shimExports;
function p(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var q = "function" === typeof Object.is ? Object.is : p, r = n$1.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b2, e2, l2, g) {
  var c = t(null);
  if (null === c.current) {
    var f2 = { hasValue: false, value: null };
    c.current = f2;
  } else
    f2 = c.current;
  c = v(function() {
    function a2(a3) {
      if (!c2) {
        c2 = true;
        d2 = a3;
        a3 = l2(a3);
        if (void 0 !== g && f2.hasValue) {
          var b3 = f2.value;
          if (g(b3, a3))
            return k2 = b3;
        }
        return k2 = a3;
      }
      b3 = k2;
      if (q(d2, a3))
        return b3;
      var e3 = l2(a3);
      if (void 0 !== g && g(b3, e3))
        return b3;
      d2 = a3;
      return k2 = e3;
    }
    var c2 = false, d2, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a2(b2());
    }, null === m2 ? void 0 : function() {
      return a2(m2());
    }];
  }, [b2, e2, l2, g]);
  var d = r(a, c[0], c[1]);
  u(function() {
    f2.hasValue = true;
    f2.value = d;
  }, [d]);
  w(d);
  return d;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
const isPlainObject$2 = (obj) => typeof obj === "object" && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe, getSnapshot, getServerSnapshot = getSnapshot, isEqual = deepEqual) {
  const trackedKeys = reactExports.useRef([]);
  const result = withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, (x2) => x2, (a, b2) => {
    if (isPlainObject$2(a) && isPlainObject$2(b2) && trackedKeys.current.length) {
      for (const key of trackedKeys.current) {
        const equal = isEqual(a[key], b2[key]);
        if (!equal)
          return false;
      }
      return true;
    }
    return isEqual(a, b2);
  });
  return reactExports.useMemo(() => {
    if (isPlainObject$2(result)) {
      const trackedResult = { ...result };
      let properties = {};
      for (const [key, value] of Object.entries(trackedResult)) {
        properties = {
          ...properties,
          [key]: {
            configurable: false,
            enumerable: true,
            get: () => {
              if (!trackedKeys.current.includes(key)) {
                trackedKeys.current.push(key);
              }
              return value;
            }
          }
        };
      }
      Object.defineProperties(trackedResult, properties);
      return trackedResult;
    }
    return result;
  }, [result]);
}
function useAccount(parameters = {}) {
  const config2 = useConfig(parameters);
  return useSyncExternalStoreWithTracked((onChange) => watchAccount(config2, { onChange }), () => getAccount(config2));
}
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$2() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type: type2 = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type2 !== "all") {
    const isActive = query.isActive();
    if (type2 === "active" && !isActive) {
      return false;
    }
    if (type2 === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject$1(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  if (a && b2 && typeof a === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialMatchKey(a[key], b2[key]));
  }
  return false;
}
function replaceEqualDeep(a, b2) {
  if (a === b2) {
    return a;
  }
  const array2 = isPlainArray(a) && isPlainArray(b2);
  if (array2 || isPlainObject$1(a) && isPlainObject$1(b2)) {
    const aItems = array2 ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array2 ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy = array2 ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array2 ? i : bItems[i];
      if ((!array2 && aItems.includes(key) || array2) && a[key] === void 0 && b2[key] === void 0) {
        copy[key] = void 0;
        equalItems++;
      } else {
        copy[key] = replaceEqualDeep(a[key], b2[key]);
        if (copy[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b2;
}
function shallowEqualObjects(a, b2) {
  if (!b2 || Object.keys(a).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$1(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep$3(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
var FocusManager = (_a2 = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused, void 0);
    __privateAdd(this, _cleanup, void 0);
    __privateAdd(this, _setup, void 0);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a3;
    if (!this.hasListeners()) {
      (_a3 = __privateGet(this, _cleanup)) == null ? void 0 : _a3.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a3;
    __privateSet(this, _setup, setup);
    (_a3 = __privateGet(this, _cleanup)) == null ? void 0 : _a3.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a3;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a3 = globalThis.document) == null ? void 0 : _a3.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a2);
var focusManager = new FocusManager();
var OnlineManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2, void 0);
    __privateAdd(this, _setup2, void 0);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a3;
    if (!this.hasListeners()) {
      (_a3 = __privateGet(this, _cleanup2)) == null ? void 0 : _a3.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a3;
    __privateSet(this, _setup2, setup);
    (_a3 = __privateGet(this, _cleanup2)) == null ? void 0 : _a3.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
var onlineManager = new OnlineManager();
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    var _a3;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a3 = config2.abort) == null ? void 0 : _a3.call(config2);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value) => {
    var _a3;
    if (!isResolved) {
      isResolved = true;
      (_a3 = config2.onSuccess) == null ? void 0 : _a3.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    var _a3;
    if (!isResolved) {
      isResolved = true;
      (_a3 = config2.onError) == null ? void 0 : _a3.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a3;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a3 = config2.onPause) == null ? void 0 : _a3.call(config2);
    }).then(() => {
      var _a3;
      continueFn = void 0;
      if (!isResolved) {
        (_a3 = config2.onContinue) == null ? void 0 : _a3.call(config2);
      }
    });
  };
  const run2 = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a3;
      if (isResolved) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry2 = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry2) {
        reject(error);
        return;
      }
      failureCount++;
      (_a3 = config2.onFail) == null ? void 0 : _a3.call(config2, failureCount, error);
      sleep$3(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run2();
        }
      });
    });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run2();
      } else {
        pause().then(run2);
      }
      return thenable;
    }
  };
}
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb2) => setTimeout(cb2, 0);
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();
var Removable = (_c = class {
  constructor() {
    __privateAdd(this, _gcTimeout, void 0);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _c);
var Query = (_d = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _dispatch);
    __privateAdd(this, _initialState, void 0);
    __privateAdd(this, _revertState, void 0);
    __privateAdd(this, _cache, void 0);
    __privateAdd(this, _retryer, void 0);
    __privateAdd(this, _defaultOptions, void 0);
    __privateAdd(this, _abortSignalConsumed, void 0);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _cache, config2.cache);
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, getDefaultState$1(this.options));
    this.state = config2.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a3;
    return (_a3 = __privateGet(this, _retryer)) == null ? void 0 : _a3.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _dispatch, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a3, _b2;
    const promise = (_a3 = __privateGet(this, _retryer)) == null ? void 0 : _a3.promise;
    (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
    return promise ? promise.then(noop$2).catch(noop$2) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a3;
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a3 = __privateGet(this, _retryer)) == null ? void 0 : _a3.continue();
  }
  onOnline() {
    var _a3;
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a3 = __privateGet(this, _retryer)) == null ? void 0 : _a3.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a3, _b2, _c2;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_a3 = this.options.behavior) == null ? void 0 : _a3.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)) {
      __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context.fetchOptions) == null ? void 0 : _c2.meta });
    }
    const onError = (error) => {
      var _a4, _b3, _c3, _d2;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b3 = (_a4 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
          _a4,
          error,
          this
        );
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          this.state.data,
          error,
          this
        );
      }
      this.scheduleGc();
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _a4, _b3, _c3, _d2;
        if (data === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        (_b3 = (_a4 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a4, data, this);
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          data,
          this.state.error,
          this
        );
        this.scheduleGc();
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _dispatch = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _d);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryCache = (_e = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries, void 0);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client2, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _e);
var Mutation = (_f = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _dispatch2);
    __privateAdd(this, _observers, void 0);
    __privateAdd(this, _mutationCache, void 0);
    __privateAdd(this, _retryer2, void 0);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a3;
    return ((_a3 = __privateGet(this, _retryer2)) == null ? void 0 : _a3.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n, _o, _p, _q, _r2, _s2, _t;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b2 = (_a3 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
          _a3,
          variables,
          this
        ));
        const context = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
        if (context !== this.state.context) {
          __privateMethod(this, _dispatch2, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
        _e2,
        data,
        variables,
        this.state.context,
        this
      ));
      await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data, variables, this.state.context));
      await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
        _i2,
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l2 = (_k2 = this.options).onSettled) == null ? void 0 : _l2.call(_k2, data, null, variables, this.state.context));
      __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_n = (_m2 = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m2,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r2 = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r2.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t = (_s2 = this.options).onSettled) == null ? void 0 : _t.call(
          _s2,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _dispatch2 = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations, void 0);
    __privateAdd(this, _mutationId, void 0);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client2, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client2.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    var _a3;
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = (_a3 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a3.filter((x2) => x2 !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    var _a3;
    const firstPendingMutation = (_a3 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a3.find((m2) => m2.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    var _a3;
    const foundMutation = (_a3 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a3.find((m2) => m2 !== mutation && m2.state.isPaused);
    return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$2))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  var _a3;
  return ((_a3 = mutation.options.scope) == null ? void 0 : _a3.id) ?? String(mutation.mutationId);
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      var _a3, _b2, _c2, _d2, _e2;
      const options = context.options;
      const direction = (_c2 = (_b2 = (_a3 = context.fetchOptions) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
      const oldPages = ((_d2 = context.state.data) == null ? void 0 : _d2.pages) || [];
      const oldPageParams = ((_e2 = context.state.data) == null ? void 0 : _e2.pageParams) || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a4, _b3;
          return (_b3 = (_a4 = context.options).persister) == null ? void 0 : _b3.call(
            _a4,
            fetchFn,
            {
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a3;
  return pages.length > 0 ? (_a3 = options.getPreviousPageParam) == null ? void 0 : _a3.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}
var QueryClient = (_h = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache, void 0);
    __privateAdd(this, _mutationCache2, void 0);
    __privateAdd(this, _defaultOptions2, void 0);
    __privateAdd(this, _queryDefaults, void 0);
    __privateAdd(this, _mutationDefaults, void 0);
    __privateAdd(this, _mountCount, void 0);
    __privateAdd(this, _unsubscribeFocus, void 0);
    __privateAdd(this, _unsubscribeOnline, void 0);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a3, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a3 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a3.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a3;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a3 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a3.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a3;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a3 = __privateGet(this, _queryCache).get(
      options.queryHash
    )) == null ? void 0 : _a3.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$2).catch(noop$2);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if ((filters == null ? void 0 : filters.refetchType) === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (filters == null ? void 0 : filters.refetchType) ?? (filters == null ? void 0 : filters.type) ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$2);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$2);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$2).catch(noop$2);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$2).catch(noop$2);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults2 = [...__privateGet(this, _queryDefaults).values()];
    const result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
var MutationObserver$1 = (_i = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _updateResult);
    __privateAdd(this, _notify);
    __privateAdd(this, _client, void 0);
    __privateAdd(this, _currentResult, void 0);
    __privateAdd(this, _currentMutation, void 0);
    __privateAdd(this, _mutateOptions, void 0);
    __privateSet(this, _client, client2);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _updateResult, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a3;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a3 = __privateGet(this, _currentMutation)) == null ? void 0 : _a3.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a3;
    if (!this.hasListeners()) {
      (_a3 = __privateGet(this, _currentMutation)) == null ? void 0 : _a3.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _updateResult, updateResult_fn).call(this);
    __privateMethod(this, _notify, notify_fn).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  reset() {
    var _a3;
    (_a3 = __privateGet(this, _currentMutation)) == null ? void 0 : _a3.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _updateResult, updateResult_fn).call(this);
    __privateMethod(this, _notify, notify_fn).call(this);
  }
  mutate(variables, options) {
    var _a3;
    __privateSet(this, _mutateOptions, options);
    (_a3 = __privateGet(this, _currentMutation)) == null ? void 0 : _a3.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client).getMutationCache().build(__privateGet(this, _client), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client = new WeakMap(), _currentResult = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _updateResult = new WeakSet(), updateResult_fn = function() {
  var _a3;
  const state = ((_a3 = __privateGet(this, _currentMutation)) == null ? void 0 : _a3.state) ?? getDefaultState();
  __privateSet(this, _currentResult, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, _notify = new WeakSet(), notify_fn = function(action) {
  notifyManager.batch(() => {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult).variables;
      const context = __privateGet(this, _currentResult).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b2 = (_a3 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b2.call(_a3, action.data, variables, context);
        (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f2 = (_e2 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e2, action.error, variables, context);
        (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
          _g2,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult));
    });
  });
}, _i);
function connectMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return connect(config2, variables);
    },
    mutationKey: ["connect"]
  };
}
function disconnectMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return disconnect(config2, variables);
    },
    mutationKey: ["disconnect"]
  };
}
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client2 = reactExports.useContext(QueryClientContext);
  if (queryClient2) {
    return queryClient2;
  }
  if (!client2) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client2;
};
var QueryClientProvider = ({
  client: client2,
  children
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client2, children });
};
function shouldThrowError(throwError2, params) {
  if (typeof throwError2 === "function") {
    return throwError2(...params);
  }
  return !!throwError2;
}
function noop$1() {
}
function useMutation(options, queryClient2) {
  const client2 = useQueryClient(queryClient2);
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client2,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$1);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
function useChains(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchChains(config2, { onChange }), () => getChains(config2), () => getChains(config2));
}
function useConnectors(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchConnectors(config2, { onChange }), () => getConnectors(config2), () => getConnectors(config2));
}
function useConnect(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = connectMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  reactExports.useEffect(() => {
    return config2.subscribe(({ status }) => status, (status, previousStatus) => {
      if (previousStatus === "connected" && status === "disconnected")
        result.reset();
    });
  }, [config2, result.reset]);
  return {
    ...result,
    connect: mutate,
    connectAsync: mutateAsync,
    connectors: useConnectors({ config: config2 })
  };
}
function useConnections(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchConnections(config2, { onChange }), () => getConnections(config2), () => getConnections(config2));
}
function useDisconnect(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = disconnectMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    connectors: useConnections({ config: config2 }).map((connection) => connection.connector),
    disconnect: mutate,
    disconnectAsync: mutateAsync
  };
}
function getEvmInjectedProvider(flag) {
  if (typeof window === "undefined" || typeof window.ethereum === "undefined")
    return;
  const providers2 = window.ethereum.providers;
  return providers2 ? providers2.find((provider) => provider[flag]) : window.ethereum[flag] ? window.ethereum : void 0;
}
function hasEvmInjectedProvider(flag) {
  return Boolean(getEvmInjectedProvider(flag));
}
function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && (/iPad/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile() {
  return isAndroid() || isIOS();
}
function isTMA() {
  if (typeof window === "undefined") {
    return false;
  }
  const check = (host) => {
    return typeof host !== "undefined" && "TelegramWebviewProxy" in host && "postEvent" in host.TelegramWebviewProxy && typeof host.TelegramWebviewProxy.postEvent === "function";
  };
  return check(window);
}
async function sleep$2(duration = 1e3) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(null);
    }, duration);
  });
}
async function openLink(uri, target = "_self") {
  if (!uri)
    return;
  const finalTarget = isTMA() ? "_blank" : target;
  window.open(uri, finalTarget, "noopener noreferrer");
}
function getRecentConnectorId() {
  if (typeof window === "undefined")
    return;
  const recentConnectorId = window.localStorage.getItem("wagmi.recentConnectorId");
  if (recentConnectorId)
    return JSON.parse(recentConnectorId);
}
injected.type = "injected";
function injected(parameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      async provider(window2) {
        return window2 == null ? void 0 : window2.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect2;
  let disconnect2;
  return createConnector((config2) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    /** @deprecated */
    get supportsSimulation() {
      return true;
    },
    type: injected.type,
    async setup() {
      const provider = await this.getProvider();
      if ((provider == null ? void 0 : provider.on) && parameters.target) {
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider.on("connect", connect2);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      var _a3, _b2, _c2, _d2, _e2, _f2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      let accounts2 = [];
      if (isReconnecting2)
        accounts2 = await this.getAccounts().catch(() => []);
      else if (shimDisconnect) {
        try {
          const permissions = await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts2 = (_d2 = (_c2 = (_b2 = (_a3 = permissions[0]) == null ? void 0 : _a3.caveats) == null ? void 0 : _b2[0]) == null ? void 0 : _c2.value) == null ? void 0 : _d2.map((x2) => getAddress$2(x2));
          if (accounts2.length > 0) {
            const sortedAccounts = await this.getAccounts();
            accounts2 = sortedAccounts;
          }
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!(accounts2 == null ? void 0 : accounts2.length) && !isReconnecting2) {
          const requestedAccounts = await provider.request({
            method: "eth_requestAccounts"
          });
          accounts2 = requestedAccounts.map((x2) => getAddress$2(x2));
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        if (shimDisconnect)
          await ((_e2 = config2.storage) == null ? void 0 : _e2.removeItem(`${this.id}.disconnected`));
        if (!parameters.target)
          await ((_f2 = config2.storage) == null ? void 0 : _f2.setItem("injected.connected", true));
        return { accounts: accounts2, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a3, _b2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      try {
        if (this.id !== "trust") {
          await withTimeout(
            () => (
              // TODO: Remove explicit type for viem@3
              provider.request({
                // `'wallet_revokePermissions'` added in `viem@2.10.3`
                method: "wallet_revokePermissions",
                params: [{ eth_accounts: {} }]
              })
            ),
            { timeout: 100 }
          );
        }
      } catch {
      }
      if (shimDisconnect) {
        await ((_a3 = config2.storage) == null ? void 0 : _a3.setItem(`${this.id}.disconnected`, true));
      }
      if (!parameters.target)
        await ((_b2 = config2.storage) == null ? void 0 : _b2.removeItem("injected.connected"));
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const accounts2 = await provider.request({ method: "eth_accounts" });
      return accounts2.map((x2) => getAddress$2(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider = await target.provider(window);
      else if (typeof target.provider === "string")
        provider = findProvider(window, target.provider);
      else
        provider = target.provider;
      if (provider && !provider.removeListener) {
        if ("off" in provider && typeof provider.off === "function")
          provider.removeListener = provider.off;
        else
          provider.removeListener = () => {
          };
      }
      return provider;
    },
    async isAuthorized() {
      var _a3, _b2;
      try {
        const isRecentConnector = getRecentConnectorId() === this.id;
        const disconnected = await ((_a3 = config2.storage) == null ? void 0 : _a3.getItem(`${this.id}.disconnected`));
        const isDisconnected = !shimDisconnect || !isRecentConnector || disconnected === true;
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem("injected.connected"));
          if (!connected)
            return false;
        }
        const provider = await this.getProvider();
        if (!provider) {
          if (unstable_shimAsyncInject !== void 0 && unstable_shimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider2 = await this.getProvider();
              return !!provider2;
            };
            const timeout = typeof unstable_shimAsyncInject === "number" ? unstable_shimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise(
                  (resolve) => window.addEventListener(
                    "ethereum#initialized",
                    () => resolve(handleEthereum()),
                    { once: true }
                  )
                )
              ] : [],
              new Promise(
                (resolve) => setTimeout(() => resolve(handleEthereum()), timeout)
              )
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError();
        }
        const accounts2 = await withRetry(() => this.getAccounts());
        return !!accounts2.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a3, _b2, _c2, _d2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const promise = new Promise((resolve) => {
        const listener = (data) => {
          if ("chainId" in data && data.chainId === chainId) {
            config2.emitter.off("change", listener);
            resolve();
          }
        };
        config2.emitter.on("change", listener);
      });
      try {
        await Promise.all([
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config2.emitter.emit("change", { chainId });
          }),
          promise
        ]);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b2 = (_a3 = error == null ? void 0 : error.data) == null ? void 0 : _a3.originalError) == null ? void 0 : _b2.code) === 4902) {
          try {
            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x2) => x2.url)
              ];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await Promise.all([
              provider.request({
                method: "wallet_addEthereumChain",
                params: [addEthereumChain]
              }).then(async () => {
                const currentChainId = await this.getChainId();
                if (currentChainId === chainId)
                  config2.emitter.emit("change", { chainId });
                else
                  throw new UserRejectedRequestError(
                    new Error("User rejected switch after adding network.")
                  );
              }),
              promise
            ]);
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts2) {
      var _a3;
      const isRecentConnector = getRecentConnectorId() === this.id;
      if (this.id === "trust" && !isRecentConnector)
        return;
      if (accounts2.length === 0)
        this.onDisconnect();
      else if (config2.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await ((_a3 = config2.storage) == null ? void 0 : _a3.removeItem(`${this.id}.disconnected`));
      } else
        config2.emitter.emit("change", {
          accounts: accounts2.map((x2) => getAddress$2(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts2 = await this.getAccounts();
      if (accounts2.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config2.emitter.emit("connect", { accounts: accounts2, chainId });
      const provider = await this.getProvider();
      if (provider) {
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider && !!(await this.getAccounts()).length)
          return;
      }
      config2.emitter.emit("disconnect");
      if (provider) {
        if (chainChanged) {
          provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider.on("connect", connect2);
        }
      }
    }
  }));
}
const targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    async provider(window2) {
      if (window2 == null ? void 0 : window2.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    async provider(window2) {
      return findProvider(window2, (provider) => {
        if (!provider.isMetaMask)
          return false;
        if (provider.isBraveWallet && !provider._events && !provider._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    async provider(window2) {
      var _a3, _b2;
      if ((_a3 = window2 == null ? void 0 : window2.phantom) == null ? void 0 : _a3.ethereum)
        return (_b2 = window2.phantom) == null ? void 0 : _b2.ethereum;
      return findProvider(window2, "isPhantom");
    }
  }
};
function findProvider(window2, select) {
  function isProvider(provider) {
    if (typeof select === "function")
      return select(provider);
    if (typeof select === "string")
      return provider[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum == null ? void 0 : ethereum.providers)
    return ethereum.providers.find((provider) => isProvider(provider));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}
function trustWallet(props = {}) {
  const { connectorOptions, ...restProps } = props;
  return {
    ...trustWalletConfig,
    id: "trust",
    walletType: "evm",
    showQRCode: false,
    isInstalled() {
      return !!getProvider$1$1();
    },
    getDeepLink() {
      const encodedUrl = encodeURIComponent(window.location.href);
      return `https://link.trustwallet.com/open_url?coin_id=60&url=${encodedUrl}`;
    },
    getUri(uri) {
      let encodedUri = encodeURIComponent(uri);
      if (isTMA() && isAndroid()) {
        encodedUri = encodeURIComponent(encodedUri);
      }
      return `https://link.trustwallet.com/wc?uri=${encodedUri}`;
    },
    getCreateConnectorFn() {
      let isReady = false;
      return injected({
        shimDisconnect: true,
        target: {
          id: trustWallet().id,
          name: trustWallet().name,
          async provider() {
            if (!isReady) {
              await sleep$2();
            }
            isReady = true;
            return getProvider$1$1();
          }
        },
        ...connectorOptions
      });
    },
    ...restProps
  };
}
function getProvider$1$1() {
  var _a3;
  if (typeof window === "undefined")
    return;
  if (!((_a3 = window == null ? void 0 : window.trustwallet) == null ? void 0 : _a3.request))
    return;
  return window.trustwallet ?? window.trustWallet ?? getEvmInjectedProvider("isTrust");
}
const WalletConnectTransparentIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_3705_10415)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M11.9465 14.9229C16.3942 10.581 23.605 10.581 28.0527 14.9229L28.5879 15.4454C28.8103 15.6625 28.8103 16.0145 28.5879 16.2316L26.7568 18.0191C26.6457 18.1276 26.4654 18.1276 26.3542 18.0191L25.6176 17.3C22.5149 14.271 17.4843 14.271 14.3816 17.3L13.5928 18.0701C13.4816 18.1786 13.3013 18.1786 13.1901 18.0701L11.359 16.2826C11.1367 16.0655 11.1367 15.7135 11.359 15.4964L11.9465 14.9229ZM31.8395 18.6197L33.4691 20.2105C33.6915 20.4276 33.6915 20.7796 33.4691 20.9967L26.1209 28.1703C25.8986 28.3874 25.538 28.3874 25.3156 28.1703L20.1003 23.079C20.0447 23.0247 19.9546 23.0247 19.899 23.079L14.6838 28.1703C14.4614 28.3874 14.1008 28.3874 13.8785 28.1703L6.53007 20.9966C6.30769 20.7795 6.30769 20.4276 6.53007 20.2105L8.15972 18.6196C8.38209 18.4025 8.74264 18.4025 8.96502 18.6196L14.1804 23.7109C14.236 23.7652 14.3261 23.7652 14.3817 23.7109L19.5969 18.6196C19.8192 18.4025 20.1798 18.4025 20.4021 18.6195L25.6175 23.7109C25.6732 23.7652 25.7633 23.7652 25.8188 23.7109L31.0342 18.6197C31.2565 18.4026 31.6171 18.4026 31.8395 18.6197Z",
        fill: "#3396FF"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_3705_10415", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "40", height: "40", fill: "white" }) }) })
  ] });
};
const WalletConnectIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "40", height: "40", viewBox: "0 0 68 68", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "68", height: "68", rx: "16", fill: "#3396FF" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M20.0995 25.2382C27.7768 17.7435 40.224 17.7435 47.9013 25.2382L48.8252 26.1402C49.209 26.5149 49.209 27.1225 48.8252 27.4972L45.6645 30.5828C45.4726 30.7702 45.1614 30.7702 44.9694 30.5828L43.6979 29.3416C38.3422 24.113 29.6586 24.113 24.3029 29.3416L22.9412 30.6708C22.7493 30.8582 22.438 30.8582 22.2461 30.6708L19.0854 27.5853C18.7016 27.2105 18.7016 26.603 19.0854 26.2282L20.0995 25.2382ZM54.4379 31.6195L57.2509 34.3655C57.6348 34.7403 57.6348 35.3478 57.2509 35.7226L44.5667 48.1054C44.1829 48.4801 43.5606 48.4801 43.1766 48.1054L34.1742 39.317C34.0782 39.2233 33.9227 39.2233 33.8267 39.317L24.8244 48.1054C24.4406 48.4801 23.8182 48.4801 23.4344 48.1054L10.7498 35.7225C10.3659 35.3477 10.3659 34.7402 10.7498 34.3654L13.5629 31.6193C13.9467 31.2446 14.5691 31.2446 14.9529 31.6193L23.9556 40.4077C24.0515 40.5015 24.207 40.5015 24.303 40.4077L33.3052 31.6193C33.689 31.2446 34.3114 31.2446 34.6952 31.6192L43.6978 40.4077C43.7939 40.5015 43.9494 40.5015 44.0453 40.4077L53.0478 31.6195C53.4316 31.2447 54.054 31.2447 54.4379 31.6195Z",
        fill: "white"
      }
    )
  ] });
};
const walletConnectConfig = {
  name: "WalletConnect",
  logos: {
    default: /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectIcon, {}),
    transparent: /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectTransparentIcon, {})
  },
  downloadUrls: {
    default: void 0
  }
};
let evmGlobalData = {};
const setEvmGlobalData = (value) => {
  evmGlobalData = {
    ...evmGlobalData,
    ...value
  };
};
const getEvmGlobalData = () => {
  return evmGlobalData;
};
function walletConnect(props = {}) {
  const { connectorOptions, ...restProps } = props;
  return {
    ...walletConnectConfig,
    id: "walletConnect",
    walletType: "evm",
    showQRCode: !(connectorOptions == null ? void 0 : connectorOptions.showQrModal),
    isInstalled() {
      return false;
    },
    getDeepLink() {
      return void 0;
    },
    getUri(uri) {
      return uri;
    },
    getCreateConnectorFn() {
      const { walletConnectProjectId, metadata } = getEvmGlobalData();
      const hasAllAppData = (metadata == null ? void 0 : metadata.name) && metadata.icon && metadata.description && metadata.url;
      if (!walletConnectProjectId) {
        throw new Error("walletConnectProjectId is required.");
      }
      return walletConnect$1({
        // https://github.com/WalletConnect/walletconnect-monorepo/issues/2830
        relayUrl: "wss://relay.walletconnect.org",
        projectId: walletConnectProjectId,
        metadata: hasAllAppData ? {
          name: metadata.name,
          description: metadata.description,
          url: metadata.url,
          icons: [metadata.icon]
        } : void 0,
        qrModalOptions: {
          explorerRecommendedWalletIds: [
            "8a0ee50d1f22f6651afcae7eb4253e52a3310b90af5daef78a8c4929a9bb99d4",
            "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
            "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"
          ]
        },
        ...connectorOptions,
        showQrModal: true
      });
    },
    ...restProps
  };
}
function isWalletConnect(id2) {
  return id2 === walletConnect().id;
}
const BinanceWalletTransparentIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BinanceWalletIcon, { width: 40, height: 40, ...props });
};
const BinanceWalletIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "40", height: "40", viewBox: "0 0 68 68", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M0 18.1333C0 8.11857 8.11857 0 18.1333 0H49.8667C59.8814 0 68 8.11857 68 18.1333V49.8667C68 59.8814 59.8814 68 49.8667 68H18.1333C8.11857 68 0 59.8814 0 49.8667V18.1333Z",
        fill: "#0B0E11"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M24.7562 30.201L34.0001 20.9572L43.2487 30.2059L48.6274 24.8269L34.0001 10.1992L19.3774 24.8221L24.7562 30.201ZM15.5792 28.6199L20.958 33.9987L15.5789 39.3778L10.2002 33.999L15.5792 28.6199ZM24.7562 37.7973L34.0001 47.0409L43.2485 37.7927L48.6303 43.1688L48.6274 43.1715L34.0001 57.7992L19.3772 43.1763L19.3697 43.1689L24.7562 37.7973ZM57.8002 33.9997L52.4215 39.3785L47.0427 33.9997L52.4215 28.6209L57.8002 33.9997Z",
        fill: "#F0B90B"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M39.4555 33.9965H39.458L33.9999 28.5382L28.5391 33.9991L28.5465 34.0067L33.9999 39.4601L39.4606 33.9991L39.4555 33.9965Z",
        fill: "#F0B90B"
      }
    )
  ] });
};
const binanceWalletConfig = {
  name: "Binance Wallet",
  logos: {
    default: /* @__PURE__ */ jsxRuntimeExports.jsx(BinanceWalletIcon, {}),
    transparent: /* @__PURE__ */ jsxRuntimeExports.jsx(BinanceWalletTransparentIcon, {})
  },
  downloadUrls: {
    default: "https://www.binance.com/en/web3wallet"
  },
  spinnerColor: void 0
};
function binanceWallet(props = {}) {
  const { connectorOptions, ...restProps } = props;
  return {
    ...binanceWalletConfig,
    id: "binanceWallet",
    walletType: "evm",
    showQRCode: true,
    isInstalled() {
      return !!getProvider();
    },
    getDeepLink() {
      const url = window.location.href;
      const base2 = "bnc://app.binance.com/mp/app";
      const appId = "yFK5FCqYprrXDiVFbhyRx7";
      const startPagePath = window.btoa("/pages/browser/index");
      const startPageQuery = window.btoa(`url=${url}`);
      const deeplink = `${base2}?appId=${appId}&startPagePath=${startPagePath}&startPageQuery=${startPageQuery}`;
      const dp = window.btoa(deeplink);
      const http2 = `https://app.binance.com/en/download?_dp=${dp}`;
      return http2;
    },
    getUri(uri) {
      return uri;
    },
    getCreateConnectorFn() {
      let isReady = false;
      return injected({
        shimDisconnect: true,
        target: {
          id: this.id,
          name: binanceWallet().name,
          async provider() {
            if (isMobile() && binanceWallet().isInstalled() && !isReady) {
              await sleep$2(3e3);
            }
            isReady = true;
            return getProvider();
          }
        },
        ...connectorOptions
      });
    },
    ...restProps
  };
}
function binanceWeb3Wallet(props = {}) {
  return {
    ...binanceWallet(props),
    id: "binanceWeb3Wallet"
  };
}
function getProvider() {
  if (typeof window === "undefined")
    return;
  return getEvmInjectedProvider("isBinance");
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code$1.length; i$2 < len; ++i$2) {
  lookup[i$2] = code$1[i$2];
  revLookup[code$1.charCodeAt(i$2)] = i$2;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE2, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE2 ? nBytes - 1 : 0;
  var d = isLE2 ? -1 : 1;
  var s = buffer2[offset2 + i];
  i += d;
  e2 = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i], i += d, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i], i += d, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE2, mLen, nBytes) {
  var e2, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE2 ? 0 : nBytes - 1;
  var d = isLE2 ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e2)) < 1) {
      e2--;
      c *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e2++;
      c /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto2 = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto2, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding2) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding2 === "string" ? createBuffer(size2).fill(fill, encoding2) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding2) {
    return alloc(size2, fill, encoding2);
  };
  function allocUnsafe(size2) {
    assertSize2(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string2, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer2.isEncoding(encoding2)) {
      throw new TypeError("Unknown encoding: " + encoding2);
    }
    const length = byteLength2(string2, encoding2) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string2, encoding2);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array2) {
    const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array2[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array2);
    } else if (length === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2)
      return 0;
    let x2 = a.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x2 = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding2) {
    switch (String(encoding2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding2) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding2, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding2)
      encoding2 = "utf8";
    while (true) {
      switch (encoding2) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = (encoding2 + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding2 = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding2);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding2 !== void 0) {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding2) {
    return this.indexOf(val, byteOffset, encoding2) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
  };
  function hexWrite(buf, string2, offset2, length) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string2.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string2.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset2 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string2, offset2, length) {
    return blitBuffer(utf8ToBytes2(string2, buf.length - offset2), buf, offset2, length);
  }
  function asciiWrite(buf, string2, offset2, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset2, length);
  }
  function base64Write(buf, string2, offset2, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset2, length);
  }
  function ucs2Write(buf, string2, offset2, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
  }
  Buffer2.prototype.write = function write3(string2, offset2, length, encoding2) {
    if (offset2 === void 0) {
      encoding2 = "utf8";
      length = this.length;
      offset2 = 0;
    } else if (length === void 0 && typeof offset2 === "string") {
      encoding2 = offset2;
      length = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding2 === void 0)
          encoding2 = "utf8";
      } else {
        encoding2 = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding2)
      encoding2 = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "hex":
          return hexWrite(this, string2, offset2, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset2, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset2, length);
        case "base64":
          return base64Write(this, string2, offset2, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset2, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes2 = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes2.length - 1; i += 2) {
      res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length) {
    if (offset2 % 1 !== 0 || offset2 < 0)
      throw new RangeError("offset is not uint");
    if (offset2 + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul2 = 1;
    let i = 0;
    while (++i < byteLength3 && (mul2 *= 256)) {
      val += this[offset2 + i] * mul2;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul2 = 1;
    while (byteLength3 > 0 && (mul2 *= 256)) {
      val += this[offset2 + --byteLength3] * mul2;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi2 = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul2 = 1;
    let i = 0;
    while (++i < byteLength3 && (mul2 *= 256)) {
      val += this[offset2 + i] * mul2;
    }
    mul2 *= 128;
    if (val >= mul2)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let i = byteLength3;
    let mul2 = 1;
    let val = this[offset2 + --i];
    while (i > 0 && (mul2 *= 256)) {
      val += this[offset2 + --i] * mul2;
    }
    mul2 *= 128;
    if (val >= mul2)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128))
      return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul2 = 1;
    let i = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul2 *= 256)) {
      this[offset2 + i] = value / mul2 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul2 = 1;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul2 *= 256)) {
      this[offset2 + i] = value / mul2 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min, max) {
    checkIntBI(value, min, max, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min, max) {
    checkIntBI(value, min, max, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2] = hi2;
    return offset2 + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul2 = 1;
    let sub = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul2 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul2 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul2 = 1;
    let sub = 0;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul2 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul2 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max, min) {
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset2 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding2) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding2 = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding2 = end;
        end = this.length;
      }
      if (encoding2 !== void 0 && typeof encoding2 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding2 === "utf8" && code2 < 128 || encoding2 === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
      const len = bytes2.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes2[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset2, byteLength3) {
    if (value > max || value < min) {
      const n2 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range = `>= ${min}${n2} and <= ${max}${n2}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type2 || "offset",
      `>= ${type2 ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string2.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi2, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset2, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset2 >= dst.length || i >= src2.length)
        break;
      dst[i + offset2] = src2[i];
    }
    return i;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64$1), l: Number(n2 >> _32n$1 & U32_MASK64$1) };
  return { h: Number(n2 >> _32n$1 & U32_MASK64$1) | 0, l: Number(n2 & U32_MASK64$1) | 0 };
}
function split$1(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l: l2 } = fromBig$1(lst[i], le2);
    [Ah2[i], Al[i]] = [h2, l2];
  }
  return [Ah2, Al];
}
const toBig$1 = (h2, l2) => BigInt(h2 >>> 0) << _32n$1 | BigInt(l2 >>> 0);
const shrSH$1 = (h2, _l2, s) => h2 >>> s;
const shrSL$1 = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
const rotrSH$1 = (h2, l2, s) => h2 >>> s | l2 << 32 - s;
const rotrSL$1 = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
const rotrBH$1 = (h2, l2, s) => h2 << 64 - s | l2 >>> s - 32;
const rotrBL$1 = (h2, l2, s) => h2 >>> s - 32 | l2 << 64 - s;
const rotr32H$1 = (_h2, l2) => l2;
const rotr32L$1 = (h2, _l2) => h2;
const rotlSH$1 = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
const rotlSL$1 = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
const rotlBH$1 = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
const rotlBL$1 = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
function add$1(Ah2, Al, Bh2, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah2 + Bh2 + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
const add3L$1 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H$1 = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
const add4L$1 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H$1 = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
const add5L$1 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H$1 = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
const u64$3 = {
  fromBig: fromBig$1,
  split: split$1,
  toBig: toBig$1,
  shrSH: shrSH$1,
  shrSL: shrSL$1,
  rotrSH: rotrSH$1,
  rotrSL: rotrSL$1,
  rotrBH: rotrBH$1,
  rotrBL: rotrBL$1,
  rotr32H: rotr32H$1,
  rotr32L: rotr32L$1,
  rotlSH: rotlSH$1,
  rotlSL: rotlSL$1,
  rotlBH: rotlBH$1,
  rotlBL: rotlBL$1,
  add: add$1,
  add3L: add3L$1,
  add3H: add3H$1,
  add4L: add4L$1,
  add4H: add4H$1,
  add5H: add5H$1,
  add5L: add5L$1
};
const u64$4 = u64$3;
const [SHA512_Kh$1, SHA512_Kl$1] = /* @__PURE__ */ (() => u64$4.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
const SHA512_W_H$1 = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L$1 = /* @__PURE__ */ new Uint32Array(80);
let SHA512$1 = class SHA512 extends HashMD$1 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    return [Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl];
  }
  // prettier-ignore
  set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl) {
    this.Ah = Ah2 | 0;
    this.Al = Al | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh2 | 0;
    this.El = El | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4) {
      SHA512_W_H$1[i] = view.getUint32(offset2);
      SHA512_W_L$1[i] = view.getUint32(offset2 += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H$1[i - 15] | 0;
      const W15l = SHA512_W_L$1[i - 15] | 0;
      const s0h = u64$4.rotrSH(W15h, W15l, 1) ^ u64$4.rotrSH(W15h, W15l, 8) ^ u64$4.shrSH(W15h, W15l, 7);
      const s0l = u64$4.rotrSL(W15h, W15l, 1) ^ u64$4.rotrSL(W15h, W15l, 8) ^ u64$4.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H$1[i - 2] | 0;
      const W2l = SHA512_W_L$1[i - 2] | 0;
      const s1h = u64$4.rotrSH(W2h, W2l, 19) ^ u64$4.rotrBH(W2h, W2l, 61) ^ u64$4.shrSH(W2h, W2l, 6);
      const s1l = u64$4.rotrSL(W2h, W2l, 19) ^ u64$4.rotrBL(W2h, W2l, 61) ^ u64$4.shrSL(W2h, W2l, 6);
      const SUMl = u64$4.add4L(s0l, s1l, SHA512_W_L$1[i - 7], SHA512_W_L$1[i - 16]);
      const SUMh = u64$4.add4H(SUMl, s0h, s1h, SHA512_W_H$1[i - 7], SHA512_W_H$1[i - 16]);
      SHA512_W_H$1[i] = SUMh | 0;
      SHA512_W_L$1[i] = SUMl | 0;
    }
    let { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64$4.rotrSH(Eh2, El, 14) ^ u64$4.rotrSH(Eh2, El, 18) ^ u64$4.rotrBH(Eh2, El, 41);
      const sigma1l = u64$4.rotrSL(Eh2, El, 14) ^ u64$4.rotrSL(Eh2, El, 18) ^ u64$4.rotrBL(Eh2, El, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64$4.add5L(Hl, sigma1l, CHIl, SHA512_Kl$1[i], SHA512_W_L$1[i]);
      const T1h = u64$4.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh$1[i], SHA512_W_H$1[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64$4.rotrSH(Ah2, Al, 28) ^ u64$4.rotrBH(Ah2, Al, 34) ^ u64$4.rotrBH(Ah2, Al, 39);
      const sigma0l = u64$4.rotrSL(Ah2, Al, 28) ^ u64$4.rotrBL(Ah2, Al, 34) ^ u64$4.rotrBL(Ah2, Al, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh2 = Gh2 | 0;
      Hl = Gl | 0;
      Gh2 = Fh2 | 0;
      Gl = Fl | 0;
      Fh2 = Eh2 | 0;
      Fl = El | 0;
      ({ h: Eh2, l: El } = u64$4.add(Dh2 | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl = Cl | 0;
      Ch2 = Bh2 | 0;
      Cl = Bl | 0;
      Bh2 = Ah2 | 0;
      Bl = Al | 0;
      const All = u64$4.add3L(T1l, sigma0l, MAJl);
      Ah2 = u64$4.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah2, l: Al } = u64$4.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al | 0));
    ({ h: Bh2, l: Bl } = u64$4.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl | 0));
    ({ h: Ch2, l: Cl } = u64$4.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl | 0));
    ({ h: Dh2, l: Dl } = u64$4.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl | 0));
    ({ h: Eh2, l: El } = u64$4.add(this.Eh | 0, this.El | 0, Eh2 | 0, El | 0));
    ({ h: Fh2, l: Fl } = u64$4.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl | 0));
    ({ h: Gh2, l: Gl } = u64$4.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl | 0));
    ({ h: Hh2, l: Hl } = u64$4.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl | 0));
    this.set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl);
  }
  roundClean() {
    SHA512_W_H$1.fill(0);
    SHA512_W_L$1.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const sha512$1 = /* @__PURE__ */ wrapConstructor$2(() => new SHA512$1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$9 = BigInt(0), _1n$c = BigInt(1), _2n$8 = BigInt(2), _8n$3 = BigInt(8);
const VERIFY_DEFAULT = { zip215: true };
function validateOpts$2(curve) {
  const opts = validateBasic$2(curve);
  validateObject$2(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts$2(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n$8 << BigInt(nByteLength * 8) - _1n$c;
  const modP = Fp2.create;
  const Fn = Field$2(CURVE.n, CURVE.nBitLength);
  const uvRatio2 = CURVE.uvRatio || ((u2, v2) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u2 * Fp2.inv(v2)) };
    } catch (e2) {
      return { isValid: false, value: _0n$9 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n2) {
    aInRange("coordinate " + title, n2, _0n$9, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { ex: x2, ey: y2, ez: z2 } = p2;
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? _8n$3 : Fp2.inv(z2);
    const ax = modP(x2 * iz);
    const ay = modP(y2 * iz);
    const zz = modP(z2 * iz);
    if (is0)
      return { x: _0n$9, y: _1n$c };
    if (zz !== _1n$c)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p2) => {
    const { a, d } = CURVE;
    if (p2.is0())
      throw new Error("bad point: ZERO");
    const { ex: X2, ey: Y2, ez: Z2, et: T9 } = p2;
    const X22 = modP(X2 * X2);
    const Y22 = modP(Y2 * Y2);
    const Z22 = modP(Z2 * Z2);
    const Z4 = modP(Z22 * Z22);
    const aX2 = modP(X22 * a);
    const left = modP(Z22 * modP(aX2 + Y22));
    const right = modP(Z4 + modP(d * modP(X22 * Y22)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X2 * Y2);
    const ZT = modP(Z2 * T9);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p2) {
      if (p2 instanceof Point)
        throw new Error("extended point not allowed");
      const { x: x2, y: y2 } = p2 || {};
      aCoordinate("x", x2);
      aCoordinate("y", y2);
      return new Point(x2, y2, _1n$c, modP(x2 * y2));
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.ez));
      return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A2 = modP(X1 * X1);
      const B2 = modP(Y1 * Y1);
      const C2 = modP(_2n$8 * modP(Z1 * Z1));
      const D2 = modP(a * A2);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A2 - B2);
      const G3 = D2 + B2;
      const F2 = G3 - C2;
      const H2 = D2 - B2;
      const X3 = modP(E2 * F2);
      const Y3 = modP(G3 * H2);
      const T32 = modP(E2 * H2);
      const Z3 = modP(F2 * G3);
      return new Point(X3, Y3, Z3, T32);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T12 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T22 } = other;
      if (a === BigInt(-1)) {
        const A3 = modP((Y1 - X1) * (Y2 + X2));
        const B3 = modP((Y1 + X1) * (Y2 - X2));
        const F3 = modP(B3 - A3);
        if (F3 === _0n$9)
          return this.double();
        const C3 = modP(Z1 * _2n$8 * T22);
        const D3 = modP(T12 * _2n$8 * Z2);
        const E3 = D3 + C3;
        const G4 = B3 + A3;
        const H3 = D3 - C3;
        const X32 = modP(E3 * F3);
        const Y32 = modP(G4 * H3);
        const T33 = modP(E3 * H3);
        const Z32 = modP(F3 * G4);
        return new Point(X32, Y32, Z32, T33);
      }
      const A2 = modP(X1 * X2);
      const B2 = modP(Y1 * Y2);
      const C2 = modP(T12 * d * T22);
      const D2 = modP(Z1 * Z2);
      const E2 = modP((X1 + Y1) * (X2 + Y2) - A2 - B2);
      const F2 = D2 - C2;
      const G3 = D2 + C2;
      const H2 = modP(B2 - a * A2);
      const X3 = modP(E2 * F2);
      const Y3 = modP(G3 * H2);
      const T32 = modP(E2 * H2);
      const Z3 = modP(F2 * G3);
      return new Point(X3, Y3, Z3, T32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, n2, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n2 = scalar;
      aInRange("scalar", n2, _1n$c, CURVE_ORDER);
      const { p: p2, f: f2 } = this.wNAF(n2);
      return Point.normalizeZ([p2, f2])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      const n2 = scalar;
      aInRange("scalar", n2, _0n$9, CURVE_ORDER);
      if (n2 === _0n$9)
        return I2;
      if (this.is0() || n2 === _1n$c)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n2, Point.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n$c)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes$2("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y2 = bytesToNumberLE$2(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y2, _0n$9, max);
      const y22 = modP(y2 * y2);
      const u2 = modP(y22 - _1n$c);
      const v2 = modP(d * y22 - a);
      let { isValid: isValid2, value: x2 } = uvRatio2(u2, v2);
      if (!isValid2)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n$c) === _1n$c;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n$9 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point.fromAffine({ x: x2, y: y2 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x2, y: y2 } = this.toAffine();
      const bytes2 = numberToBytesLE$2(y2, Fp2.BYTES);
      bytes2[bytes2.length - 1] |= x2 & _1n$c ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex$2(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$c, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n$9, _1n$c, _1n$c, _0n$9);
  const { BASE: G2, ZERO: I2 } = Point;
  const wnaf = wNAF$2(Point, nByteLength * 8);
  function modN(a) {
    return mod$2(a, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE$2(hash2));
  }
  function getExtendedPublicKey(key) {
    const len = Fp2.BYTES;
    key = ensureBytes$2("private key", key, len);
    const hashed = ensureBytes$2("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G2.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes$4(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes$2("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options = {}) {
    msg = ensureBytes$2("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r2 = hashDomainToScalar(options.context, prefix, msg);
    const R2 = G2.multiply(r2).toRawBytes();
    const k2 = hashDomainToScalar(options.context, R2, pointBytes, msg);
    const s = modN(r2 + k2 * scalar);
    aInRange("signature.s", s, _0n$9, CURVE_ORDER);
    const res = concatBytes$4(R2, numberToBytesLE$2(s, Fp2.BYTES));
    return ensureBytes$2("result", res, Fp2.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify2(sig, msg, publicKey2, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes$2("signature", sig, 2 * len);
    msg = ensureBytes$2("message", msg);
    publicKey2 = ensureBytes$2("publicKey", publicKey2, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE$2(sig.slice(len, 2 * len));
    let A2, R2, SB;
    try {
      A2 = Point.fromHex(publicKey2, zip215);
      R2 = Point.fromHex(sig.slice(0, len), zip215);
      SB = G2.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A2.isSmallOrder())
      return false;
    const k2 = hashDomainToScalar(context, R2.toRawBytes(), A2.toRawBytes(), msg);
    const RkA = R2.add(A2.multiplyUnsafe(k2));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G2._setWindowSize(8);
  const utils2 = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign: sign2,
    verify: verify2,
    ExtendedPoint: Point,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$b = BigInt(1), _2n$7 = BigInt(2);
BigInt(3);
const _5n$2 = BigInt(5), _8n$2 = BigInt(8);
function ed25519_pow_2_252_3(x2) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P2 = ED25519_P;
  const x22 = x2 * x2 % P2;
  const b2 = x22 * x2 % P2;
  const b4 = pow2$2(b2, _2n$7, P2) * b2 % P2;
  const b5 = pow2$2(b4, _1n$b, P2) * x2 % P2;
  const b10 = pow2$2(b5, _5n$2, P2) * b5 % P2;
  const b20 = pow2$2(b10, _10n, P2) * b10 % P2;
  const b40 = pow2$2(b20, _20n, P2) * b20 % P2;
  const b80 = pow2$2(b40, _40n, P2) * b40 % P2;
  const b160 = pow2$2(b80, _80n, P2) * b80 % P2;
  const b240 = pow2$2(b160, _80n, P2) * b80 % P2;
  const b250 = pow2$2(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow2$2(b250, _2n$7, P2) * x2 % P2;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u2, v2) {
  const P2 = ED25519_P;
  const v32 = mod$2(v2 * v2 * v2, P2);
  const v7 = mod$2(v32 * v32 * v2, P2);
  const pow3 = ed25519_pow_2_252_3(u2 * v7).pow_p_5_8;
  let x2 = mod$2(u2 * v32 * pow3, P2);
  const vx2 = mod$2(v2 * x2 * x2, P2);
  const root1 = x2;
  const root2 = mod$2(x2 * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod$2(-u2, P2);
  const noRoot = vx2 === mod$2(-u2 * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE(x2, P2))
    x2 = mod$2(-x2, P2);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
const Fp$2 = /* @__PURE__ */ (() => Field$2(ED25519_P, void 0, true))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field p over which we'll do calculations; 2n**255n - 19n
  Fp: Fp$2,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n$2,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512$1,
  randomBytes: randomBytes$4,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}))();
const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var bn = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
bn.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$1.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w2;
      var off = 0;
      if (endian === "be") {
        for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
          w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number2.length; i += 3) {
          w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c = string2.charCodeAt(index2);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w2;
      if (endian === "be") {
        for (i = number2.length - 1; i >= start; i -= 2) {
          w2 = parseHexByte(number2, start, i) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
          w2 = parseHexByte(number2, start, i) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul2) {
      var r2 = 0;
      var b2 = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r2 *= mul2;
        if (c >= 49) {
          b2 = c - 49 + 10;
        } else if (c >= 17) {
          b2 = c - 17 + 10;
        } else {
          b2 = c;
        }
        assert2(c >= 0 && b2 < mul2, "Invalid character");
        r2 += b2;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod2 = total % limbLen;
      var end = Math.min(total, total - mod2) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number2, i, i + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow3 = 1;
        word = parseBase(number2, i, number2.length, base2);
        for (i = 0; i < mod2; i++) {
          pow3 *= base2;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
      } catch (e2) {
        BN2.prototype.inspect = inspect;
      }
    } else {
      BN2.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString3(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = this.words[i];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r2 = c.modrn(groupBase).toString(base2);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size2) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size2);
      }
      return new ArrayType(size2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b2 = this._zeroBits(this.words[i]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos2(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos2(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i = 0; i < b2.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      for (var i = 0; i < b2.length; i++) {
        this.words[i] = a.words[i] ^ b2.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a, b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0; i < b2.length; i++) {
        r2 = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add2(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b2;
      if (cmp > 0) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0; i < b2.length; i++) {
        r2 = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r2 = (a.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i = k2 - j | 0;
          a = self2.words[i] | 0;
          b2 = num.words[j] | 0;
          r2 = a * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i = k2 - j;
          var a = self2.words[i] | 0;
          var b2 = num.words[j] | 0;
          var r2 = a * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul2(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w2 = (this.words[i] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow3(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w2.length; i++, res = res.sqr()) {
        if (w2[i] !== 0)
          break;
      }
      if (++i < w2.length) {
        for (var q2 = res.sqr(); i < w2.length; i++, q2 = q2.sqr()) {
          if (w2[i] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s = Math.min((bits - r2) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0)
        ;
      else if (this.length > s) {
        this.length -= s;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s)
        return false;
      var w2 = this.words[s];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r2 !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r2 !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask2;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul2, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul2;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w2 & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w2 = -(this.words[i] | 0) + carry;
        carry = w2 >> 26;
        this.words[i] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i = 0; i < q2.length; i++) {
          q2.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j = m2 - 1; j >= 0; j--) {
        var qj2 = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a._ishlnsubmul(b2, qj2, j);
        while (a.negative !== 0) {
          qj2--;
          a.negative = 0;
          a._ishlnsubmul(b2, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j] = qj2;
        }
      }
      if (q2) {
        q2._strip();
      }
      a._strip();
      if (mode2 !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p2 * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w2 = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i = 0, im = 1; (x2.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x2.iushrn(i);
          while (i-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y2.iushrn(j);
          while (j-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a = this;
      var b2 = p2.clone();
      if (a.negative !== 0) {
        a = a.umod(p2);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b2.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b2) >= 0) {
          a.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b2 = num.clone();
      a.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
        a.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a.cmp(b2);
        if (r2 < 0) {
          var t2 = a;
          a = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd2() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q2;
        return this;
      }
      var carry = q2;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w2 = this.words[i] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i] = w2;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b2 = num.words[i] | 0;
        if (a === b2)
          continue;
        if (a < b2) {
          res = -1;
        } else if (a > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p2) {
      this.name = name;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output2) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output2.words[i] = input.words[i];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask2;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w2 = num.words[i] | 0;
        lo += w2 * 977;
        num.words[i] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi2 = (num.words[i] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b2) {
      assert2((a.negative | b2.negative) === 0, "red works only with positives");
      assert2(
        a.red && a.red === b2.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add2(a, b2) {
      this._verify2(a, b2);
      var res = a.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b2) {
      this._verify2(a, b2);
      var res = a.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b2) {
      this._verify2(a, b2);
      var res = a.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b2) {
      this._verify2(a, b2);
      var res = a.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.imul(b2));
    };
    Red.prototype.mul = function mul2(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.mul(b2));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow3 = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow3);
      }
      var q2 = this.m.subn(1);
      var s = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c = this.pow(z2, q2);
      var r2 = this.pow(a, q2.addn(1).iushrn(1));
      var t2 = this.pow(a, q2);
      var m2 = s;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m2);
        var b2 = this.pow(c, new BN2(1).iushln(m2 - i - 1));
        r2 = r2.redMul(b2);
        c = b2.redSqr();
        t2 = t2.redMul(c);
        m2 = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow3(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a, b2) {
      if (a.isZero() || b2.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t2 = a.imul(b2);
      var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul2(a, b2) {
      if (a.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a.mul(b2);
      var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN = /* @__PURE__ */ getDefaultExportFromCjs$1(bnExports);
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports) {
  var buffer$12 = buffer;
  var Buffer2 = buffer$12.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer$12;
  } else {
    copyProps(buffer$12, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size2, fill, encoding2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size2);
    if (fill !== void 0) {
      if (typeof encoding2 === "string") {
        buf.fill(fill, encoding2);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer$12.SlowBuffer(size2);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var _Buffer = safeBufferExports.Buffer;
function base$2(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x2 = ALPHABET2.charAt(i);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i;
  }
  var BASE2 = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode4(source) {
    if (Array.isArray(source) || source instanceof Uint8Array) {
      source = _Buffer.from(source);
    }
    if (!_Buffer.isBuffer(source)) {
      throw new TypeError("Expected Buffer");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      pbegin++;
    }
    var it2 = size2 - length;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return _Buffer.alloc(0);
    }
    var psz = 0;
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (psz < source.length) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      psz++;
    }
    var it4 = size2 - length;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size2 - it4));
    vch.fill(0, 0, zeroes);
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode3(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode3
  };
}
var src$1 = base$2;
var basex$1 = src$1;
var ALPHABET$3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$2 = basex$1(ALPHABET$3);
const bs58$3 = /* @__PURE__ */ getDefaultExportFromCjs$1(bs58$2);
var lib = {};
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0)
    return {};
  if (o === Object(o))
    return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string2) {
  var s = String(string2);
  var n2 = s.length;
  var i = 0;
  var u2 = [];
  while (i < n2) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u2.push(c);
    } else if (56320 <= c && c <= 57343) {
      u2.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n2 - 1) {
        u2.push(65533);
      } else {
        var d = string2.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b2 = d & 1023;
          u2.push(65536 + (a << 10) + b2);
          i += 1;
        } else {
          u2.push(65533);
        }
      }
    }
    i += 1;
  }
  return u2;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s;
}
var end_of_stream = -1;
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    if (!this.tokens.length)
      return end_of_stream;
    return this.tokens.shift();
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(token) {
    if (Array.isArray(token)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token
      );
      while (tokens.length)
        this.tokens.unshift(tokens.pop());
    } else {
      this.tokens.unshift(token);
    }
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(token) {
    if (Array.isArray(token)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token
      );
      while (tokens.length)
        this.tokens.push(tokens.shift());
    } else {
      this.tokens.push(token);
    }
  }
};
var finished = -1;
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(encoding2, options) {
  if (!(this instanceof TextDecoder$1)) {
    return new TextDecoder$1(encoding2, options);
  }
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function decode(input, options) {
    var bytes2;
    if (typeof input === "object" && input instanceof ArrayBuffer) {
      bytes2 = new Uint8Array(input);
    } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
      bytes2 = new Uint8Array(
        input.buffer,
        input.byteOffset,
        input.byteLength
      );
    } else {
      bytes2 = new Uint8Array(0);
    }
    options = ToDictionary(options);
    if (!this._streaming) {
      this._decoder = new UTF8Decoder({ fatal: this._fatal });
      this._BOMseen = false;
    }
    this._streaming = Boolean(options["stream"]);
    var input_stream = new Stream(bytes2);
    var code_points = [];
    var result;
    while (!input_stream.endOfStream()) {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        code_points.push.apply(
          code_points,
          /**@type {!Array.<number>}*/
          result
        );
      else
        code_points.push(result);
    }
    if (!this._streaming) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(
            code_points,
            /**@type {!Array.<number>}*/
            result
          );
        else
          code_points.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }
    if (code_points.length) {
      if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
        if (code_points[0] === 65279) {
          this._BOMseen = true;
          code_points.shift();
        } else {
          this._BOMseen = true;
        }
      }
    }
    return codePointsToString(code_points);
  }
};
function TextEncoder$1(encoding2, options) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(encoding2, options);
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : "";
    options = ToDictionary(options);
    if (!this._streaming)
      this._encoder = new UTF8Encoder(this._options);
    this._streaming = Boolean(options["stream"]);
    var bytes2 = [];
    var input_stream = new Stream(stringToCodePoints(opt_string));
    var result;
    while (!input_stream.endOfStream()) {
      result = this._encoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        bytes2.push.apply(
          bytes2,
          /**@type {!Array.<number>}*/
          result
        );
      else
        bytes2.push(result);
    }
    if (!this._streaming) {
      while (true) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes2.push.apply(
            bytes2,
            /**@type {!Array.<number>}*/
            result
          );
        else
          bytes2.push(result);
      }
      this._encoder = null;
    }
    return new Uint8Array(bytes2);
  }
};
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count, offset2;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset2 = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset2 = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset2 = 240;
    }
    var bytes2 = [(code_point >> 6 * count) + offset2];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes2.push(128 | temp & 63);
      count -= 1;
    }
    return bytes2;
  };
}
const encoding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(encoding$1);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  Object.defineProperty(o, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
  Object.defineProperty(o, "default", { enumerable: true, value: v2 });
} : function(o, v2) {
  o["default"] = v2;
});
var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2)
      if (k2 !== "default" && Object.hasOwnProperty.call(mod2, k2))
        __createBinding(result, mod2, k2);
  }
  __setModuleDefault(result, mod2);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(lib, "__esModule", { value: true });
var deserializeUnchecked_1 = lib.deserializeUnchecked = deserialize_1 = lib.deserialize = serialize_1 = lib.serialize = lib.BinaryReader = lib.BinaryWriter = lib.BorshError = lib.baseDecode = lib.baseEncode = void 0;
const bn_js_1 = __importDefault(bnExports);
const bs58_1 = __importDefault(bs58$2);
const encoding = __importStar(require$$2);
const ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
const textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
function baseEncode(value) {
  if (typeof value === "string") {
    value = Buffer.from(value, "utf8");
  }
  return bs58_1.default.encode(Buffer.from(value));
}
lib.baseEncode = baseEncode;
function baseDecode(value) {
  return Buffer.from(bs58_1.default.decode(value));
}
lib.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
  constructor(message2) {
    super(message2);
    this.fieldPath = [];
    this.originalMessage = message2;
  }
  addToFieldPath(fieldName) {
    this.fieldPath.splice(0, 0, fieldName);
    this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
lib.BorshError = BorshError;
class BinaryWriter {
  constructor() {
    this.buf = Buffer.alloc(INITIAL_LENGTH);
    this.length = 0;
  }
  maybeResize() {
    if (this.buf.length < 16 + this.length) {
      this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
    }
  }
  writeU8(value) {
    this.maybeResize();
    this.buf.writeUInt8(value, this.length);
    this.length += 1;
  }
  writeU16(value) {
    this.maybeResize();
    this.buf.writeUInt16LE(value, this.length);
    this.length += 2;
  }
  writeU32(value) {
    this.maybeResize();
    this.buf.writeUInt32LE(value, this.length);
    this.length += 4;
  }
  writeU64(value) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
  }
  writeU128(value) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
  }
  writeU256(value) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
  }
  writeU512(value) {
    this.maybeResize();
    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
  }
  writeBuffer(buffer2) {
    this.buf = Buffer.concat([
      Buffer.from(this.buf.subarray(0, this.length)),
      buffer2,
      Buffer.alloc(INITIAL_LENGTH)
    ]);
    this.length += buffer2.length;
  }
  writeString(str) {
    this.maybeResize();
    const b2 = Buffer.from(str, "utf8");
    this.writeU32(b2.length);
    this.writeBuffer(b2);
  }
  writeFixedArray(array2) {
    this.writeBuffer(Buffer.from(array2));
  }
  writeArray(array2, fn) {
    this.maybeResize();
    this.writeU32(array2.length);
    for (const elem of array2) {
      this.maybeResize();
      fn(elem);
    }
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
lib.BinaryWriter = BinaryWriter;
function handlingRangeError(target, propertyKey, propertyDescriptor) {
  const originalMethod = propertyDescriptor.value;
  propertyDescriptor.value = function(...args) {
    try {
      return originalMethod.apply(this, args);
    } catch (e2) {
      if (e2 instanceof RangeError) {
        const code2 = e2.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code2) >= 0) {
          throw new BorshError("Reached the end of buffer when deserializing");
        }
      }
      throw e2;
    }
  };
}
class BinaryReader {
  constructor(buf) {
    this.buf = buf;
    this.offset = 0;
  }
  readU8() {
    const value = this.buf.readUInt8(this.offset);
    this.offset += 1;
    return value;
  }
  readU16() {
    const value = this.buf.readUInt16LE(this.offset);
    this.offset += 2;
    return value;
  }
  readU32() {
    const value = this.buf.readUInt32LE(this.offset);
    this.offset += 4;
    return value;
  }
  readU64() {
    const buf = this.readBuffer(8);
    return new bn_js_1.default(buf, "le");
  }
  readU128() {
    const buf = this.readBuffer(16);
    return new bn_js_1.default(buf, "le");
  }
  readU256() {
    const buf = this.readBuffer(32);
    return new bn_js_1.default(buf, "le");
  }
  readU512() {
    const buf = this.readBuffer(64);
    return new bn_js_1.default(buf, "le");
  }
  readBuffer(len) {
    if (this.offset + len > this.buf.length) {
      throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
    }
    const result = this.buf.slice(this.offset, this.offset + len);
    this.offset += len;
    return result;
  }
  readString() {
    const len = this.readU32();
    const buf = this.readBuffer(len);
    try {
      return textDecoder.decode(buf);
    } catch (e2) {
      throw new BorshError(`Error decoding UTF-8 string: ${e2}`);
    }
  }
  readFixedArray(len) {
    return new Uint8Array(this.readBuffer(len));
  }
  readArray(fn) {
    const len = this.readU32();
    const result = Array();
    for (let i = 0; i < len; ++i) {
      result.push(fn());
    }
    return result;
  }
}
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readArray", null);
lib.BinaryReader = BinaryReader;
function capitalizeFirstLetter(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function serializeField(schema, fieldName, value, fieldType, writer) {
  try {
    if (typeof fieldType === "string") {
      writer[`write${capitalizeFirstLetter(fieldType)}`](value);
    } else if (fieldType instanceof Array) {
      if (typeof fieldType[0] === "number") {
        if (value.length !== fieldType[0]) {
          throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
        }
        writer.writeFixedArray(value);
      } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
        if (value.length !== fieldType[1]) {
          throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
        }
        for (let i = 0; i < fieldType[1]; i++) {
          serializeField(schema, null, value[i], fieldType[0], writer);
        }
      } else {
        writer.writeArray(value, (item) => {
          serializeField(schema, fieldName, item, fieldType[0], writer);
        });
      }
    } else if (fieldType.kind !== void 0) {
      switch (fieldType.kind) {
        case "option": {
          if (value === null || value === void 0) {
            writer.writeU8(0);
          } else {
            writer.writeU8(1);
            serializeField(schema, fieldName, value, fieldType.type, writer);
          }
          break;
        }
        case "map": {
          writer.writeU32(value.size);
          value.forEach((val, key) => {
            serializeField(schema, fieldName, key, fieldType.key, writer);
            serializeField(schema, fieldName, val, fieldType.value, writer);
          });
          break;
        }
        default:
          throw new BorshError(`FieldType ${fieldType} unrecognized`);
      }
    } else {
      serializeStruct(schema, value, writer);
    }
  } catch (error) {
    if (error instanceof BorshError) {
      error.addToFieldPath(fieldName);
    }
    throw error;
  }
}
function serializeStruct(schema, obj, writer) {
  if (typeof obj.borshSerialize === "function") {
    obj.borshSerialize(writer);
    return;
  }
  const structSchema = schema.get(obj.constructor);
  if (!structSchema) {
    throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
  }
  if (structSchema.kind === "struct") {
    structSchema.fields.map(([fieldName, fieldType]) => {
      serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
    });
  } else if (structSchema.kind === "enum") {
    const name = obj[structSchema.field];
    for (let idx = 0; idx < structSchema.values.length; ++idx) {
      const [fieldName, fieldType] = structSchema.values[idx];
      if (fieldName === name) {
        writer.writeU8(idx);
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        break;
      }
    }
  } else {
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
  }
}
function serialize(schema, obj, Writer2 = BinaryWriter) {
  const writer = new Writer2();
  serializeStruct(schema, obj, writer);
  return writer.toArray();
}
var serialize_1 = lib.serialize = serialize;
function deserializeField(schema, fieldName, fieldType, reader) {
  try {
    if (typeof fieldType === "string") {
      return reader[`read${capitalizeFirstLetter(fieldType)}`]();
    }
    if (fieldType instanceof Array) {
      if (typeof fieldType[0] === "number") {
        return reader.readFixedArray(fieldType[0]);
      } else if (typeof fieldType[1] === "number") {
        const arr = [];
        for (let i = 0; i < fieldType[1]; i++) {
          arr.push(deserializeField(schema, null, fieldType[0], reader));
        }
        return arr;
      } else {
        return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
      }
    }
    if (fieldType.kind === "option") {
      const option = reader.readU8();
      if (option) {
        return deserializeField(schema, fieldName, fieldType.type, reader);
      }
      return void 0;
    }
    if (fieldType.kind === "map") {
      let map = /* @__PURE__ */ new Map();
      const length = reader.readU32();
      for (let i = 0; i < length; i++) {
        const key = deserializeField(schema, fieldName, fieldType.key, reader);
        const val = deserializeField(schema, fieldName, fieldType.value, reader);
        map.set(key, val);
      }
      return map;
    }
    return deserializeStruct(schema, fieldType, reader);
  } catch (error) {
    if (error instanceof BorshError) {
      error.addToFieldPath(fieldName);
    }
    throw error;
  }
}
function deserializeStruct(schema, classType, reader) {
  if (typeof classType.borshDeserialize === "function") {
    return classType.borshDeserialize(reader);
  }
  const structSchema = schema.get(classType);
  if (!structSchema) {
    throw new BorshError(`Class ${classType.name} is missing in schema`);
  }
  if (structSchema.kind === "struct") {
    const result = {};
    for (const [fieldName, fieldType] of schema.get(classType).fields) {
      result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
    }
    return new classType(result);
  }
  if (structSchema.kind === "enum") {
    const idx = reader.readU8();
    if (idx >= structSchema.values.length) {
      throw new BorshError(`Enum index: ${idx} is out of range`);
    }
    const [fieldName, fieldType] = structSchema.values[idx];
    const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
    return new classType({ [fieldName]: fieldValue });
  }
  throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
}
function deserialize(schema, classType, buffer2, Reader2 = BinaryReader) {
  const reader = new Reader2(buffer2);
  const result = deserializeStruct(schema, classType, reader);
  if (reader.offset < buffer2.length) {
    throw new BorshError(`Unexpected ${buffer2.length - reader.offset} bytes after deserialized data`);
  }
  return result;
}
var deserialize_1 = lib.deserialize = deserialize;
function deserializeUnchecked(schema, classType, buffer2, Reader2 = BinaryReader) {
  const reader = new Reader2(buffer2);
  return deserializeStruct(schema, classType, reader);
}
deserializeUnchecked_1 = lib.deserializeUnchecked = deserializeUnchecked;
var Layout$1 = {};
Object.defineProperty(Layout$1, "__esModule", { value: true });
Layout$1.s16 = Layout$1.s8 = Layout$1.nu64be = Layout$1.u48be = Layout$1.u40be = Layout$1.u32be = Layout$1.u24be = Layout$1.u16be = nu64 = Layout$1.nu64 = Layout$1.u48 = Layout$1.u40 = u32$1 = Layout$1.u32 = Layout$1.u24 = u16 = Layout$1.u16 = u8 = Layout$1.u8 = offset = Layout$1.offset = Layout$1.greedy = Layout$1.Constant = Layout$1.UTF8 = Layout$1.CString = Layout$1.Blob = Layout$1.Boolean = Layout$1.BitField = Layout$1.BitStructure = Layout$1.VariantLayout = Layout$1.Union = Layout$1.UnionLayoutDiscriminator = Layout$1.UnionDiscriminator = Layout$1.Structure = Layout$1.Sequence = Layout$1.DoubleBE = Layout$1.Double = Layout$1.FloatBE = Layout$1.Float = Layout$1.NearInt64BE = Layout$1.NearInt64 = Layout$1.NearUInt64BE = Layout$1.NearUInt64 = Layout$1.IntBE = Layout$1.Int = Layout$1.UIntBE = Layout$1.UInt = Layout$1.OffsetLayout = Layout$1.GreedyCount = Layout$1.ExternalLayout = Layout$1.bindConstructorLayout = Layout$1.nameWithProperty = Layout$1.Layout = Layout$1.uint8ArrayToBuffer = Layout$1.checkUint8Array = void 0;
Layout$1.constant = Layout$1.utf8 = Layout$1.cstr = blob = Layout$1.blob = Layout$1.unionLayoutDiscriminator = Layout$1.union = seq = Layout$1.seq = Layout$1.bits = struct = Layout$1.struct = Layout$1.f64be = Layout$1.f64 = Layout$1.f32be = Layout$1.f32 = Layout$1.ns64be = Layout$1.s48be = Layout$1.s40be = Layout$1.s32be = Layout$1.s24be = Layout$1.s16be = ns64 = Layout$1.ns64 = Layout$1.s48 = Layout$1.s40 = Layout$1.s32 = Layout$1.s24 = void 0;
const buffer_1 = buffer;
function checkUint8Array(b2) {
  if (!(b2 instanceof Uint8Array)) {
    throw new TypeError("b must be a Uint8Array");
  }
}
Layout$1.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(b2) {
  checkUint8Array(b2);
  return buffer_1.Buffer.from(b2.buffer, b2.byteOffset, b2.length);
}
Layout$1.uint8ArrayToBuffer = uint8ArrayToBuffer;
class Layout {
  constructor(span, property) {
    if (!Number.isInteger(span)) {
      throw new TypeError("span must be an integer");
    }
    this.span = span;
    this.property = property;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Uint8Array} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(b2, offset2) {
    if (0 > this.span) {
      throw new RangeError("indeterminate span");
    }
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(property) {
    const rv = Object.create(this.constructor.prototype);
    Object.assign(rv, this);
    rv.property = property;
    return rv;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(values) {
    return void 0;
  }
}
Layout$1.Layout = Layout;
function nameWithProperty(name, lo) {
  if (lo.property) {
    return name + "[" + lo.property + "]";
  }
  return name;
}
Layout$1.nameWithProperty = nameWithProperty;
function bindConstructorLayout(Class, layout) {
  if ("function" !== typeof Class) {
    throw new TypeError("Class must be constructor");
  }
  if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
    throw new Error("Class is already bound to a layout");
  }
  if (!(layout && layout instanceof Layout)) {
    throw new TypeError("layout must be a Layout");
  }
  if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
    throw new Error("layout is already bound to a constructor");
  }
  Class.layout_ = layout;
  layout.boundConstructor_ = Class;
  layout.makeDestinationObject = () => new Class();
  Object.defineProperty(Class.prototype, "encode", {
    value(b2, offset2) {
      return layout.encode(this, b2, offset2);
    },
    writable: true
  });
  Object.defineProperty(Class, "decode", {
    value(b2, offset2) {
      return layout.decode(b2, offset2);
    },
    writable: true
  });
}
Layout$1.bindConstructorLayout = bindConstructorLayout;
class ExternalLayout extends Layout {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
Layout$1.ExternalLayout = ExternalLayout;
class GreedyCount extends ExternalLayout {
  constructor(elementSpan = 1, property) {
    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
      throw new TypeError("elementSpan must be a (positive) integer");
    }
    super(-1, property);
    this.elementSpan = elementSpan;
  }
  /** @override */
  isCount() {
    return true;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    checkUint8Array(b2);
    const rem = b2.length - offset2;
    return Math.floor(rem / this.elementSpan);
  }
  /** @override */
  encode(src2, b2, offset2) {
    return 0;
  }
}
Layout$1.GreedyCount = GreedyCount;
class OffsetLayout extends ExternalLayout {
  constructor(layout, offset2 = 0, property) {
    if (!(layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (!Number.isInteger(offset2)) {
      throw new TypeError("offset must be integer or undefined");
    }
    super(layout.span, property || layout.property);
    this.layout = layout;
    this.offset = offset2;
  }
  /** @override */
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return this.layout.decode(b2, offset2 + this.offset);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    return this.layout.encode(src2, b2, offset2 + this.offset);
  }
}
Layout$1.OffsetLayout = OffsetLayout;
class UInt extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readUIntLE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeUIntLE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.UInt = UInt;
class UIntBE extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readUIntBE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeUIntBE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.UIntBE = UIntBE;
class Int extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readIntLE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeIntLE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.Int = Int;
class IntBE extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readIntBE(offset2, this.span);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeIntBE(src2, offset2, this.span);
    return this.span;
  }
}
Layout$1.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
function divmodInt64(src2) {
  const hi32 = Math.floor(src2 / V2E32);
  const lo32 = src2 - hi32 * V2E32;
  return { hi32, lo32 };
}
function roundedInt64(hi32, lo32) {
  return hi32 * V2E32 + lo32;
}
class NearUInt64 extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const lo32 = buffer2.readUInt32LE(offset2);
    const hi32 = buffer2.readUInt32LE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeUInt32LE(split2.lo32, offset2);
    buffer2.writeUInt32LE(split2.hi32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearUInt64 = NearUInt64;
class NearUInt64BE extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const hi32 = buffer2.readUInt32BE(offset2);
    const lo32 = buffer2.readUInt32BE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeUInt32BE(split2.hi32, offset2);
    buffer2.writeUInt32BE(split2.lo32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearUInt64BE = NearUInt64BE;
class NearInt64 extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const lo32 = buffer2.readUInt32LE(offset2);
    const hi32 = buffer2.readInt32LE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeUInt32LE(split2.lo32, offset2);
    buffer2.writeInt32LE(split2.hi32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearInt64 = NearInt64;
class NearInt64BE extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const buffer2 = uint8ArrayToBuffer(b2);
    const hi32 = buffer2.readInt32BE(offset2);
    const lo32 = buffer2.readUInt32BE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    const split2 = divmodInt64(src2);
    const buffer2 = uint8ArrayToBuffer(b2);
    buffer2.writeInt32BE(split2.hi32, offset2);
    buffer2.writeUInt32BE(split2.lo32, offset2 + 4);
    return 8;
  }
}
Layout$1.NearInt64BE = NearInt64BE;
class Float extends Layout {
  constructor(property) {
    super(4, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readFloatLE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeFloatLE(src2, offset2);
    return 4;
  }
}
Layout$1.Float = Float;
class FloatBE extends Layout {
  constructor(property) {
    super(4, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readFloatBE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeFloatBE(src2, offset2);
    return 4;
  }
}
Layout$1.FloatBE = FloatBE;
class Double extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readDoubleLE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeDoubleLE(src2, offset2);
    return 8;
  }
}
Layout$1.Double = Double;
class DoubleBE extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b2, offset2 = 0) {
    return uint8ArrayToBuffer(b2).readDoubleBE(offset2);
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    uint8ArrayToBuffer(b2).writeDoubleBE(src2, offset2);
    return 8;
  }
}
Layout$1.DoubleBE = DoubleBE;
class Sequence extends Layout {
  constructor(elementLayout, count, property) {
    if (!(elementLayout instanceof Layout)) {
      throw new TypeError("elementLayout must be a Layout");
    }
    if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    }
    let span = -1;
    if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
      span = count * elementLayout.span;
    }
    super(span, property);
    this.elementLayout = elementLayout;
    this.count = count;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    let span = 0;
    let count = this.count;
    if (count instanceof ExternalLayout) {
      count = count.decode(b2, offset2);
    }
    if (0 < this.elementLayout.span) {
      span = count * this.elementLayout.span;
    } else {
      let idx = 0;
      while (idx < count) {
        span += this.elementLayout.getSpan(b2, offset2 + span);
        ++idx;
      }
    }
    return span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const rv = [];
    let i = 0;
    let count = this.count;
    if (count instanceof ExternalLayout) {
      count = count.decode(b2, offset2);
    }
    while (i < count) {
      rv.push(this.elementLayout.decode(b2, offset2));
      offset2 += this.elementLayout.getSpan(b2, offset2);
      i += 1;
    }
    return rv;
  }
  /** Implement {@link Layout#encode|encode} for {@link Sequence}.
   *
   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
   * the unused space in the buffer is left unchanged.  If `src` is
   * longer than {@link Sequence#count|count} the unneeded elements are
   * ignored.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(src2, b2, offset2 = 0) {
    const elo = this.elementLayout;
    const span = src2.reduce((span2, v2) => {
      return span2 + elo.encode(v2, b2, offset2 + span2);
    }, 0);
    if (this.count instanceof ExternalLayout) {
      this.count.encode(src2.length, b2, offset2);
    }
    return span;
  }
}
Layout$1.Sequence = Sequence;
class Structure extends Layout {
  constructor(fields, property, decodePrefixes) {
    if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout, true))) {
      throw new TypeError("fields must be array of Layout instances");
    }
    if ("boolean" === typeof property && void 0 === decodePrefixes) {
      decodePrefixes = property;
      property = void 0;
    }
    for (const fd2 of fields) {
      if (0 > fd2.span && void 0 === fd2.property) {
        throw new Error("fields cannot contain unnamed variable-length layout");
      }
    }
    let span = -1;
    try {
      span = fields.reduce((span2, fd2) => span2 + fd2.getSpan(), 0);
    } catch (e2) {
    }
    super(span, property);
    this.fields = fields;
    this.decodePrefixes = !!decodePrefixes;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    let span = 0;
    try {
      span = this.fields.reduce((span2, fd2) => {
        const fsp = fd2.getSpan(b2, offset2);
        offset2 += fsp;
        return span2 + fsp;
      }, 0);
    } catch (e2) {
      throw new RangeError("indeterminate span");
    }
    return span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    checkUint8Array(b2);
    const dest = this.makeDestinationObject();
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property) {
        dest[fd2.property] = fd2.decode(b2, offset2);
      }
      offset2 += fd2.getSpan(b2, offset2);
      if (this.decodePrefixes && b2.length === offset2) {
        break;
      }
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(src2, b2, offset2 = 0) {
    const firstOffset = offset2;
    let lastOffset = 0;
    let lastWrote = 0;
    for (const fd2 of this.fields) {
      let span = fd2.span;
      lastWrote = 0 < span ? span : 0;
      if (void 0 !== fd2.property) {
        const fv = src2[fd2.property];
        if (void 0 !== fv) {
          lastWrote = fd2.encode(fv, b2, offset2);
          if (0 > span) {
            span = fd2.getSpan(b2, offset2);
          }
        }
      }
      lastOffset = offset2;
      offset2 += span;
    }
    return lastOffset + lastWrote - firstOffset;
  }
  /** @override */
  fromArray(values) {
    const dest = this.makeDestinationObject();
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property && 0 < values.length) {
        dest[fd2.property] = values.shift();
      }
    }
    return dest;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    for (const fd2 of this.fields) {
      if (fd2.property === property) {
        return fd2;
      }
    }
    return void 0;
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    let offset2 = 0;
    for (const fd2 of this.fields) {
      if (fd2.property === property) {
        return offset2;
      }
      if (0 > fd2.span) {
        offset2 = -1;
      } else if (0 <= offset2) {
        offset2 += fd2.span;
      }
    }
    return void 0;
  }
}
Layout$1.Structure = Structure;
class UnionDiscriminator {
  constructor(property) {
    this.property = property;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode(b2, offset2) {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode(src2, b2, offset2) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
Layout$1.UnionDiscriminator = UnionDiscriminator;
class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(layout, property) {
    if (!(layout instanceof ExternalLayout && layout.isCount())) {
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    }
    super(property || layout.property || "variant");
    this.layout = layout;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(b2, offset2) {
    return this.layout.decode(b2, offset2);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(src2, b2, offset2) {
    return this.layout.encode(src2, b2, offset2);
  }
}
Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
class Union extends Layout {
  constructor(discr, defaultLayout, property) {
    let discriminator;
    if (discr instanceof UInt || discr instanceof UIntBE) {
      discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
    } else if (discr instanceof ExternalLayout && discr.isCount()) {
      discriminator = new UnionLayoutDiscriminator(discr);
    } else if (!(discr instanceof UnionDiscriminator)) {
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    } else {
      discriminator = discr;
    }
    if (void 0 === defaultLayout) {
      defaultLayout = null;
    }
    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
      throw new TypeError("defaultLayout must be null or a Layout");
    }
    if (null !== defaultLayout) {
      if (0 > defaultLayout.span) {
        throw new Error("defaultLayout must have constant span");
      }
      if (void 0 === defaultLayout.property) {
        defaultLayout = defaultLayout.replicate("content");
      }
    }
    let span = -1;
    if (defaultLayout) {
      span = defaultLayout.span;
      if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
        span += discriminator.layout.span;
      }
    }
    super(span, property);
    this.discriminator = discriminator;
    this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
    this.defaultLayout = defaultLayout;
    this.registry = {};
    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(src2) {
      return boundGetSourceVariant(src2);
    };
    this.configGetSourceVariant = function(gsv) {
      boundGetSourceVariant = gsv.bind(this);
    };
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    const vlo = this.getVariant(b2, offset2);
    if (!vlo) {
      throw new Error("unable to determine span for unrecognized variant");
    }
    return vlo.getSpan(b2, offset2);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisfied rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(src2) {
    if (Object.prototype.hasOwnProperty.call(src2, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src2, this.defaultLayout.property)) {
        return void 0;
      }
      const vlo = this.registry[src2[this.discriminator.property]];
      if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property))) {
        return vlo;
      }
    } else {
      for (const tag in this.registry) {
        const vlo = this.registry[tag];
        if (vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property)) {
          return vlo;
        }
      }
    }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(b2, offset2 = 0) {
    let dest;
    const dlo = this.discriminator;
    const discr = dlo.decode(b2, offset2);
    const clo = this.registry[discr];
    if (void 0 === clo) {
      const defaultLayout = this.defaultLayout;
      let contentOffset = 0;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dest = this.makeDestinationObject();
      dest[dlo.property] = discr;
      dest[defaultLayout.property] = defaultLayout.decode(b2, offset2 + contentOffset);
    } else {
      dest = clo.decode(b2, offset2);
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(src2, b2, offset2 = 0) {
    const vlo = this.getSourceVariant(src2);
    if (void 0 === vlo) {
      const dlo = this.discriminator;
      const clo = this.defaultLayout;
      let contentOffset = 0;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dlo.encode(src2[dlo.property], b2, offset2);
      return contentOffset + clo.encode(src2[clo.property], b2, offset2 + contentOffset);
    }
    return vlo.encode(src2, b2, offset2);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(variant, layout, property) {
    const rv = new VariantLayout(this, variant, layout, property);
    this.registry[variant] = rv;
    return rv;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Uint8Array)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Uint8Array}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(vb2, offset2 = 0) {
    let variant;
    if (vb2 instanceof Uint8Array) {
      variant = this.discriminator.decode(vb2, offset2);
    } else {
      variant = vb2;
    }
    return this.registry[variant];
  }
}
Layout$1.Union = Union;
class VariantLayout extends Layout {
  constructor(union2, variant, layout, property) {
    if (!(union2 instanceof Union)) {
      throw new TypeError("union must be a Union");
    }
    if (!Number.isInteger(variant) || 0 > variant) {
      throw new TypeError("variant must be a (non-negative) integer");
    }
    if ("string" === typeof layout && void 0 === property) {
      property = layout;
      layout = null;
    }
    if (layout) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
        throw new Error("variant span exceeds span of containing union");
      }
      if ("string" !== typeof property) {
        throw new TypeError("variant must have a String property");
      }
    }
    let span = union2.span;
    if (0 > union2.span) {
      span = layout ? layout.span : 0;
      if (0 <= span && union2.usesPrefixDiscriminator) {
        span += union2.discriminator.layout.span;
      }
    }
    super(span, property);
    this.union = union2;
    this.variant = variant;
    this.layout = layout || null;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    if (0 <= this.span) {
      return this.span;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    let span = 0;
    if (this.layout) {
      span = this.layout.getSpan(b2, offset2 + contentOffset);
    }
    return contentOffset + span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const dest = this.makeDestinationObject();
    if (this !== this.union.getVariant(b2, offset2)) {
      throw new Error("variant mismatch");
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout) {
      dest[this.property] = this.layout.decode(b2, offset2 + contentOffset);
    } else if (this.property) {
      dest[this.property] = true;
    } else if (this.union.usesPrefixDiscriminator) {
      dest[this.union.discriminator.property] = this.variant;
    }
    return dest;
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout && !Object.prototype.hasOwnProperty.call(src2, this.property)) {
      throw new TypeError("variant lacks property " + this.property);
    }
    this.union.discriminator.encode(this.variant, b2, offset2);
    let span = contentOffset;
    if (this.layout) {
      this.layout.encode(src2[this.property], b2, offset2 + contentOffset);
      span += this.layout.getSpan(b2, offset2 + contentOffset);
      if (0 <= this.union.span && span > this.union.span) {
        throw new Error("encoded variant overruns containing union");
      }
    }
    return span;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(values) {
    if (this.layout) {
      return this.layout.fromArray(values);
    }
    return void 0;
  }
}
Layout$1.VariantLayout = VariantLayout;
function fixBitwiseResult(v2) {
  if (0 > v2) {
    v2 += 4294967296;
  }
  return v2;
}
class BitStructure extends Layout {
  constructor(word, msb, property) {
    if (!(word instanceof UInt || word instanceof UIntBE)) {
      throw new TypeError("word must be a UInt or UIntBE layout");
    }
    if ("string" === typeof msb && void 0 === property) {
      property = msb;
      msb = false;
    }
    if (4 < word.span) {
      throw new RangeError("word cannot exceed 32 bits");
    }
    super(word.span, property);
    this.word = word;
    this.msb = !!msb;
    this.fields = [];
    let value = 0;
    this._packedSetValue = function(v2) {
      value = fixBitwiseResult(v2);
      return this;
    };
    this._packedGetValue = function() {
      return value;
    };
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const dest = this.makeDestinationObject();
    const value = this.word.decode(b2, offset2);
    this._packedSetValue(value);
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property) {
        dest[fd2.property] = fd2.decode(b2);
      }
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the packed
   * value is left unmodified.  Unused bits are also left unmodified. */
  encode(src2, b2, offset2 = 0) {
    const value = this.word.decode(b2, offset2);
    this._packedSetValue(value);
    for (const fd2 of this.fields) {
      if (void 0 !== fd2.property) {
        const fv = src2[fd2.property];
        if (void 0 !== fv) {
          fd2.encode(fv);
        }
      }
    }
    return this.word.encode(this._packedGetValue(), b2, offset2);
  }
  /** Register a new bitfield with a containing bit structure.  The
   * resulting bitfield is returned.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {BitField} */
  addField(bits, property) {
    const bf2 = new BitField(this, bits, property);
    this.fields.push(bf2);
    return bf2;
  }
  /** As with {@link BitStructure#addField|addField} for single-bit
   * fields with `boolean` value representation.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {Boolean} */
  // `Boolean` conflicts with the native primitive type
  // eslint-disable-next-line @typescript-eslint/ban-types
  addBoolean(property) {
    const bf2 = new Boolean$1(this, property);
    this.fields.push(bf2);
    return bf2;
  }
  /**
   * Get access to the bit field for a given property.
   *
   * @param {String} property - the bit field of interest.
   *
   * @return {BitField} - the field associated with `property`, or
   * undefined if there is no such property.
   */
  fieldFor(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    for (const fd2 of this.fields) {
      if (fd2.property === property) {
        return fd2;
      }
    }
    return void 0;
  }
}
Layout$1.BitStructure = BitStructure;
class BitField {
  constructor(container, bits, property) {
    if (!(container instanceof BitStructure)) {
      throw new TypeError("container must be a BitStructure");
    }
    if (!Number.isInteger(bits) || 0 >= bits) {
      throw new TypeError("bits must be positive integer");
    }
    const totalBits = 8 * container.span;
    const usedBits = container.fields.reduce((sum, fd2) => sum + fd2.bits, 0);
    if (bits + usedBits > totalBits) {
      throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
    }
    this.container = container;
    this.bits = bits;
    this.valueMask = (1 << bits) - 1;
    if (32 === bits) {
      this.valueMask = 4294967295;
    }
    this.start = usedBits;
    if (this.container.msb) {
      this.start = totalBits - usedBits - bits;
    }
    this.wordMask = fixBitwiseResult(this.valueMask << this.start);
    this.property = property;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field. */
  decode(b2, offset2) {
    const word = this.container._packedGetValue();
    const wordValue = fixBitwiseResult(word & this.wordMask);
    const value = wordValue >>> this.start;
    return value;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field.
   *
   * **NOTE** This is not a specialization of {@link
   * Layout#encode|Layout.encode} and there is no return value. */
  encode(value) {
    if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
      throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    }
    const word = this.container._packedGetValue();
    const wordValue = fixBitwiseResult(value << this.start);
    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
  }
}
Layout$1.BitField = BitField;
let Boolean$1 = class Boolean2 extends BitField {
  constructor(container, property) {
    super(container, 1, property);
  }
  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
   *
   * @returns {boolean} */
  decode(b2, offset2) {
    return !!super.decode(b2, offset2);
  }
  /** @override */
  encode(value) {
    if ("boolean" === typeof value) {
      value = +value;
    }
    super.encode(value);
  }
};
Layout$1.Boolean = Boolean$1;
let Blob$2 = class Blob2 extends Layout {
  constructor(length, property) {
    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    }
    let span = -1;
    if (!(length instanceof ExternalLayout)) {
      span = length;
    }
    super(span, property);
    this.length = length;
  }
  /** @override */
  getSpan(b2, offset2) {
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b2, offset2);
    }
    return span;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b2, offset2);
    }
    return uint8ArrayToBuffer(b2).slice(offset2, offset2 + span);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(src2, b2, offset2) {
    let span = this.length;
    if (this.length instanceof ExternalLayout) {
      span = src2.length;
    }
    if (!(src2 instanceof Uint8Array && span === src2.length)) {
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
    }
    if (offset2 + span > b2.length) {
      throw new RangeError("encoding overruns Uint8Array");
    }
    const srcBuffer = uint8ArrayToBuffer(src2);
    uint8ArrayToBuffer(b2).write(srcBuffer.toString("hex"), offset2, span, "hex");
    if (this.length instanceof ExternalLayout) {
      this.length.encode(span, b2, offset2);
    }
    return span;
  }
};
Layout$1.Blob = Blob$2;
class CString extends Layout {
  constructor(property) {
    super(-1, property);
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    checkUint8Array(b2);
    let idx = offset2;
    while (idx < b2.length && 0 !== b2[idx]) {
      idx += 1;
    }
    return 1 + idx - offset2;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const span = this.getSpan(b2, offset2);
    return uint8ArrayToBuffer(b2).slice(offset2, offset2 + span - 1).toString("utf-8");
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    if ("string" !== typeof src2) {
      src2 = String(src2);
    }
    const srcb = buffer_1.Buffer.from(src2, "utf8");
    const span = srcb.length;
    if (offset2 + span > b2.length) {
      throw new RangeError("encoding overruns Buffer");
    }
    const buffer2 = uint8ArrayToBuffer(b2);
    srcb.copy(buffer2, offset2);
    buffer2[offset2 + span] = 0;
    return span + 1;
  }
}
Layout$1.CString = CString;
class UTF8 extends Layout {
  constructor(maxSpan, property) {
    if ("string" === typeof maxSpan && void 0 === property) {
      property = maxSpan;
      maxSpan = void 0;
    }
    if (void 0 === maxSpan) {
      maxSpan = -1;
    } else if (!Number.isInteger(maxSpan)) {
      throw new TypeError("maxSpan must be an integer");
    }
    super(-1, property);
    this.maxSpan = maxSpan;
  }
  /** @override */
  getSpan(b2, offset2 = 0) {
    checkUint8Array(b2);
    return b2.length - offset2;
  }
  /** @override */
  decode(b2, offset2 = 0) {
    const span = this.getSpan(b2, offset2);
    if (0 <= this.maxSpan && this.maxSpan < span) {
      throw new RangeError("text length exceeds maxSpan");
    }
    return uint8ArrayToBuffer(b2).slice(offset2, offset2 + span).toString("utf-8");
  }
  /** @override */
  encode(src2, b2, offset2 = 0) {
    if ("string" !== typeof src2) {
      src2 = String(src2);
    }
    const srcb = buffer_1.Buffer.from(src2, "utf8");
    const span = srcb.length;
    if (0 <= this.maxSpan && this.maxSpan < span) {
      throw new RangeError("text length exceeds maxSpan");
    }
    if (offset2 + span > b2.length) {
      throw new RangeError("encoding overruns Buffer");
    }
    srcb.copy(uint8ArrayToBuffer(b2), offset2);
    return span;
  }
}
Layout$1.UTF8 = UTF8;
class Constant extends Layout {
  constructor(value, property) {
    super(0, property);
    this.value = value;
  }
  /** @override */
  decode(b2, offset2) {
    return this.value;
  }
  /** @override */
  encode(src2, b2, offset2) {
    return 0;
  }
}
Layout$1.Constant = Constant;
Layout$1.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
var offset = Layout$1.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
var u8 = Layout$1.u8 = (property) => new UInt(1, property);
var u16 = Layout$1.u16 = (property) => new UInt(2, property);
Layout$1.u24 = (property) => new UInt(3, property);
var u32$1 = Layout$1.u32 = (property) => new UInt(4, property);
Layout$1.u40 = (property) => new UInt(5, property);
Layout$1.u48 = (property) => new UInt(6, property);
var nu64 = Layout$1.nu64 = (property) => new NearUInt64(property);
Layout$1.u16be = (property) => new UIntBE(2, property);
Layout$1.u24be = (property) => new UIntBE(3, property);
Layout$1.u32be = (property) => new UIntBE(4, property);
Layout$1.u40be = (property) => new UIntBE(5, property);
Layout$1.u48be = (property) => new UIntBE(6, property);
Layout$1.nu64be = (property) => new NearUInt64BE(property);
Layout$1.s8 = (property) => new Int(1, property);
Layout$1.s16 = (property) => new Int(2, property);
Layout$1.s24 = (property) => new Int(3, property);
Layout$1.s32 = (property) => new Int(4, property);
Layout$1.s40 = (property) => new Int(5, property);
Layout$1.s48 = (property) => new Int(6, property);
var ns64 = Layout$1.ns64 = (property) => new NearInt64(property);
Layout$1.s16be = (property) => new IntBE(2, property);
Layout$1.s24be = (property) => new IntBE(3, property);
Layout$1.s32be = (property) => new IntBE(4, property);
Layout$1.s40be = (property) => new IntBE(5, property);
Layout$1.s48be = (property) => new IntBE(6, property);
Layout$1.ns64be = (property) => new NearInt64BE(property);
Layout$1.f32 = (property) => new Float(property);
Layout$1.f32be = (property) => new FloatBE(property);
Layout$1.f64 = (property) => new Double(property);
Layout$1.f64be = (property) => new DoubleBE(property);
var struct = Layout$1.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
Layout$1.bits = (word, msb, property) => new BitStructure(word, msb, property);
var seq = Layout$1.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
Layout$1.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
Layout$1.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
var blob = Layout$1.blob = (length, property) => new Blob$2(length, property);
Layout$1.cstr = (property) => new CString(property);
Layout$1.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
Layout$1.constant = (value, property) => new Constant(value, property);
var browser$2 = {};
Object.defineProperty(browser$2, "__esModule", { value: true });
function toBigIntLE(buf) {
  {
    const reversed = Buffer.from(buf);
    reversed.reverse();
    const hex = reversed.toString("hex");
    if (hex.length === 0) {
      return BigInt(0);
    }
    return BigInt(`0x${hex}`);
  }
}
var toBigIntLE_1 = browser$2.toBigIntLE = toBigIntLE;
function toBigIntBE(buf) {
  {
    const hex = buf.toString("hex");
    if (hex.length === 0) {
      return BigInt(0);
    }
    return BigInt(`0x${hex}`);
  }
}
browser$2.toBigIntBE = toBigIntBE;
function toBufferLE(num, width) {
  {
    const hex = num.toString(16);
    const buffer2 = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
    buffer2.reverse();
    return buffer2;
  }
}
var toBufferLE_1 = browser$2.toBufferLE = toBufferLE;
function toBufferBE(num, width) {
  {
    const hex = num.toString(16);
    return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
  }
}
browser$2.toBufferBE = toBufferBE;
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message: message2, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message2 : `At path: ${path.join(".")} -- ${message2}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
}
function isIterable(x2) {
  return isObject$3(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject$3(x2) {
  return typeof x2 === "object" && x2 != null;
}
function isNonArrayObject(x2) {
  return isObject$3(x2) && !Array.isArray(x2);
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct2, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct2;
  const { refinement, message: message2 = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message: message2
  };
}
function* toFailures(result, context, struct2, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r2 of result) {
    const failure = toFailure(r2, context, struct2, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct2, options = {}) {
  const { path = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;
  const ctx = { path, branch, mask: mask2 };
  if (coerce2) {
    value = struct2.coercer(value, ctx);
  }
  let status = "valid";
  for (const failure of struct2.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k2, v2, s] of struct2.entries(value, ctx)) {
    const ts = run(v2, s, {
      path: k2 === void 0 ? path : [...path, k2],
      branch: k2 === void 0 ? branch : [...branch, v2],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const t2 of ts) {
      if (t2[0]) {
        status = t2[0].refinement != null ? "not_refined" : "not_valid";
        yield [t2[0], void 0];
      } else if (coerce2) {
        v2 = t2[1];
        if (k2 === void 0) {
          value = v2;
        } else if (value instanceof Map) {
          value.set(k2, v2);
        } else if (value instanceof Set) {
          value.add(v2);
        } else if (isObject$3(value)) {
          if (v2 !== void 0 || k2 in value)
            value[k2] = v2;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
let Struct$1 = class Struct {
  constructor(props) {
    const { type: type2, schema, validator: validator2, refiner, coercer = (value) => value, entries = function* () {
    } } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator2) {
      this.validator = (value, context) => {
        const result = validator2(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value, message2) {
    return assert$2(value, this, message2);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value, message2) {
    return create(value, this, message2);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value) {
    return is(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema. Masking applies recursively to
   * props of `object` structs only.
   */
  mask(value, message2) {
    return mask$1(value, this, message2);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `coerce` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful. Also, `mask` will turn on
   * masking of the unknown `object` props recursively if passed.
   */
  validate(value, options = {}) {
    return validate$1(value, this, options);
  }
};
function assert$2(value, struct2, message2) {
  const result = validate$1(value, struct2, { message: message2 });
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct2, message2) {
  const result = validate$1(value, struct2, { coerce: true, message: message2 });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask$1(value, struct2, message2) {
  const result = validate$1(value, struct2, { coerce: true, mask: true, message: message2 });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct2) {
  const result = validate$1(value, struct2);
  return !result[0];
}
function validate$1(value, struct2, options = {}) {
  const tuples = run(value, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t2 of tuples) {
        if (t2[0]) {
          yield t2[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v2 = tuple2[1];
    return [void 0, v2];
  }
}
function define(name, validator2) {
  return new Struct$1({ type: name, schema: null, validator: validator2 });
}
function any() {
  return define("any", () => true);
}
function array(Element) {
  return new Struct$1({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v2] of value.entries()) {
          yield [i, v2, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function boolean() {
  return define("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance(Class) {
  return define("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
  });
}
function literal(constant) {
  const description = print(constant);
  const t2 = typeof constant;
  return new Struct$1({
    type: "literal",
    schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define("never", () => false);
}
function nullable(struct2) {
  return new Struct$1({
    ...struct2,
    validator: (value, ctx) => value === null || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
  });
}
function number$2() {
  return define("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function optional(struct2) {
  return new Struct$1({
    ...struct2,
    validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)
  });
}
function record(Key2, Value) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject$3(value)) {
        for (const k2 in value) {
          const v2 = value[k2];
          yield [k2, k2, Key2];
          yield [k2, v2, Value];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function string() {
  return define("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i = 0; i < length; i++) {
          yield [i, value[i], Structs[i] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct$1({
    type: "type",
    schema,
    *entries(value) {
      if (isObject$3(value)) {
        for (const k2 of keys) {
          yield [k2, value[k2], schema[k2]];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value, {
          coerce: true,
          mask: ctx.mask
        });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run(value, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define("unknown", () => true);
}
function coerce(struct2, condition, coercer) {
  return new Struct$1({
    ...struct2,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
    }
  });
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid2) {
  return typeof uuid2 === "string" && REGEX.test(uuid2);
}
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1) {
  byteToHex.push((i$1 + 256).toString(16).substr(1));
}
function stringify$1(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid2 = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate(uuid2)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid2;
}
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset2) {
  var i = buf && offset2 || 0;
  var b2 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i++] = tl2 >>> 24 & 255;
  b2[i++] = tl2 >>> 16 & 255;
  b2[i++] = tl2 >>> 8 & 255;
  b2[i++] = tl2 & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i++] = tmh >>> 8 & 255;
  b2[i++] = tmh & 255;
  b2[i++] = tmh >>> 24 & 15 | 16;
  b2[i++] = tmh >>> 16 & 255;
  b2[i++] = clockseq >>> 8 | 128;
  b2[i++] = clockseq & 255;
  for (var n2 = 0; n2 < 6; ++n2) {
    b2[i + n2] = node[n2];
  }
  return buf || stringify$1(b2);
}
function parse(uuid2) {
  if (!validate(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
function stringToBytes$1(str) {
  str = unescape(encodeURIComponent(str));
  var bytes2 = [];
  for (var i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset2) {
    if (typeof value === "string") {
      value = stringToBytes$1(value);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset2 + i] = bytes2[i];
      }
      return buf;
    }
    return stringify$1(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes2[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x2 = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b2 = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x2.length; i += 16) {
    var olda = a;
    var oldb = b2;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b2, c, d, x2[i], 7, -680876936);
    d = md5ff(d, a, b2, c, x2[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b2, x2[i + 2], 17, 606105819);
    b2 = md5ff(b2, c, d, a, x2[i + 3], 22, -1044525330);
    a = md5ff(a, b2, c, d, x2[i + 4], 7, -176418897);
    d = md5ff(d, a, b2, c, x2[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b2, x2[i + 6], 17, -1473231341);
    b2 = md5ff(b2, c, d, a, x2[i + 7], 22, -45705983);
    a = md5ff(a, b2, c, d, x2[i + 8], 7, 1770035416);
    d = md5ff(d, a, b2, c, x2[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b2, x2[i + 10], 17, -42063);
    b2 = md5ff(b2, c, d, a, x2[i + 11], 22, -1990404162);
    a = md5ff(a, b2, c, d, x2[i + 12], 7, 1804603682);
    d = md5ff(d, a, b2, c, x2[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b2, x2[i + 14], 17, -1502002290);
    b2 = md5ff(b2, c, d, a, x2[i + 15], 22, 1236535329);
    a = md5gg(a, b2, c, d, x2[i + 1], 5, -165796510);
    d = md5gg(d, a, b2, c, x2[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b2, x2[i + 11], 14, 643717713);
    b2 = md5gg(b2, c, d, a, x2[i], 20, -373897302);
    a = md5gg(a, b2, c, d, x2[i + 5], 5, -701558691);
    d = md5gg(d, a, b2, c, x2[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b2, x2[i + 15], 14, -660478335);
    b2 = md5gg(b2, c, d, a, x2[i + 4], 20, -405537848);
    a = md5gg(a, b2, c, d, x2[i + 9], 5, 568446438);
    d = md5gg(d, a, b2, c, x2[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b2, x2[i + 3], 14, -187363961);
    b2 = md5gg(b2, c, d, a, x2[i + 8], 20, 1163531501);
    a = md5gg(a, b2, c, d, x2[i + 13], 5, -1444681467);
    d = md5gg(d, a, b2, c, x2[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b2, x2[i + 7], 14, 1735328473);
    b2 = md5gg(b2, c, d, a, x2[i + 12], 20, -1926607734);
    a = md5hh(a, b2, c, d, x2[i + 5], 4, -378558);
    d = md5hh(d, a, b2, c, x2[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b2, x2[i + 11], 16, 1839030562);
    b2 = md5hh(b2, c, d, a, x2[i + 14], 23, -35309556);
    a = md5hh(a, b2, c, d, x2[i + 1], 4, -1530992060);
    d = md5hh(d, a, b2, c, x2[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b2, x2[i + 7], 16, -155497632);
    b2 = md5hh(b2, c, d, a, x2[i + 10], 23, -1094730640);
    a = md5hh(a, b2, c, d, x2[i + 13], 4, 681279174);
    d = md5hh(d, a, b2, c, x2[i], 11, -358537222);
    c = md5hh(c, d, a, b2, x2[i + 3], 16, -722521979);
    b2 = md5hh(b2, c, d, a, x2[i + 6], 23, 76029189);
    a = md5hh(a, b2, c, d, x2[i + 9], 4, -640364487);
    d = md5hh(d, a, b2, c, x2[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b2, x2[i + 15], 16, 530742520);
    b2 = md5hh(b2, c, d, a, x2[i + 2], 23, -995338651);
    a = md5ii(a, b2, c, d, x2[i], 6, -198630844);
    d = md5ii(d, a, b2, c, x2[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b2, x2[i + 14], 15, -1416354905);
    b2 = md5ii(b2, c, d, a, x2[i + 5], 21, -57434055);
    a = md5ii(a, b2, c, d, x2[i + 12], 6, 1700485571);
    d = md5ii(d, a, b2, c, x2[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b2, x2[i + 10], 15, -1051523);
    b2 = md5ii(b2, c, d, a, x2[i + 1], 21, -2054922799);
    a = md5ii(a, b2, c, d, x2[i + 8], 6, 1873313359);
    d = md5ii(d, a, b2, c, x2[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b2, x2[i + 6], 15, -1560198380);
    b2 = md5ii(b2, c, d, a, x2[i + 13], 21, 1309151649);
    a = md5ii(a, b2, c, d, x2[i + 4], 6, -145523070);
    d = md5ii(d, a, b2, c, x2[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b2, x2[i + 2], 15, 718787259);
    b2 = md5ii(b2, c, d, a, x2[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b2 = safeAdd(b2, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b2, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd(x2, y2) {
  var lsw = (x2 & 65535) + (y2 & 65535);
  var msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a, b2, x2, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q2), safeAdd(x2, t2)), s), b2);
}
function md5ff(a, b2, c, d, x2, s, t2) {
  return md5cmn(b2 & c | ~b2 & d, a, b2, x2, s, t2);
}
function md5gg(a, b2, c, d, x2, s, t2) {
  return md5cmn(b2 & d | c & ~d, a, b2, x2, s, t2);
}
function md5hh(a, b2, c, d, x2, s, t2) {
  return md5cmn(b2 ^ c ^ d, a, b2, x2, s, t2);
}
function md5ii(a, b2, c, d, x2, s, t2) {
  return md5cmn(c ^ (b2 | ~d), a, b2, x2, s, t2);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return stringify$1(rnds);
}
function f$1(s, x2, y2, z2) {
  switch (s) {
    case 0:
      return x2 & y2 ^ ~x2 & z2;
    case 1:
      return x2 ^ y2 ^ z2;
    case 2:
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    case 3:
      return x2 ^ y2 ^ z2;
  }
}
function ROTL(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha1(bytes2) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes2.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l2 = bytes2.length / 4 + 2;
  var N2 = Math.ceil(l2 / 16);
  var M2 = new Array(N2);
  for (var _i2 = 0; _i2 < N2; ++_i2) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes2[_i2 * 64 + j * 4] << 24 | bytes2[_i2 * 64 + j * 4 + 1] << 16 | bytes2[_i2 * 64 + j * 4 + 2] << 8 | bytes2[_i2 * 64 + j * 4 + 3];
    }
    M2[_i2] = arr;
  }
  M2[N2 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i22 = 0; _i22 < N2; ++_i22) {
    var W2 = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W2[t2] = M2[_i22][t2];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W2[_t] = ROTL(W2[_t - 3] ^ W2[_t - 8] ^ W2[_t - 14] ^ W2[_t - 16], 1);
    }
    var a = H2[0];
    var b2 = H2[1];
    var c = H2[2];
    var d = H2[3];
    var e2 = H2[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T9 = ROTL(a, 5) + f$1(s, b2, c, d) + e2 + K2[s] + W2[_t2] >>> 0;
      e2 = d;
      d = c;
      c = ROTL(b2, 30) >>> 0;
      b2 = a;
      a = T9;
    }
    H2[0] = H2[0] + a >>> 0;
    H2[1] = H2[1] + b2 >>> 0;
    H2[2] = H2[2] + c >>> 0;
    H2[3] = H2[3] + d >>> 0;
    H2[4] = H2[4] + e2 >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5;
const nil = "00000000-0000-0000-0000-000000000000";
function version$3(uuid2) {
  if (!validate(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid2.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse,
  stringify: stringify$1,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate,
  version: version$3
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
const uuid$1 = require$$0.v4;
const generateRequest$1 = function(method, params, id2, options) {
  if (typeof method !== "string") {
    throw new TypeError(method + " must be a string");
  }
  options = options || {};
  const version2 = typeof options.version === "number" ? options.version : 2;
  if (version2 !== 1 && version2 !== 2) {
    throw new TypeError(version2 + " must be 1 or 2");
  }
  const request = {
    method
  };
  if (version2 === 2) {
    request.jsonrpc = "2.0";
  }
  if (params) {
    if (typeof params !== "object" && !Array.isArray(params)) {
      throw new TypeError(params + " must be an object, array or omitted");
    }
    request.params = params;
  }
  if (typeof id2 === "undefined") {
    const generator = typeof options.generator === "function" ? options.generator : function() {
      return uuid$1();
    };
    request.id = generator(request, options);
  } else if (version2 === 2 && id2 === null) {
    if (options.notificationIdNull) {
      request.id = null;
    }
  } else {
    request.id = id2;
  }
  return request;
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$0.v4;
const generateRequest = generateRequest_1;
const ClientBrowser = function(callServer, options) {
  if (!(this instanceof ClientBrowser)) {
    return new ClientBrowser(callServer, options);
  }
  if (!options) {
    options = {};
  }
  this.options = {
    reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
    replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
    generator: typeof options.generator !== "undefined" ? options.generator : function() {
      return uuid();
    },
    version: typeof options.version !== "undefined" ? options.version : 2,
    notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
  };
  this.callServer = callServer;
};
var browser$1 = ClientBrowser;
ClientBrowser.prototype.request = function(method, params, id2, callback) {
  const self2 = this;
  let request = null;
  const isBatch = Array.isArray(method) && typeof params === "function";
  if (this.options.version === 1 && isBatch) {
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  }
  const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
  if (isBatch || isRaw) {
    callback = params;
    request = method;
  } else {
    if (typeof id2 === "function") {
      callback = id2;
      id2 = void 0;
    }
    const hasCallback = typeof callback === "function";
    try {
      request = generateRequest(method, params, id2, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (err) {
      if (hasCallback) {
        return callback(err);
      }
      throw err;
    }
    if (!hasCallback) {
      return request;
    }
  }
  let message2;
  try {
    message2 = JSON.stringify(request, this.options.replacer);
  } catch (err) {
    return callback(err);
  }
  this.callServer(message2, function(err, response) {
    self2._parseResponse(err, response, callback);
  });
  return request;
};
ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
  if (err) {
    callback(err);
    return;
  }
  if (!responseText) {
    return callback();
  }
  let response;
  try {
    response = JSON.parse(responseText, this.options.reviver);
  } catch (err2) {
    return callback(err2);
  }
  if (callback.length === 3) {
    if (Array.isArray(response)) {
      const isError2 = function(res) {
        return typeof res.error !== "undefined";
      };
      const isNotError = function(res) {
        return !isError2(res);
      };
      return callback(null, response.filter(isError2), response.filter(isNotError));
    } else {
      return callback(null, response.error, response.result);
    }
  }
  callback(null, response);
};
const RpcClient = /* @__PURE__ */ getDefaultExportFromCjs$1(browser$1);
var WebSocketBrowserImpl = class extends EventEmitter$3 {
  /** Instantiate a WebSocket class
  * @constructor
  * @param {String} address - url to a websocket server
  * @param {(Object)} options - websocket options
  * @param {(String|Array)} protocols - a list of protocols
  * @return {WebSocketBrowserImpl} - returns a WebSocket instance
  */
  constructor(address2, options, protocols) {
    super();
    __publicField(this, "socket");
    this.socket = new window.WebSocket(address2, protocols);
    this.socket.onopen = () => this.emit("open");
    this.socket.onmessage = (event) => this.emit("message", event.data);
    this.socket.onerror = (error) => this.emit("error", error);
    this.socket.onclose = (event) => {
      this.emit("close", event.code, event.reason);
    };
  }
  /**
  * Sends data through a websocket connection
  * @method
  * @param {(String|Object)} data - data to be sent via websocket
  * @param {Object} optionsOrCallback - ws options
  * @param {Function} callback - a callback called once the data is sent
  * @return {Undefined}
  */
  send(data, optionsOrCallback, callback) {
    const cb2 = callback || optionsOrCallback;
    try {
      this.socket.send(data);
      cb2();
    } catch (error) {
      cb2(error);
    }
  }
  /**
  * Closes an underlying socket
  * @method
  * @param {Number} code - status code explaining why the connection is being closed
  * @param {String} reason - a description why the connection is closing
  * @return {Undefined}
  * @throws {Error}
  */
  close(code2, reason) {
    this.socket.close(code2, reason);
  }
  addEventListener(type2, listener, options) {
    this.socket.addEventListener(type2, listener, options);
  }
};
function WebSocket$1(address2, options) {
  return new WebSocketBrowserImpl(address2, options);
}
var DefaultDataPack = class {
  encode(value) {
    return JSON.stringify(value);
  }
  decode(value) {
    return JSON.parse(value);
  }
};
var CommonClient = class extends EventEmitter$3 {
  /**
  * Instantiate a Client class.
  * @constructor
  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
  * @param {String} address - url to a websocket server
  * @param {Object} options - ws options object with reconnect parameters
  * @param {Function} generate_request_id - custom generation request Id
  * @param {DataPack} dataPack - data pack contains encoder and decoder
  * @return {CommonClient}
  */
  constructor(webSocketFactory, address2 = "ws://localhost:8080", {
    autoconnect = true,
    reconnect: reconnect2 = true,
    reconnect_interval = 1e3,
    max_reconnects = 5,
    ...rest_options
  } = {}, generate_request_id, dataPack) {
    super();
    __publicField(this, "address");
    __publicField(this, "rpc_id");
    __publicField(this, "queue");
    __publicField(this, "options");
    __publicField(this, "autoconnect");
    __publicField(this, "ready");
    __publicField(this, "reconnect");
    __publicField(this, "reconnect_timer_id");
    __publicField(this, "reconnect_interval");
    __publicField(this, "max_reconnects");
    __publicField(this, "rest_options");
    __publicField(this, "current_reconnects");
    __publicField(this, "generate_request_id");
    __publicField(this, "socket");
    __publicField(this, "webSocketFactory");
    __publicField(this, "dataPack");
    this.webSocketFactory = webSocketFactory;
    this.queue = {};
    this.rpc_id = 0;
    this.address = address2;
    this.autoconnect = autoconnect;
    this.ready = false;
    this.reconnect = reconnect2;
    this.reconnect_timer_id = void 0;
    this.reconnect_interval = reconnect_interval;
    this.max_reconnects = max_reconnects;
    this.rest_options = rest_options;
    this.current_reconnects = 0;
    this.generate_request_id = generate_request_id || (() => ++this.rpc_id);
    if (!dataPack)
      this.dataPack = new DefaultDataPack();
    else
      this.dataPack = dataPack;
    if (this.autoconnect)
      this._connect(this.address, {
        autoconnect: this.autoconnect,
        reconnect: this.reconnect,
        reconnect_interval: this.reconnect_interval,
        max_reconnects: this.max_reconnects,
        ...this.rest_options
      });
  }
  /**
  * Connects to a defined server if not connected already.
  * @method
  * @return {Undefined}
  */
  connect() {
    if (this.socket)
      return;
    this._connect(this.address, {
      autoconnect: this.autoconnect,
      reconnect: this.reconnect,
      reconnect_interval: this.reconnect_interval,
      max_reconnects: this.max_reconnects,
      ...this.rest_options
    });
  }
  /**
  * Calls a registered RPC method on server.
  * @method
  * @param {String} method - RPC method name
  * @param {Object|Array} params - optional method parameters
  * @param {Number} timeout - RPC reply timeout value
  * @param {Object} ws_opts - options passed to ws
  * @return {Promise}
  */
  call(method, params, timeout, ws_opts) {
    if (!ws_opts && "object" === typeof timeout) {
      ws_opts = timeout;
      timeout = null;
    }
    return new Promise((resolve, reject) => {
      if (!this.ready)
        return reject(new Error("socket not ready"));
      const rpc_id = this.generate_request_id(method, params);
      const message2 = {
        jsonrpc: "2.0",
        method,
        params: params || void 0,
        id: rpc_id
      };
      this.socket.send(this.dataPack.encode(message2), ws_opts, (error) => {
        if (error)
          return reject(error);
        this.queue[rpc_id] = { promise: [resolve, reject] };
        if (timeout) {
          this.queue[rpc_id].timeout = setTimeout(() => {
            delete this.queue[rpc_id];
            reject(new Error("reply timeout"));
          }, timeout);
        }
      });
    });
  }
  /**
  * Logins with the other side of the connection.
  * @method
  * @param {Object} params - Login credentials object
  * @return {Promise}
  */
  async login(params) {
    const resp = await this.call("rpc.login", params);
    if (!resp)
      throw new Error("authentication failed");
    return resp;
  }
  /**
  * Fetches a list of client's methods registered on server.
  * @method
  * @return {Array}
  */
  async listMethods() {
    return await this.call("__listMethods");
  }
  /**
  * Sends a JSON-RPC 2.0 notification to server.
  * @method
  * @param {String} method - RPC method name
  * @param {Object} params - optional method parameters
  * @return {Promise}
  */
  notify(method, params) {
    return new Promise((resolve, reject) => {
      if (!this.ready)
        return reject(new Error("socket not ready"));
      const message2 = {
        jsonrpc: "2.0",
        method,
        params
      };
      this.socket.send(this.dataPack.encode(message2), (error) => {
        if (error)
          return reject(error);
        resolve();
      });
    });
  }
  /**
  * Subscribes for a defined event.
  * @method
  * @param {String|Array} event - event name
  * @return {Undefined}
  * @throws {Error}
  */
  async subscribe(event) {
    if (typeof event === "string")
      event = [event];
    const result = await this.call("rpc.on", event);
    if (typeof event === "string" && result[event] !== "ok")
      throw new Error(
        "Failed subscribing to an event '" + event + "' with: " + result[event]
      );
    return result;
  }
  /**
  * Unsubscribes from a defined event.
  * @method
  * @param {String|Array} event - event name
  * @return {Undefined}
  * @throws {Error}
  */
  async unsubscribe(event) {
    if (typeof event === "string")
      event = [event];
    const result = await this.call("rpc.off", event);
    if (typeof event === "string" && result[event] !== "ok")
      throw new Error("Failed unsubscribing from an event with: " + result);
    return result;
  }
  /**
  * Closes a WebSocket connection gracefully.
  * @method
  * @param {Number} code - socket close code
  * @param {String} data - optional data to be sent before closing
  * @return {Undefined}
  */
  close(code2, data) {
    this.socket.close(code2 || 1e3, data);
  }
  /**
  * Enable / disable automatic reconnection.
  * @method
  * @param {Boolean} reconnect - enable / disable reconnection
  * @return {Undefined}
  */
  setAutoReconnect(reconnect2) {
    this.reconnect = reconnect2;
  }
  /**
  * Set the interval between reconnection attempts.
  * @method
  * @param {Number} interval - reconnection interval in milliseconds
  * @return {Undefined}
  */
  setReconnectInterval(interval) {
    this.reconnect_interval = interval;
  }
  /**
  * Set the maximum number of reconnection attempts.
  * @method
  * @param {Number} max_reconnects - maximum reconnection attempts
  * @return {Undefined}
  */
  setMaxReconnects(max_reconnects) {
    this.max_reconnects = max_reconnects;
  }
  /**
  * Connection/Message handler.
  * @method
  * @private
  * @param {String} address - WebSocket API address
  * @param {Object} options - ws options object
  * @return {Undefined}
  */
  _connect(address2, options) {
    clearTimeout(this.reconnect_timer_id);
    this.socket = this.webSocketFactory(address2, options);
    this.socket.addEventListener("open", () => {
      this.ready = true;
      this.emit("open");
      this.current_reconnects = 0;
    });
    this.socket.addEventListener("message", ({ data: message2 }) => {
      if (message2 instanceof ArrayBuffer)
        message2 = buffer.Buffer.from(message2).toString();
      try {
        message2 = this.dataPack.decode(message2);
      } catch (error) {
        return;
      }
      if (message2.notification && this.listeners(message2.notification).length) {
        if (!Object.keys(message2.params).length)
          return this.emit(message2.notification);
        const args = [message2.notification];
        if (message2.params.constructor === Object)
          args.push(message2.params);
        else
          for (let i = 0; i < message2.params.length; i++)
            args.push(message2.params[i]);
        return Promise.resolve().then(() => {
          this.emit.apply(this, args);
        });
      }
      if (!this.queue[message2.id]) {
        if (message2.method) {
          return Promise.resolve().then(() => {
            this.emit(message2.method, message2 == null ? void 0 : message2.params);
          });
        }
        return;
      }
      if ("error" in message2 === "result" in message2)
        this.queue[message2.id].promise[1](
          new Error(
            'Server response malformed. Response must include either "result" or "error", but not both.'
          )
        );
      if (this.queue[message2.id].timeout)
        clearTimeout(this.queue[message2.id].timeout);
      if (message2.error)
        this.queue[message2.id].promise[1](message2.error);
      else
        this.queue[message2.id].promise[0](message2.result);
      delete this.queue[message2.id];
    });
    this.socket.addEventListener("error", (error) => this.emit("error", error));
    this.socket.addEventListener("close", ({ code: code2, reason }) => {
      if (this.ready)
        setTimeout(() => this.emit("close", code2, reason), 0);
      this.ready = false;
      this.socket = void 0;
      if (code2 === 1e3)
        return;
      this.current_reconnects++;
      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
        this.reconnect_timer_id = setTimeout(
          () => this._connect(address2, options),
          this.reconnect_interval
        );
    });
  }
};
ed25519.utils.randomPrivateKey;
function isOnCurve(publicKey2) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey2);
    return true;
  } catch {
    return false;
  }
}
const sign = (message2, secretKey) => ed25519.sign(message2, secretKey.slice(0, 32));
const verify = ed25519.verify;
const toBuffer = (arr) => {
  if (buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer.Buffer.from(arr);
  }
};
class Struct2 {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return deserialize_1(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return deserializeUnchecked_1(SOLANA_SCHEMA, this, data);
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _PublicKey;
const MAX_SEED_LENGTH = 32;
const PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value) {
  return value._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
class PublicKey extends Struct2 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = bs58$3.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new BN(decoded);
      } else {
        this._bn = new BN(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey2) {
    return this._bn.eq(publicKey2._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58$3.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b2 = this._bn.toArrayLike(buffer.Buffer);
    if (b2.length === PUBLIC_KEY_LENGTH) {
      return b2;
    }
    const zeroPad2 = buffer.Buffer.alloc(32);
    b2.copy(zeroPad2, 32 - b2.length);
    return zeroPad2;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer$12 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha256$4(buffer$12);
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer$12 = buffer.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer$12 = buffer.Buffer.concat([buffer$12, toBuffer(seed)]);
    });
    buffer$12 = buffer.Buffer.concat([buffer$12, programId.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256$4(buffer$12);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address2;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
        address2 = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address2, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
}
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new PublicKey("BPFLoader1111111111111111111111111111111111");
const PACKET_DATA_SIZE = 1280 - 40 - 8;
const VERSION_PREFIX_MASK = 127;
const SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
  constructor(signature2) {
    super(`Signature ${signature2} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature2;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
  constructor(signature2, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature2;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(signature2) {
    super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature2;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index2) {
    for (const keySegment of this.keySegments()) {
      if (index2 < keySegment.length) {
        return keySegment[index2];
      } else {
        index2 -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index2) => {
      keyIndexMap.set(key.toBase58(), index2);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
const publicKey = (property = "publicKey") => {
  return blob(32, property);
};
const signature = (property = "signature") => {
  return blob(64, property);
};
const rustString = (property = "string") => {
  const rsl = struct([u32$1("length"), u32$1("lengthPadding"), blob(offset(u32$1(), -8), "chars")], property);
  const _decode2 = rsl.decode.bind(rsl);
  const _encode2 = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b2, offset2) => {
    const data = _decode2(b2, offset2);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b2, offset2) => {
    const data = {
      chars: buffer.Buffer.from(str, "utf8")
    };
    return _encode2(data, b2, offset2);
  };
  rslShim.alloc = (str) => {
    return u32$1().span + u32$1().span + buffer.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
const authorized = (property = "authorized") => {
  return struct([publicKey("staker"), publicKey("withdrawer")], property);
};
const lockup = (property = "lockup") => {
  return struct([ns64("unixTimestamp"), ns64("epoch"), publicKey("custodian")], property);
};
const voteInit = (property = "voteInit") => {
  return struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), u8("commission")], property);
};
const voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return struct([u32$1("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};
function decodeLength(bytes2) {
  let len = 0;
  let size2 = 0;
  for (; ; ) {
    let elem = bytes2.shift();
    len |= (elem & 127) << size2 * 7;
    size2 += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes2, len) {
  let rem_len = len;
  for (; ; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem);
      break;
    } else {
      elem |= 128;
      bytes2.push(elem);
    }
  }
}
function assert$1(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "Assertion failed");
  }
}
class CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address2 = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address2);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address2, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert$1(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert$1(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert$1(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address2]) => new PublicKey(address2)), ...readonlySigners.map(([address2]) => new PublicKey(address2)), ...writableNonSigners.map(([address2]) => new PublicKey(address2)), ...readonlyNonSigners.map(([address2]) => new PublicKey(address2))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address2, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address2);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert$1(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address2);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}
const END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
function guardedShift(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.shift();
}
function guardedSplice(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.splice(...args);
}
class Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: bs58$3.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: bs58$3.encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index2) {
    return index2 < this.header.numRequiredSignatures;
  }
  isAccountWritable(index2) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index2 >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index2 - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index2 < numWritableSignedAccounts;
    }
  }
  isProgramId(index2) {
    return this.indexToProgramIds.has(index2);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index2) => !this.isProgramId(index2));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts: accounts2,
        programIdIndex
      } = instruction;
      const data = Array.from(bs58$3.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts2.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
        keyIndices: accounts2,
        dataLength: buffer.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    buffer.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = struct([u8("programIdIndex"), blob(instruction.keyIndicesCount.length, "keyIndicesCount"), seq(u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), blob(instruction.dataLength.length, "dataLength"), seq(u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = struct([blob(1, "numRequiredSignatures"), blob(1, "numReadonlySignedAccounts"), blob(1, "numReadonlyUnsignedAccounts"), blob(keyCount.length, "keyCount"), seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction2 = {
      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: bs58$3.decode(this.recentBlockhash)
    };
    let signData = buffer.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction2, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer$12) {
    let byteArray = [...buffer$12];
    const numRequiredSignatures = guardedShift(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift(byteArray);
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i = 0; i < accountCount; i++) {
      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(buffer.Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = guardedShift(byteArray);
      const accountCount2 = decodeLength(byteArray);
      const accounts2 = guardedSplice(byteArray, 0, accountCount2);
      const dataLength2 = decodeLength(byteArray);
      const dataSlice2 = guardedSplice(byteArray, 0, dataLength2);
      const data = bs58$3.encode(buffer.Buffer.from(dataSlice2));
      instructions.push({
        programIdIndex,
        accounts: accounts2,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: bs58$3.encode(buffer.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
}
class MessageV0 {
  constructor(args) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup2 of this.addressTableLookups) {
      count += lookup2.readonlyIndexes.length + lookup2.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args) {
    let accountKeysFromLookups;
    if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      }
      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    }
    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index2) {
    return index2 < this.header.numRequiredSignatures;
  }
  isAccountWritable(index2) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index2 >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index2 - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup2) => count + lookup2.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index2 >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index2 - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index2 < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index2 of tableLookup.writableIndexes) {
        if (index2 < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index2]);
        } else {
          throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index2 of tableLookup.readonlyIndexes) {
        if (index2 < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index2]);
        } else {
          throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== void 0) {
        const [addressTableLookup, {
          writable,
          readonly
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = struct([u8("prefix"), struct([u8("numRequiredSignatures"), u8("numReadonlySignedAccounts"), u8("numReadonlyUnsignedAccounts")], "header"), blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), blob(encodedInstructionsLength.length, "instructionsLength"), blob(serializedInstructions.length, "serializedInstructions"), blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
      recentBlockhash: bs58$3.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength(encodedDataLength, instruction.data.length);
      const instructionLayout = struct([u8("programIdIndex"), blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), seq(u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), blob(encodedDataLength.length, "encodedDataLength"), blob(instruction.data.length, "data")]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
    for (const lookup2 of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength(encodedWritableIndexesLength, lookup2.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength(encodedReadonlyIndexesLength, lookup2.readonlyIndexes.length);
      const addressTableLookupLayout = struct([publicKey("accountKey"), blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), seq(u8(), lookup2.writableIndexes.length, "writableIndexes"), blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), seq(u8(), lookup2.readonlyIndexes.length, "readonlyIndexes")]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup2.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup2.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup2.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = guardedShift(byteArray);
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    assert$1(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version2 = maskedPrefix;
    assert$1(version2 === 0, `Expected versioned message with version 0 but found version ${version2}`);
    const header = {
      numRequiredSignatures: guardedShift(byteArray),
      numReadonlySignedAccounts: guardedShift(byteArray),
      numReadonlyUnsignedAccounts: guardedShift(byteArray)
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength(byteArray);
    for (let i = 0; i < staticAccountKeysLength; i++) {
      staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
    }
    const recentBlockhash = bs58$3.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
    const instructionCount = decodeLength(byteArray);
    const compiledInstructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = guardedShift(byteArray);
      const accountKeyIndexesLength = decodeLength(byteArray);
      const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
      const dataLength2 = decodeLength(byteArray);
      const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength2));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength(byteArray);
    const addressTableLookups = [];
    for (let i = 0; i < addressTableLookupsCount; i++) {
      const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
      const writableIndexesLength = decodeLength(byteArray);
      const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength(byteArray);
      const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
}
const VersionedMessage = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    if (maskedPrefix === prefix) {
      return "legacy";
    }
    return maskedPrefix;
  },
  deserialize: (serializedMessage) => {
    const version2 = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version2 === "legacy") {
      return Message.from(serializedMessage);
    }
    if (version2 === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version2} deserialization is not supported`);
    }
  }
};
let TransactionStatus = /* @__PURE__ */ function(TransactionStatus2) {
  TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus2;
}({});
const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
  constructor(opts) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = buffer.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}
let Transaction$2 = class Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey2
      }) => {
        return publicKey2.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i = 0; i < instructions.length; i++) {
      if (instructions[i].programId === void 0) {
        throw new Error(`Transaction instruction index ${i} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x2, y2) {
      if (x2.isSigner !== y2.isSigner) {
        return x2.isSigner ? -1 : 1;
      }
      if (x2.isWritable !== y2.isWritable) {
        return x2.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x2.pubkey.toBase58().localeCompare(y2.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x2) => {
      return x2.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature2 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.equals(signature2.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: bs58$3.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert$1(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert$1(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message2 = this.compileMessage();
    const signedKeys = message2.accountKeys.slice(0, message2.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index2) => {
        return signedKeys[index2].equals(pair.publicKey);
      });
      if (valid)
        return message2;
    }
    this.signatures = signedKeys.map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
    return message2;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen2 = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey2) => {
      const key = publicKey2.toString();
      if (seen2.has(key)) {
        return false;
      } else {
        seen2.add(key);
        return true;
      }
    }).map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen2 = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen2.has(key)) {
        continue;
      } else {
        seen2.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message2 = this._compile();
    this._partialSign(message2, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen2 = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen2.has(key)) {
        continue;
      } else {
        seen2.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message2 = this._compile();
    this._partialSign(message2, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message2, ...signers) {
    const signData = message2.serialize();
    signers.forEach((signer) => {
      const signature2 = sign(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature2));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(pubkey, signature2) {
    this._compile();
    this._addSignature(pubkey, signature2);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature2) {
    assert$1(signature2.length === 64);
    const index2 = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index2 < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index2].signature = buffer.Buffer.from(signature2);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(message2, requireAllSignatures) {
    const errors = {};
    for (const {
      signature: signature2,
      publicKey: publicKey2
    } of this.signatures) {
      if (signature2 === null) {
        if (requireAllSignatures) {
          (errors.missing || (errors.missing = [])).push(publicKey2);
        }
      } else {
        if (!verify(signature2, message2, publicKey2.toBytes())) {
          (errors.invalid || (errors.invalid = [])).push(publicKey2);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(config2) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config2);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p2) => p2.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p2) => p2.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = buffer.Buffer.alloc(transactionLength);
    assert$1(signatures.length < 256);
    buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature2
    }, index2) => {
      if (signature2 !== null) {
        assert$1(signature2.length === 64, `signature has invalid length`);
        buffer.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index2 * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert$1(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert$1(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert$1(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert$1(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(buffer$12) {
    let byteArray = [...buffer$12];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i = 0; i < signatureCount; i++) {
      const signature2 = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(bs58$3.encode(buffer.Buffer.from(signature2)));
    }
    return Transaction.populate(Message.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(message2, signatures = []) {
    const transaction2 = new Transaction();
    transaction2.recentBlockhash = message2.recentBlockhash;
    if (message2.header.numRequiredSignatures > 0) {
      transaction2.feePayer = message2.accountKeys[0];
    }
    signatures.forEach((signature2, index2) => {
      const sigPubkeyPair = {
        signature: signature2 == bs58$3.encode(DEFAULT_SIGNATURE) ? null : bs58$3.decode(signature2),
        publicKey: message2.accountKeys[index2]
      };
      transaction2.signatures.push(sigPubkeyPair);
    });
    message2.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message2.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction2.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message2.isAccountSigner(account),
          isWritable: message2.isAccountWritable(account)
        };
      });
      transaction2.instructions.push(new TransactionInstruction({
        keys,
        programId: message2.accountKeys[instruction.programIdIndex],
        data: bs58$3.decode(instruction.data)
      }));
    });
    transaction2._message = message2;
    transaction2._json = transaction2.toJSON();
    return transaction2;
  }
};
class VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(message2, signatures) {
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== void 0) {
      assert$1(signatures.length === message2.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];
      for (let i = 0; i < message2.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message2;
  }
  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = struct([blob(encodedSignaturesLength.length, "encodedSignaturesLength"), seq(signature(), this.signatures.length, "signatures"), blob(serializedMessage.length, "serializedMessage")]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }
  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength(byteArray);
    for (let i = 0; i < signaturesLength; i++) {
      signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
    }
    const message2 = VersionedMessage.deserialize(new Uint8Array(byteArray));
    return new VersionedTransaction(message2, signatures);
  }
  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
      assert$1(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign(messageData, signer.secretKey);
    }
  }
  addSignature(publicKey2, signature2) {
    assert$1(signature2.byteLength === 64, "Signature must be 64 bytes long");
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey2));
    assert$1(signerIndex >= 0, `Can not add signature; \`${publicKey2.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature2;
  }
}
const NUM_TICKS_PER_SECOND = 160;
const DEFAULT_TICKS_PER_SLOT = 64;
const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
const MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
new PublicKey("SysvarC1ock11111111111111111111111111111111");
new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey("Sysvar1nstructions1111111111111111111111111");
new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
new PublicKey("SysvarRent111111111111111111111111111111111");
new PublicKey("SysvarRewards111111111111111111111111111111");
new PublicKey("SysvarS1otHashes111111111111111111111111111");
new PublicKey("SysvarS1otHistory11111111111111111111111111");
new PublicKey("SysvarStakeHistory1111111111111111111111111");
class SendTransactionError extends Error {
  constructor({
    action,
    signature: signature2,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message2;
    switch (action) {
      case "send":
        message2 = `Transaction ${signature2} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message2 = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message2 = `Unknown action '${((a) => a)(action)}'`;
      }
    }
    super(message2);
    this.signature = void 0;
    this.transactionMessage = void 0;
    this.transactionLogs = void 0;
    this.signature = signature2;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : void 0;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    };
  }
  /* @deprecated Use `await getLogs()` instead */
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return void 0;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
}
class SolanaJSONRPCError extends Error {
  constructor({
    code: code2,
    message: message2,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message2}` : message2);
    this.code = void 0;
    this.data = void 0;
    this.code = code2;
    this.data = data;
    this.name = "SolanaJSONRPCError";
  }
}
function sleep$1(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const FeeCalculatorLayout = nu64("lamportsPerSignature");
const NonceAccountLayout = struct([u32$1("version"), u32$1("state"), publicKey("authorizedPubkey"), publicKey("nonce"), struct([FeeCalculatorLayout], "feeCalculator")]);
NonceAccountLayout.span;
class NonceAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(buffer2) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer2), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
      nonce: new PublicKey(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
}
const encodeDecode = (layout) => {
  const decode3 = layout.decode.bind(layout);
  const encode4 = layout.encode.bind(layout);
  return {
    decode: decode3,
    encode: encode4
  };
};
const bigInt = (length) => (property) => {
  const layout = blob(length, property);
  const {
    encode: encode4,
    decode: decode3
  } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer$12, offset2) => {
    const src2 = decode3(buffer$12, offset2);
    return toBigIntLE_1(buffer.Buffer.from(src2));
  };
  bigIntLayout.encode = (bigInt2, buffer2, offset2) => {
    const src2 = toBufferLE_1(bigInt2, length);
    return encode4(src2, buffer2, offset2);
  };
  return bigIntLayout;
};
const u64$2 = bigInt(8);
Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32$1("instruction"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: struct([u32$1("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct([u32$1("instruction"), u64$2("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32$1("instruction"), publicKey("base"), rustString("seed"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32$1("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32$1("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32$1("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32$1("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct([u32$1("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct([u32$1("instruction"), publicKey("base"), rustString("seed"), ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct([u32$1("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct([u32$1("instruction"), u64$2("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct([u32$1("instruction")])
  }
});
new PublicKey("11111111111111111111111111111111");
new PublicKey("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var fastStableStringify$1;
var hasRequiredFastStableStringify;
function requireFastStableStringify() {
  if (hasRequiredFastStableStringify)
    return fastStableStringify$1;
  hasRequiredFastStableStringify = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys = [];
    for (var name in obj) {
      keys.push(name);
    }
    return keys;
  };
  function stringify2(val, isArrayProp) {
    var i, max, str, keys, key, propVal, toStr2;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify2(val.toJSON(), isArrayProp);
        } else {
          toStr2 = objToString.call(val);
          if (toStr2 === "[object Array]") {
            str = "[";
            max = val.length - 1;
            for (i = 0; i < max; i++) {
              str += stringify2(val[i], true) + ",";
            }
            if (max > -1) {
              str += stringify2(val[i], true);
            }
            return str + "]";
          } else if (toStr2 === "[object Object]") {
            keys = objKeys(val).sort();
            max = keys.length;
            str = "";
            i = 0;
            while (i < max) {
              key = keys[i];
              propVal = stringify2(val[key], false);
              if (propVal !== void 0) {
                if (str) {
                  str += ",";
                }
                str += JSON.stringify(key) + ":" + propVal;
              }
              i++;
            }
            return "{" + str + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$1 = function(val) {
    var returnVal = stringify2(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$1;
}
var fastStableStringifyExports = /* @__PURE__ */ requireFastStableStringify();
var fastStableStringify = /* @__PURE__ */ getDefaultExportFromCjs(fastStableStringifyExports);
const MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(n2) {
  let trailingZeros2 = 0;
  while (n2 > 1) {
    n2 /= 2;
    trailingZeros2++;
  }
  return trailingZeros2;
}
function nextPowerOfTwo(n2) {
  if (n2 === 0)
    return 1;
  n2--;
  n2 |= n2 >> 1;
  n2 |= n2 >> 2;
  n2 |= n2 >> 4;
  n2 |= n2 >> 8;
  n2 |= n2 >> 16;
  n2 |= n2 >> 32;
  return n2 + 1;
}
class EpochSchedule {
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }
}
var fetchImpl = globalThis.fetch;
class RpcWebSocketClient extends CommonClient {
  constructor(address2, options, generate_request_id) {
    const webSocketFactory = (url) => {
      const rpc = WebSocket$1(url, {
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1e3,
        ...options
      });
      if ("socket" in rpc) {
        this.underlyingSocket = rpc.socket;
      } else {
        this.underlyingSocket = rpc;
      }
      return rpc;
    };
    super(webSocketFactory, address2, options, generate_request_id);
    this.underlyingSocket = void 0;
  }
  call(...args) {
    var _a3;
    const readyState = (_a3 = this.underlyingSocket) == null ? void 0 : _a3.readyState;
    if (readyState === 1) {
      return super.call(...args);
    }
    return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
  notify(...args) {
    var _a3;
    const readyState = (_a3 = this.underlyingSocket) == null ? void 0 : _a3.readyState;
    if (readyState === 1) {
      return super.notify(...args);
    }
    return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
}
function decodeData(type2, data) {
  let decoded;
  try {
    decoded = type2.layout.decode(data);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (decoded.typeIndex !== type2.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type2.index}`);
  }
  return decoded;
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(args) {
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  isActive() {
    const U64_MAX = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === U64_MAX;
  }
  static deserialize(accountData) {
    const meta = decodeData(LookupTableMetaLayout, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
    assert$1(serializedAddressesLen >= 0, "lookup table is invalid");
    assert$1(serializedAddressesLen % 32 === 0, "lookup table is invalid");
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = struct([seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
      addresses: addresses.map((address2) => new PublicKey(address2))
    };
  }
}
const LookupTableMetaLayout = {
  index: 1,
  layout: struct([
    u32$1("typeIndex"),
    u64$2("deactivationSlot"),
    nu64("lastExtendedSlot"),
    u8("lastExtendedStartIndex"),
    u8(),
    // option
    seq(publicKey(), offset(u8(), -1), "authority")
  ])
};
const URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
  const matches2 = endpoint.match(URL_RE);
  if (matches2 == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
  }
  const [
    _,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish,
    portWithColon,
    rest
  ] = matches2;
  const protocol = endpoint.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to agave-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`
  );
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}
const PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
const RawAccountDataResult = tuple([string(), literal("base64")]);
const BufferFromRawAccountData = coerce(instance(buffer.Buffer), RawAccountDataResult, (value) => buffer.Buffer.from(value[0], "base64"));
const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
}
function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config2;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config2 = specifiedConfig;
  }
  return {
    commitment,
    config: config2
  };
}
function applyDefaultMemcmpEncodingToFilters(filters) {
  return filters.map((filter2) => "memcmp" in filter2 ? {
    ...filter2,
    memcmp: {
      ...filter2.memcmp,
      encoding: filter2.memcmp.encoding ?? "base58"
    }
  } : filter2);
}
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number$2()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number$2()
    }),
    value
  });
}
function versionedMessageFromResponse(version2, response) {
  if (version2 === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: bs58$3.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}
const GetInflationGovernorResult = type({
  foundation: number$2(),
  foundationTerm: number$2(),
  initial: number$2(),
  taper: number$2(),
  terminal: number$2()
});
const GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number$2(),
  effectiveSlot: number$2(),
  amount: number$2(),
  postBalance: number$2(),
  commission: optional(nullable(number$2()))
}))));
const GetRecentPrioritizationFeesResult = array(type({
  slot: number$2(),
  prioritizationFee: number$2()
}));
const GetInflationRateResult = type({
  total: number$2(),
  validator: number$2(),
  foundation: number$2(),
  epoch: number$2()
});
const GetEpochInfoResult = type({
  epoch: number$2(),
  slotIndex: number$2(),
  slotsInEpoch: number$2(),
  absoluteSlot: number$2(),
  blockHeight: optional(number$2()),
  transactionCount: optional(number$2())
});
const GetEpochScheduleResult = type({
  slotsPerEpoch: number$2(),
  leaderScheduleSlotOffset: number$2(),
  warmup: boolean(),
  firstNormalEpoch: number$2(),
  firstNormalSlot: number$2()
});
const GetLeaderScheduleResult = record(string(), array(number$2()));
const TransactionErrorResult = nullable(union([type({}), string()]));
const SignatureStatusResult = type({
  err: TransactionErrorResult
});
const SignatureReceivedResult = literal("receivedSignature");
const VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number$2())
});
const ParsedInstructionStruct = type({
  program: string(),
  programId: PublicKeyFromString,
  parsed: unknown()
});
const PartiallyDecodedInstructionStruct = type({
  programId: PublicKeyFromString,
  accounts: array(PublicKeyFromString),
  data: string()
});
const SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number$2(),
    data: array(string()),
    rentEpoch: optional(number$2())
  }))))),
  unitsConsumed: optional(number$2()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number$2(),
    instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
  }))))
}));
const BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number$2())),
  range: type({
    firstSlot: number$2(),
    lastSlot: number$2()
  })
}));
function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch2 = customFetch ? customFetch : fetchImpl;
  let agent;
  {
    if (httpAgent != null) {
      console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch2(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new RpcClient(async (request, callback) => {
    const options = {
      method: "POST",
      body: request,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch2(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep$1(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error)
        callback(err);
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest(client2) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client2.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client2) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0)
        resolve([]);
      const batch = requests.map((params) => {
        return client2.request(params.methodName, params.args);
      });
      client2.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
const SlotRpcResult = jsonRpcResult(number$2());
const GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number$2(),
  circulating: number$2(),
  nonCirculating: number$2(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
const TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number$2()),
  decimals: number$2(),
  uiAmountString: optional(string())
});
const GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number$2()),
  decimals: number$2(),
  uiAmountString: optional(string())
})));
const GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number$2(),
    data: BufferFromRawAccountData,
    rentEpoch: number$2()
  })
})));
const ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number$2()
});
const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number$2(),
    data: ParsedAccountDataResult,
    rentEpoch: number$2()
  })
})));
const GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number$2(),
  address: PublicKeyFromString
})));
const AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number$2(),
  data: BufferFromRawAccountData,
  rentEpoch: number$2()
});
const KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ParsedOrRawAccountData = coerce(union([instance(buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
const ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number$2(),
  data: ParsedOrRawAccountData,
  rentEpoch: number$2()
});
const KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
const StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number$2(),
  inactive: number$2()
});
const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number$2(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number$2()))
})));
const GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number$2(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number$2()))
})));
const AccountNotificationResult = type({
  subscription: number$2(),
  result: notificationResultAndContext(AccountInfoResult)
});
const ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ProgramAccountNotificationResult = type({
  subscription: number$2(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
const SlotInfoResult = type({
  parent: number$2(),
  slot: number$2(),
  root: number$2()
});
const SlotNotificationResult = type({
  subscription: number$2(),
  result: SlotInfoResult
});
const SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number$2(),
  timestamp: number$2()
}), type({
  type: literal("createdBank"),
  parent: number$2(),
  slot: number$2(),
  timestamp: number$2()
}), type({
  type: literal("frozen"),
  slot: number$2(),
  timestamp: number$2(),
  stats: type({
    numTransactionEntries: number$2(),
    numSuccessfulTransactions: number$2(),
    numFailedTransactions: number$2(),
    maxTransactionsPerEntry: number$2()
  })
}), type({
  type: literal("dead"),
  slot: number$2(),
  timestamp: number$2(),
  err: string()
})]);
const SlotUpdateNotificationResult = type({
  subscription: number$2(),
  result: SlotUpdateResult
});
const SignatureNotificationResult = type({
  subscription: number$2(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
const RootNotificationResult = type({
  subscription: number$2(),
  result: number$2()
});
const ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
const VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number$2(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number$2(), number$2(), number$2()])),
  commission: number$2(),
  lastVote: number$2(),
  rootSlot: nullable(number$2())
});
const GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
const ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
const SignatureStatusResponse = type({
  slot: number$2(),
  confirmations: nullable(number$2()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
const GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number$2());
const AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number$2()),
  readonlyIndexes: array(number$2())
});
const ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number$2(),
      numReadonlySignedAccounts: number$2(),
      numReadonlyUnsignedAccounts: number$2()
    }),
    instructions: array(type({
      accounts: array(number$2()),
      data: string(),
      programIdIndex: number$2()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
const AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
const ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
const ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
const RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
const InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
const UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
const ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult);
  } else {
    return create(value, ParsedInstructionResult);
  }
});
const ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
const TokenBalanceResult = type({
  accountIndex: number$2(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult
});
const LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});
const ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number$2(),
  innerInstructions: optional(nullable(array(type({
    index: number$2(),
    instructions: array(type({
      accounts: array(number$2()),
      data: string(),
      programIdIndex: number$2()
    }))
  })))),
  preBalances: array(number$2()),
  postBalances: array(number$2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number$2())
});
const ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number$2(),
  innerInstructions: optional(nullable(array(type({
    index: number$2(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number$2()),
  postBalances: array(number$2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number$2())
});
const TransactionVersionStruct = union([literal(0), literal("legacy")]);
const RewardsResult = type({
  pubkey: string(),
  lamports: number$2(),
  postBalance: nullable(number$2()),
  rewardType: nullable(string()),
  commission: optional(nullable(number$2()))
});
const GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$2()),
  blockHeight: nullable(number$2())
})));
const GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$2()),
  blockHeight: nullable(number$2())
})));
const GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$2()),
  blockHeight: nullable(number$2())
})));
const GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$2()),
  blockHeight: nullable(number$2())
})));
const GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$2()),
  blockHeight: nullable(number$2())
})));
const GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$2()),
  blockHeight: nullable(number$2())
})));
const GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number$2())
})));
const GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number$2(),
  signatures: array(string()),
  blockTime: nullable(number$2())
})));
const GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number$2(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number$2())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
const GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number$2(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number$2())),
  version: optional(TransactionVersionStruct)
})));
const GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number$2()
}));
const IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
const PerfSampleResult = type({
  slot: number$2(),
  numTransactions: number$2(),
  numSlots: number$2(),
  samplePeriodSecs: number$2()
});
const GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
const GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number$2()
  })
})));
const RequestAirdropRpcResult = jsonRpcResult(string());
const SendTransactionRpcResult = jsonRpcResult(string());
const LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
const LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number$2()
});
const COMMON_HTTP_HEADERS = {
  "solana-client": `js/${"1.0.0-maintenance"}`
};
class Connection {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(endpoint, _commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
    this.getBlockHeight = (() => {
      const requestPromises = {};
      return async (commitmentOrConfig) => {
        const {
          commitment,
          config: config2
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config2);
        const requestHash = fastStableStringify(args);
        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
          try {
            const unsafeRes = await this._rpcRequest("getBlockHeight", args);
            const res = create(unsafeRes, jsonRpcResult(number$2()));
            if ("error" in res) {
              throw new SolanaJSONRPCError(res.error, "failed to get block height information");
            }
            return res.result;
          } finally {
            delete requestPromises[requestHash];
          }
        })();
        return await requestPromises[requestHash];
      };
    })();
    let wsEndpoint;
    let httpHeaders;
    let fetch2;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch2 = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch2, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
    this._rpcWebSocket.on("error", this._wsOnError.bind(this));
    this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
    this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */
  async getBalanceAndContext(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(number$2()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the balance for the specified public key
   */
  async getBalance(publicKey2, commitmentOrConfig) {
    return await this.getBalanceAndContext(publicKey2, commitmentOrConfig).then((x2) => x2.value).catch((e2) => {
      throw new Error("failed to get balance of account " + publicKey2.toBase58() + ": " + e2);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */
  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
    const res = create(unsafeRes, jsonRpcResult(nullable(number$2())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
    }
    return res.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
    const res = create(unsafeRes, jsonRpcResult(number$2()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
    }
    return res.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
    const res = create(unsafeRes, SlotRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get first available block");
    }
    return res.result;
  }
  /**
   * Fetch information about the current supply
   */
  async getSupply(config2) {
    let configArg = {};
    if (typeof config2 === "string") {
      configArg = {
        commitment: config2
      };
    } else if (config2) {
      configArg = {
        ...config2,
        commitment: config2 && config2.commitment || this.commitment
      };
    } else {
      configArg = {
        commitment: this.commitment
      };
    }
    const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
    const res = create(unsafeRes, GetSupplyRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get supply");
    }
    return res.result;
  }
  /**
   * Fetch the current supply of a token mint
   */
  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenSupply", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token supply");
    }
    return res.result;
  }
  /**
   * Fetch the current balance of a token account
   */
  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
    }
    return res.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
   */
  async getTokenAccountsByOwner(ownerAddress, filter2, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter2) {
      _args.push({
        mint: filter2.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter2.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "base64", config2);
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  async getParsedTokenAccountsByOwner(ownerAddress, filter2, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter2) {
      _args.push({
        mint: filter2.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter2.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */
  async getLargestAccounts(config2) {
    const arg = {
      ...config2,
      commitment: config2 && config2.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
    const res = create(unsafeRes, GetLargestAccountsRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
    const res = create(unsafeRes, GetTokenLargestAccountsResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */
  async getAccountInfoAndContext(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "base64", config2);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed account info for the specified public key
   */
  async getParsedAccountInfo(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "jsonParsed", config2);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key
   */
  async getAccountInfo(publicKey2, commitmentOrConfig) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey2, commitmentOrConfig);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get info about account " + publicKey2.toBase58() + ": " + e2);
    }
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleParsedAccounts(publicKeys, rawConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(rawConfig);
    const keys = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys], commitment, "jsonParsed", config2);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const keys = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys], commitment, "base64", config2);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
    return res.value;
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   *
   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
   */
  async getStakeActivation(publicKey2, commitmentOrConfig, epoch) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, void 0, {
      ...config2,
      epoch: epoch != null ? epoch : config2 == null ? void 0 : config2.epoch
    });
    const unsafeRes = await this._rpcRequest("getStakeActivation", args);
    const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(configOrCommitment);
    const {
      encoding: encoding2,
      ...configWithoutEncoding
    } = config2 || {};
    const args = this._buildArgs([programId.toBase58()], commitment, encoding2 || "base64", {
      ...configWithoutEncoding,
      ...configWithoutEncoding.filters ? {
        filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
      } : null
    });
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const baseSchema = array(KeyedAccountInfoResult);
    const res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create(unsafeRes, jsonRpcResult(baseSchema));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  async getParsedProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(configOrCommitment);
    const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config2);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(strategy, commitment) {
    var _a3;
    let rawSignature;
    if (typeof strategy == "string") {
      rawSignature = strategy;
    } else {
      const config2 = strategy;
      if ((_a3 = config2.abortSignal) == null ? void 0 : _a3.aborted) {
        return Promise.reject(config2.abortSignal.reason);
      }
      rawSignature = config2.signature;
    }
    let decodedSignature;
    try {
      decodedSignature = bs58$3.decode(rawSignature);
    } catch (err) {
      throw new Error("signature must be base58 encoded: " + rawSignature);
    }
    assert$1(decodedSignature.length === 64, "signature has invalid length");
    if (typeof strategy === "string") {
      return await this.confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: commitment || this.commitment,
        signature: rawSignature
      });
    } else if ("lastValidBlockHeight" in strategy) {
      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    } else {
      return await this.confirmTransactionUsingDurableNonceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    }
  }
  getCancellationPromise(signal) {
    return new Promise((_, reject) => {
      if (signal == null) {
        return;
      }
      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        });
      }
    });
  }
  getTransactionConfirmationPromise({
    commitment,
    signature: signature2
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
          signatureSubscriptionId = void 0;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: TransactionStatus.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
              if (nextState === "subscribed") {
                resolveSubscriptionSetup();
              }
            });
          }
        });
        (async () => {
          await subscriptionSetupPromise;
          if (done)
            return;
          const response = await this.getSignatureStatus(signature2);
          if (done)
            return;
          if (response == null) {
            return;
          }
          const {
            context,
            value
          } = response;
          if (value == null) {
            return;
          }
          if (value == null ? void 0 : value.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case "confirmed":
              case "single":
              case "singleGossip": {
                if (value.confirmationStatus === "processed") {
                  return;
                }
                break;
              }
              case "finalized":
              case "max":
              case "root": {
                if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                  return;
                }
                break;
              }
              case "processed":
              case "recent":
            }
            done = true;
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        })();
      } catch (err) {
        reject(err);
      }
    });
    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = void 0;
      }
      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = void 0;
      }
    };
    return {
      abortConfirmation,
      confirmationPromise
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment,
    strategy: {
      abortSignal,
      lastValidBlockHeight,
      signature: signature2
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e2) {
          return -1;
        }
      };
      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done)
          return;
        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep$1(1e3);
          if (done)
            return;
          currentBlockHeight = await checkBlockHeight();
          if (done)
            return;
        }
        resolve({
          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
        });
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature2
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredBlockheightExceededError(signature2);
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment,
    strategy: {
      abortSignal,
      minContextSlot,
      nonceAccountPubkey,
      nonceValue,
      signature: signature2
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      let currentNonceValue = nonceValue;
      let lastCheckedSlot = null;
      const getCurrentNonceValue = async () => {
        try {
          const {
            context,
            value: nonceAccount
          } = await this.getNonceAndContext(nonceAccountPubkey, {
            commitment,
            minContextSlot
          });
          lastCheckedSlot = context.slot;
          return nonceAccount == null ? void 0 : nonceAccount.nonce;
        } catch (e2) {
          return currentNonceValue;
        }
      };
      (async () => {
        currentNonceValue = await getCurrentNonceValue();
        if (done)
          return;
        while (true) {
          if (nonceValue !== currentNonceValue) {
            resolve({
              __type: TransactionStatus.NONCE_INVALID,
              slotInWhichNonceDidAdvance: lastCheckedSlot
            });
            return;
          }
          await sleep$1(2e3);
          if (done)
            return;
          currentNonceValue = await getCurrentNonceValue();
          if (done)
            return;
        }
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature2
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        let signatureStatus;
        while (true) {
          const status = await this.getSignatureStatus(signature2);
          if (status == null) {
            break;
          }
          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
            await sleep$1(400);
            continue;
          }
          signatureStatus = status;
          break;
        }
        if (signatureStatus == null ? void 0 : signatureStatus.value) {
          const commitmentForStatus = commitment || "finalized";
          const {
            confirmationStatus
          } = signatureStatus.value;
          switch (commitmentForStatus) {
            case "processed":
            case "recent":
              if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
              break;
            case "finalized":
            case "max":
            case "root":
              if (confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
              break;
            default:
              /* @__PURE__ */ ((_) => {
              })(commitmentForStatus);
          }
          result = {
            context: signatureStatus.context,
            value: {
              err: signatureStatus.value.err
            }
          };
        } else {
          throw new TransactionExpiredNonceInvalidError(signature2);
        }
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment,
    signature: signature2
  }) {
    let timeoutId;
    const expiryPromise = new Promise((resolve) => {
      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
      switch (commitment) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
          break;
        }
      }
      timeoutId = setTimeout(() => resolve({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs
      }), timeoutMs);
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature2
    });
    let result;
    try {
      const outcome = await Promise.race([confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
      }
    } finally {
      clearTimeout(timeoutId);
      abortConfirmation();
    }
    return result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest("getClusterNodes", []);
    const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
    }
    return res.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
    const res = create(unsafeRes, GetVoteAccounts);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
    }
    return res.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */
  async getSlot(commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getSlot", args);
    const res = create(unsafeRes, jsonRpcResult(number$2()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot");
    }
    return res.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */
  async getSlotLeader(commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getSlotLeader", args);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
    }
    return res.result;
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  async getSlotLeaders(startSlot, limit) {
    const args = [startSlot, limit];
    const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
    const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
    }
    return res.result;
  }
  /**
   * Fetch the current status of a signature
   */
  async getSignatureStatus(signature2, config2) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature2], config2);
    assert$1(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */
  async getSignatureStatuses(signatures, config2) {
    const params = [signatures];
    if (config2) {
      params.push(config2);
    }
    const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
    const res = create(unsafeRes, GetSignatureStatusesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signature status");
    }
    return res.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */
  async getTransactionCount(commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getTransactionCount", args);
    const res = create(unsafeRes, jsonRpcResult(number$2()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
    }
    return res.result;
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
   */
  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */
  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
    const res = create(unsafeRes, GetInflationGovernorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation");
    }
    return res.result;
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  async getInflationReward(addresses, epoch, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
      ...config2,
      epoch: epoch != null ? epoch : config2 == null ? void 0 : config2.epoch
    });
    const unsafeRes = await this._rpcRequest("getInflationReward", args);
    const res = create(unsafeRes, GetInflationRewardResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
    }
    return res.result;
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */
  async getInflationRate() {
    const unsafeRes = await this._rpcRequest("getInflationRate", []);
    const res = create(unsafeRes, GetInflationRateRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Info parameters
   */
  async getEpochInfo(commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getEpochInfo", args);
    const res = create(unsafeRes, GetEpochInfoRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Schedule parameters
   */
  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
    const res = create(unsafeRes, GetEpochScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
    }
    const epochSchedule = res.result;
    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
    const res = create(unsafeRes, GetLeaderScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
    }
    return res.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  async getMinimumBalanceForRentExemption(dataLength2, commitment) {
    const args = this._buildArgs([dataLength2], commitment);
    const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
    const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
    if ("error" in res) {
      console.warn("Unable to fetch minimum balance for rent exemption");
      return 0;
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhashAndContext(commitment) {
    const {
      context,
      value: {
        blockhash
      }
    } = await this.getLatestBlockhashAndContext(commitment);
    const feeCalculator = {
      get lamportsPerSignature() {
        throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
      },
      toJSON() {
        return {};
      }
    };
    return {
      context,
      value: {
        blockhash,
        feeCalculator
      }
    };
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  async getRecentPerformanceSamples(limit) {
    const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
    const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
    }
    return res.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
   */
  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);
    const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
    const res = create(unsafeRes, GetFeeCalculatorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
    }
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  async getFeeForMessage(message2, commitment) {
    const wireMessage = toBuffer(message2.serialize()).toString("base64");
    const args = this._buildArgs([wireMessage], commitment);
    const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number$2())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
    }
    if (res.result === null) {
      throw new Error("invalid blockhash");
    }
    return res.result;
  }
  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  async getRecentPrioritizationFees(config2) {
    var _a3;
    const accounts2 = (_a3 = config2 == null ? void 0 : config2.lockedWritableAccounts) == null ? void 0 : _a3.map((key) => key.toBase58());
    const args = (accounts2 == null ? void 0 : accounts2.length) ? [accounts2] : [];
    const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
    const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get recent blockhash: " + e2);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhash(commitmentOrConfig) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
      return res.value;
    } catch (e2) {
      throw new Error("failed to get recent blockhash: " + e2);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhashAndContext(commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
    const res = create(unsafeRes, GetLatestBlockhashRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
    }
    return res.result;
  }
  /**
   * Returns whether a blockhash is still valid or not
   */
  async isBlockhashValid(blockhash, rawConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgs([blockhash], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
    const res = create(unsafeRes, IsBlockhashValidRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
    }
    return res.result;
  }
  /**
   * Fetch the node version
   */
  async getVersion() {
    const unsafeRes = await this._rpcRequest("getVersion", []);
    const res = create(unsafeRes, jsonRpcResult(VersionResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get version");
    }
    return res.result;
  }
  /**
   * Fetch the genesis hash
   */
  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest("getGenesisHash", []);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
    }
    return res.result;
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(slot, rawConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config2 == null ? void 0 : config2.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          const {
            result
          } = res;
          return result ? {
            ...result,
            transactions: result.transactions.map(({
              transaction: transaction2,
              meta,
              version: version2
            }) => ({
              meta,
              transaction: {
                ...transaction2,
                message: versionedMessageFromResponse(version2, transaction2.message)
              },
              version: version2
            }))
          } : null;
        }
      }
    } catch (e2) {
      throw new SolanaJSONRPCError(e2, "failed to get confirmed block");
    }
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(slot, rawConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config2);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config2 == null ? void 0 : config2.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetParsedBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
      }
    } catch (e2) {
      throw new SolanaJSONRPCError(e2, "failed to get block");
    }
  }
  /*
   * Returns recent block production information from the current or previous epoch
   */
  async getBlockProduction(configOrCommitment) {
    let extra;
    let commitment;
    if (typeof configOrCommitment === "string") {
      commitment = configOrCommitment;
    } else if (configOrCommitment) {
      const {
        commitment: c,
        ...rest
      } = configOrCommitment;
      commitment = c;
      extra = rest;
    }
    const args = this._buildArgs([], commitment, "base64", extra);
    const unsafeRes = await this._rpcRequest("getBlockProduction", args);
    const res = create(unsafeRes, BlockProductionResponseStruct);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block production information");
    }
    return res.result;
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(signature2, rawConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config2);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result)
      return result;
    return {
      ...result,
      transaction: {
        ...result.transaction,
        message: versionedMessageFromResponse(result.version, result.transaction.message)
      }
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  async getParsedTransaction(signature2, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config2);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  async getParsedTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config2);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config2);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      const result = res2.result;
      if (!result)
        return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    });
    return res;
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
   */
  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetConfirmedBlockRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    const block = {
      ...result,
      transactions: result.transactions.map(({
        transaction: transaction2,
        meta
      }) => {
        const message2 = new Message(transaction2.message);
        return {
          meta,
          transaction: {
            ...transaction2,
            message: message2
          }
        };
      })
    };
    return {
      ...block,
      transactions: block.transactions.map(({
        transaction: transaction2,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction$2.populate(transaction2.message, transaction2.signatures)
        };
      })
    };
  }
  /**
   * Fetch confirmed blocks between two slots
   */
  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
    const unsafeRes = await this._rpcRequest("getBlocks", args);
    const res = create(unsafeRes, jsonRpcResult(array(number$2())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get blocks");
    }
    return res.result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
   */
  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
   */
  async getConfirmedTransaction(signature2, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result)
      return result;
    const message2 = new Message(result.transaction.message);
    const signatures = result.transaction.signatures;
    return {
      ...result,
      transaction: Transaction$2.populate(message2, signatures)
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
   */
  async getParsedConfirmedTransaction(signature2, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
   */
  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  async getConfirmedSignaturesForAddress(address2, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();
    while (!("until" in options)) {
      startSlot--;
      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    let highestConfirmedRoot = await this.getSlot("finalized");
    while (!("before" in options)) {
      endSlot++;
      if (endSlot > highestConfirmedRoot) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);
        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address2, options);
    return confirmedSignatureInfo.map((info) => info.signature);
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
   */
  async getConfirmedSignaturesForAddress2(address2, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address2.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
    const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
    }
    return res.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getSignaturesForAddress(address2, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address2.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
    const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
    }
    return res.result;
  }
  async getAddressLookupTable(accountKey, config2) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(accountKey, config2);
    let value = null;
    if (accountInfo !== null) {
      value = new AddressLookupTableAccount({
        key: accountKey,
        state: AddressLookupTableAccount.deserialize(accountInfo.data)
      });
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  async getNonceAndContext(nonceAccount, commitmentOrConfig) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
    let value = null;
    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  async getNonce(nonceAccount, commitmentOrConfig) {
    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x2) => x2.value).catch((e2) => {
      throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e2);
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  async requestAirdrop(to, lamports) {
    const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
    const res = create(unsafeRes, RequestAirdropRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
    }
    return res.result;
  }
  /**
   * @internal
   */
  async _blockhashWithExpiryBlockHeight(disableCache) {
    if (!disableCache) {
      while (this._pollingBlockhash) {
        await sleep$1(100);
      }
      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !expired) {
        return this._blockhashInfo.latestBlockhash;
      }
    }
    return await this._pollNewBlockhash();
  }
  /**
   * @internal
   */
  async _pollNewBlockhash() {
    this._pollingBlockhash = true;
    try {
      const startTime = Date.now();
      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
      for (let i = 0; i < 50; i++) {
        const latestBlockhash = await this.getLatestBlockhash("finalized");
        if (cachedBlockhash !== latestBlockhash.blockhash) {
          this._blockhashInfo = {
            latestBlockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return latestBlockhash;
        }
        await sleep$1(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  /**
   * get the stake minimum delegation
   */
  async getStakeMinimumDelegation(config2) {
    const {
      commitment,
      config: configArg
    } = extractCommitmentFromConfig(config2);
    const args = this._buildArgs([], commitment, "base64", configArg);
    const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(number$2()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
    }
    return res.result;
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    if ("message" in transactionOrMessage) {
      const versionedTx = transactionOrMessage;
      const wireTransaction2 = versionedTx.serialize();
      const encodedTransaction2 = buffer.Buffer.from(wireTransaction2).toString("base64");
      if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
        throw new Error("Invalid arguments");
      }
      const config3 = configOrSigners || {};
      config3.encoding = "base64";
      if (!("commitment" in config3)) {
        config3.commitment = this.commitment;
      }
      if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
        config3.innerInstructions = configOrSigners.innerInstructions;
      }
      const args2 = [encodedTransaction2, config3];
      const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
      const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct);
      if ("error" in res2) {
        throw new Error("failed to simulate transaction: " + res2.error.message);
      }
      return res2.result;
    }
    let transaction2;
    if (transactionOrMessage instanceof Transaction$2) {
      let originalTx = transactionOrMessage;
      transaction2 = new Transaction$2();
      transaction2.feePayer = originalTx.feePayer;
      transaction2.instructions = transactionOrMessage.instructions;
      transaction2.nonceInfo = originalTx.nonceInfo;
      transaction2.signatures = originalTx.signatures;
    } else {
      transaction2 = Transaction$2.populate(transactionOrMessage);
      transaction2._message = transaction2._json = void 0;
    }
    if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
      throw new Error("Invalid arguments");
    }
    const signers = configOrSigners;
    if (transaction2.nonceInfo && signers) {
      transaction2.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction2.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction2.recentBlockhash = latestBlockhash.blockhash;
        if (!signers)
          break;
        transaction2.sign(...signers);
        if (!transaction2.signature) {
          throw new Error("!signature");
        }
        const signature2 = transaction2.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
          this._blockhashInfo.simulatedSignatures.push(signature2);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const message2 = transaction2._compile();
    const signData = message2.serialize();
    const wireTransaction = transaction2._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config2 = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message2.nonProgramIds()).map((key) => key.toBase58());
      config2["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config2.sigVerify = true;
    }
    if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
      config2.innerInstructions = configOrSigners.innerInstructions;
    }
    const args = [encodedTransaction, config2];
    const unsafeRes = await this._rpcRequest("simulateTransaction", args);
    const res = create(unsafeRes, SimulatedTransactionResponseStruct);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError({
        action: "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */
  /**
   * Send a signed transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(transaction2, signersOrOptions, options) {
    if ("version" in transaction2) {
      if (signersOrOptions && Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const wireTransaction2 = transaction2.serialize();
      return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
    }
    if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
      throw new Error("Invalid arguments");
    }
    const signers = signersOrOptions;
    if (transaction2.nonceInfo) {
      transaction2.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction2.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction2.recentBlockhash = latestBlockhash.blockhash;
        transaction2.sign(...signers);
        if (!transaction2.signature) {
          throw new Error("!signature");
        }
        const signature2 = transaction2.signature.toString("base64");
        if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
          this._blockhashInfo.transactionSignatures.push(signature2);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const wireTransaction = transaction2.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString("base64");
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  async sendEncodedTransaction(encodedTransaction, options) {
    const config2 = {
      encoding: "base64"
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
    if (options && options.maxRetries != null) {
      config2.maxRetries = options.maxRetries;
    }
    if (options && options.minContextSlot != null) {
      config2.minContextSlot = options.minContextSlot;
    }
    if (skipPreflight) {
      config2.skipPreflight = skipPreflight;
    }
    if (preflightCommitment) {
      config2.preflightCommitment = preflightCommitment;
    }
    const args = [encodedTransaction, config2];
    const unsafeRes = await this._rpcRequest("sendTransaction", args);
    const res = create(unsafeRes, SendTransactionRpcResult);
    if ("error" in res) {
      let logs = void 0;
      if ("data" in res.error) {
        logs = res.error.data.logs;
      }
      throw new SendTransactionError({
        action: skipPreflight ? "send" : "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      (async () => {
        try {
          await this._rpcWebSocket.notify("ping");
        } catch {
        }
      })();
    }, 5e3);
    this._updateSubscriptions();
  }
  /**
   * @internal
   */
  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error("ws error:", err.message);
  }
  /**
   * @internal
   */
  _wsOnClose(code2) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code2 === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash2, subscription]) => {
      this._setSubscription(hash2, {
        ...subscription,
        state: "pending"
      });
    });
  }
  /**
   * @internal
   */
  _setSubscription(hash2, nextSubscription) {
    var _a3;
    const prevState = (_a3 = this._subscriptionsByHash[hash2]) == null ? void 0 : _a3.state;
    this._subscriptionsByHash[hash2] = nextSubscription;
    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2];
      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach((cb2) => {
          try {
            cb2(nextSubscription.state);
          } catch {
          }
        });
      }
    }
  }
  /**
   * @internal
   */
  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    var _a3;
    const hash2 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
    if (hash2 == null) {
      return () => {
      };
    }
    const stateChangeCallbacks = (_a3 = this._subscriptionStateChangeCallbacksByHash)[hash2] || (_a3[hash2] = /* @__PURE__ */ new Set());
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);
      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash2];
      }
    };
  }
  /**
   * @internal
   */
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (err) {
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }
    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const activeWebSocketGeneration = this._rpcWebSocketGeneration;
    const isCurrentConnectionStillActive = () => {
      return activeWebSocketGeneration === this._rpcWebSocketGeneration;
    };
    await Promise.all(
      // Don't be tempted to change this to `Object.entries`. We call
      // `_updateSubscriptions` recursively when processing the state,
      // so it's important that we look up the *current* version of
      // each subscription, every time we process a hash.
      Object.keys(this._subscriptionsByHash).map(async (hash2) => {
        const subscription = this._subscriptionsByHash[hash2];
        if (subscription === void 0) {
          return;
        }
        switch (subscription.state) {
          case "pending":
          case "unsubscribed":
            if (subscription.callbacks.size === 0) {
              delete this._subscriptionsByHash[hash2];
              if (subscription.state === "unsubscribed") {
                delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
              }
              await this._updateSubscriptions();
              return;
            }
            await (async () => {
              const {
                args,
                method
              } = subscription;
              try {
                this._setSubscription(hash2, {
                  ...subscription,
                  state: "subscribing"
                });
                const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                this._setSubscription(hash2, {
                  ...subscription,
                  serverSubscriptionId,
                  state: "subscribed"
                });
                this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                await this._updateSubscriptions();
              } catch (e2) {
                console.error(`Received ${e2 instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                  args,
                  error: e2
                });
                if (!isCurrentConnectionStillActive()) {
                  return;
                }
                this._setSubscription(hash2, {
                  ...subscription,
                  state: "pending"
                });
                await this._updateSubscriptions();
              }
            })();
            break;
          case "subscribed":
            if (subscription.callbacks.size === 0) {
              await (async () => {
                const {
                  serverSubscriptionId,
                  unsubscribeMethod
                } = subscription;
                if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                  this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                } else {
                  this._setSubscription(hash2, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  this._setSubscription(hash2, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                  } catch (e2) {
                    if (e2 instanceof Error) {
                      console.error(`${unsubscribeMethod} error:`, e2.message);
                    }
                    if (!isCurrentConnectionStillActive()) {
                      return;
                    }
                    this._setSubscription(hash2, {
                      ...subscription,
                      state: "subscribed"
                    });
                    await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(hash2, {
                  ...subscription,
                  state: "unsubscribed"
                });
                await this._updateSubscriptions();
              })();
            }
            break;
        }
      })
    );
  }
  /**
   * @internal
   */
  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    if (callbacks === void 0) {
      return;
    }
    callbacks.forEach((cb2) => {
      try {
        cb2(
          ...callbackArgs
        );
      } catch (e2) {
        console.error(e2);
      }
    });
  }
  /**
   * @internal
   */
  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, AccountNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _makeSubscription(subscriptionConfig, args) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash2 = fastStableStringify([subscriptionConfig.method, args]);
    const existingSubscription = this._subscriptionsByHash[hash2];
    if (existingSubscription === void 0) {
      this._subscriptionsByHash[hash2] = {
        ...subscriptionConfig,
        args,
        callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
        state: "pending"
      };
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }
    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash2;
    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash2];
      assert$1(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      await this._updateSubscriptions();
    };
    this._updateSubscriptions();
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onAccountChange(publicKey2, callback, commitmentOrConfig) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs(
      [publicKey2.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config2
    );
    return this._makeSubscription({
      callback,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
  }
  /**
   * @internal
   */
  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, ProgramAccountNotificationResult);
    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
    const {
      commitment,
      config: config2
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs(
      [programId.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config2 ? config2 : maybeFilters ? {
        filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
      } : void 0
      /* extra */
    );
    return this._makeSubscription({
      callback,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeProgramAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(filter2, callback, commitment) {
    const args = this._buildArgs(
      [typeof filter2 === "object" ? {
        mentions: [filter2.toString()]
      } : filter2],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    return this._makeSubscription({
      callback,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, args);
  }
  /**
   * Deregister a logs callback.
   *
   * @param clientSubscriptionId client subscription id to deregister.
   */
  async removeOnLogsListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
  }
  /**
   * @internal
   */
  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, LogsNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
  }
  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotUpdateNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotUpdateListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
  }
  /**
   * @internal
   */
  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
    if (dispose) {
      await dispose();
    } else {
      console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
    }
  }
  _buildArgs(args, override, encoding2, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding2 || extra) {
      let options = {};
      if (encoding2) {
        options.encoding = encoding2;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args.push(options);
    }
    return args;
  }
  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(args, override, encoding2, extra) {
    const commitment = override || this._commitment;
    if (commitment && !["confirmed", "finalized"].includes(commitment)) {
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    }
    return this._buildArgs(args, override, encoding2, extra);
  }
  /**
   * @internal
   */
  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SignatureNotificationResult);
    if (result.value !== "receivedSignature") {
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }
    this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
      type: "received"
    }, result.context] : [{
      type: "status",
      result: result.value
    }, result.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(signature2, callback, commitment) {
    const args = this._buildArgs(
      [signature2],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === "status") {
          callback(notification.result, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(signature2, callback, options) {
    const {
      commitment,
      ...extra
    } = {
      ...options,
      commitment: options && options.commitment || this._commitment || "finalized"
      // Apply connection/server default.
    };
    const args = this._buildArgs([signature2], commitment, void 0, extra);
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context);
        try {
          this.removeSignatureListener(clientSubscriptionId);
        } catch (_err) {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSignatureListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
  }
  /**
   * @internal
   */
  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, RootNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeRootChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
  }
}
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct([u32$1("instruction"), u64$2("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct([u32$1("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct([u32$1("instruction"), u64$2(), seq(publicKey(), offset(u32$1(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct([u32$1("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct([u32$1("instruction")])
  }
});
new PublicKey("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct([u8("instruction"), u32$1("units"), u32$1("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct([u8("instruction"), u32$1("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct([u8("instruction"), u32$1("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct([u8("instruction"), u64$2("microLamports")])
  }
});
new PublicKey("ComputeBudget111111111111111111111111111111");
struct([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
new PublicKey("Ed25519SigVerify111111111111111111111111111");
secp256k1$2.utils.isValidPrivateKey;
secp256k1$2.getPublicKey;
struct([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob(20, "ethAddress"), blob(64, "signature"), u8("recoveryId")]);
new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
}
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32$1("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32$1("instruction"), publicKey("newAuthorized"), u32$1("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct([u32$1("instruction")])
  },
  Split: {
    index: 3,
    layout: struct([u32$1("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32$1("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32$1("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct([u32$1("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct([u32$1("instruction"), publicKey("newAuthorized"), u32$1("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
new PublicKey("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct([u32$1("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32$1("instruction"), publicKey("newAuthorized"), u32$1("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct([u32$1("instruction"), ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: struct([u32$1("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct([u32$1("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
new PublicKey("Vote111111111111111111111111111111111111111");
new PublicKey("Va1idator1nfo111111111111111111111111111111");
type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
new PublicKey("Vote111111111111111111111111111111111111111");
struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  u8("commission"),
  nu64(),
  // votes.length
  seq(struct([nu64("slot"), u32$1("confirmationCount")]), offset(u32$1(), -8), "votes"),
  u8("rootSlotValid"),
  nu64("rootSlot"),
  nu64(),
  // authorizedVoters.length
  seq(struct([nu64("epoch"), publicKey("authorizedVoter")]), offset(u32$1(), -8), "authorizedVoters"),
  struct([seq(struct([publicKey("authorizedPubkey"), nu64("epochOfLastAuthorizedSwitch"), nu64("targetEpoch")]), 32, "buf"), nu64("idx"), u8("isEmpty")], "priorVoters"),
  nu64(),
  // epochCredits.length
  seq(struct([nu64("epoch"), nu64("credits"), nu64("prevCredits")]), offset(u32$1(), -8), "epochCredits"),
  struct([nu64("slot"), nu64("timestamp")], "lastTimestamp")
]);
const ConnectionContext = reactExports.createContext({});
function useConnection() {
  return reactExports.useContext(ConnectionContext);
}
const ConnectionProvider = ({ children, endpoint, config: config2 = { commitment: "confirmed" } }) => {
  const connection = reactExports.useMemo(() => new Connection(endpoint, config2), [endpoint, config2]);
  return React.createElement(ConnectionContext.Provider, { value: { connection } }, children);
};
var eventemitter3$1 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE2(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE2(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners2.length; i < length; i++) {
        if (listeners2[i].fn !== fn || once && !listeners2[i].once || context && listeners2[i].context !== context) {
          events.push(listeners2[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3$1);
var eventemitter3Exports$1 = eventemitter3$1.exports;
const EventEmitter$2 = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports$1);
let WalletError$1 = class WalletError extends Error {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  constructor(message2, error) {
    super(message2);
    this.error = error;
  }
};
class WalletNotReadyError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
}
class WalletConfigError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletConfigError";
  }
}
let WalletConnectionError$1 = class WalletConnectionError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
let WalletDisconnectedError$1 = class WalletDisconnectedError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectedError";
  }
};
class WalletDisconnectionError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
}
class WalletAccountError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
}
class WalletPublicKeyError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletPublicKeyError";
  }
}
class WalletNotConnectedError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
}
class WalletSendTransactionError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletSendTransactionError";
  }
}
let WalletSignTransactionError$1 = class WalletSignTransactionError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
let WalletSignMessageError$1 = class WalletSignMessageError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
class WalletSignInError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletSignInError";
  }
}
var WalletReadyState$1;
(function(WalletReadyState2) {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
})(WalletReadyState$1 || (WalletReadyState$1 = {}));
class BaseWalletAdapter extends EventEmitter$2 {
  get connected() {
    return !!this.publicKey;
  }
  async autoConnect() {
    await this.connect();
  }
  async prepareTransaction(transaction2, connection, options = {}) {
    const publicKey2 = this.publicKey;
    if (!publicKey2)
      throw new WalletNotConnectedError();
    transaction2.feePayer = transaction2.feePayer || publicKey2;
    transaction2.recentBlockhash = transaction2.recentBlockhash || (await connection.getLatestBlockhash({
      commitment: options.preflightCommitment,
      minContextSlot: options.minContextSlot
    })).blockhash;
    return transaction2;
  }
}
function isVersionedTransaction$1(transaction2) {
  return "version" in transaction2;
}
class BaseSignerWalletAdapter extends BaseWalletAdapter {
  async sendTransaction(transaction2, connection, options = {}) {
    let emit = true;
    try {
      if (isVersionedTransaction$1(transaction2)) {
        if (!this.supportedTransactionVersions)
          throw new WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);
        if (!this.supportedTransactionVersions.has(transaction2.version))
          throw new WalletSendTransactionError(`Sending transaction version ${transaction2.version} isn't supported by this wallet`);
        try {
          transaction2 = await this.signTransaction(transaction2);
          const rawTransaction = transaction2.serialize();
          return await connection.sendRawTransaction(rawTransaction, options);
        } catch (error) {
          if (error instanceof WalletSignTransactionError$1) {
            emit = false;
            throw error;
          }
          throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
        }
      } else {
        try {
          const { signers, ...sendOptions } = options;
          transaction2 = await this.prepareTransaction(transaction2, connection, sendOptions);
          (signers == null ? void 0 : signers.length) && transaction2.partialSign(...signers);
          transaction2 = await this.signTransaction(transaction2);
          const rawTransaction = transaction2.serialize();
          return await connection.sendRawTransaction(rawTransaction, sendOptions);
        } catch (error) {
          if (error instanceof WalletSignTransactionError$1) {
            emit = false;
            throw error;
          }
          throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
        }
      }
    } catch (error) {
      if (emit) {
        this.emit("error", error);
      }
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    for (const transaction2 of transactions) {
      if (isVersionedTransaction$1(transaction2)) {
        if (!this.supportedTransactionVersions)
          throw new WalletSignTransactionError$1(`Signing versioned transactions isn't supported by this wallet`);
        if (!this.supportedTransactionVersions.has(transaction2.version))
          throw new WalletSignTransactionError$1(`Signing transaction version ${transaction2.version} isn't supported by this wallet`);
      }
    }
    const signedTransactions = [];
    for (const transaction2 of transactions) {
      signedTransactions.push(await this.signTransaction(transaction2));
    }
    return signedTransactions;
  }
}
class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {
}
class BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {
}
const SolanaSignAndSendTransaction = "solana:signAndSendTransaction";
const SolanaSignIn = "solana:signIn";
const SolanaSignMessage = "solana:signMessage";
const SolanaSignTransaction = "solana:signTransaction";
const StandardConnect = "standard:connect";
const StandardDisconnect = "standard:disconnect";
const StandardEvents = "standard:events";
function isWalletAdapterCompatibleStandardWallet(wallet) {
  return StandardConnect in wallet.features && StandardEvents in wallet.features && (SolanaSignAndSendTransaction in wallet.features || SolanaSignTransaction in wallet.features);
}
let WalletNotSelectedError$1 = class WalletNotSelectedError extends WalletError$1 {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
const EMPTY_ARRAY = [];
const DEFAULT_CONTEXT$1 = {
  autoConnect: false,
  connecting: false,
  connected: false,
  disconnecting: false,
  select() {
    logMissingProviderError("call", "select");
  },
  connect() {
    return Promise.reject(logMissingProviderError("call", "connect"));
  },
  disconnect() {
    return Promise.reject(logMissingProviderError("call", "disconnect"));
  },
  sendTransaction() {
    return Promise.reject(logMissingProviderError("call", "sendTransaction"));
  },
  signTransaction() {
    return Promise.reject(logMissingProviderError("call", "signTransaction"));
  },
  signAllTransactions() {
    return Promise.reject(logMissingProviderError("call", "signAllTransactions"));
  },
  signMessage() {
    return Promise.reject(logMissingProviderError("call", "signMessage"));
  },
  signIn() {
    return Promise.reject(logMissingProviderError("call", "signIn"));
  }
};
Object.defineProperty(DEFAULT_CONTEXT$1, "wallets", {
  get() {
    logMissingProviderError("read", "wallets");
    return EMPTY_ARRAY;
  }
});
Object.defineProperty(DEFAULT_CONTEXT$1, "wallet", {
  get() {
    logMissingProviderError("read", "wallet");
    return null;
  }
});
Object.defineProperty(DEFAULT_CONTEXT$1, "publicKey", {
  get() {
    logMissingProviderError("read", "publicKey");
    return null;
  }
});
function logMissingProviderError(action, property) {
  const error = new Error(`You have tried to ${action} "${property}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.`);
  console.error(error);
  return error;
}
const WalletContext$1 = reactExports.createContext(DEFAULT_CONTEXT$1);
function useWallet$1() {
  return reactExports.useContext(WalletContext$1);
}
function useLocalStorage$1(key, defaultState) {
  const state = reactExports.useState(() => {
    try {
      const value2 = localStorage.getItem(key);
      if (value2)
        return JSON.parse(value2);
    } catch (error) {
      if (typeof window !== "undefined") {
        console.error(error);
      }
    }
    return defaultState;
  });
  const value = state[0];
  const isFirstRenderRef = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRenderRef.current) {
      isFirstRenderRef.current = false;
      return;
    }
    try {
      if (value === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, JSON.stringify(value));
      }
    } catch (error) {
      if (typeof window !== "undefined") {
        console.error(error);
      }
    }
  }, [value, key]);
  return state;
}
function getCommitment(commitment) {
  switch (commitment) {
    case "processed":
    case "confirmed":
    case "finalized":
    case void 0:
      return commitment;
    case "recent":
      return "processed";
    case "single":
    case "singleGossip":
      return "confirmed";
    case "max":
    case "root":
      return "finalized";
    default:
      return void 0;
  }
}
const SOLANA_MAINNET_CHAIN = "solana:mainnet";
const SOLANA_DEVNET_CHAIN = "solana:devnet";
const SOLANA_TESTNET_CHAIN = "solana:testnet";
const SOLANA_LOCALNET_CHAIN = "solana:localnet";
const MAINNET_ENDPOINT = "https://api.mainnet-beta.solana.com";
function getChainForEndpoint(endpoint) {
  if (endpoint.includes(MAINNET_ENDPOINT))
    return SOLANA_MAINNET_CHAIN;
  if (/\bdevnet\b/i.test(endpoint))
    return SOLANA_DEVNET_CHAIN;
  if (/\btestnet\b/i.test(endpoint))
    return SOLANA_TESTNET_CHAIN;
  if (/\blocalhost\b/i.test(endpoint) || /\b127\.0\.0\.1\b/.test(endpoint))
    return SOLANA_LOCALNET_CHAIN;
  return SOLANA_MAINNET_CHAIN;
}
function createSignInMessageText(input) {
  let message2 = `${input.domain} wants you to sign in with your Solana account:
`;
  message2 += `${input.address}`;
  if (input.statement) {
    message2 += `

${input.statement}`;
  }
  const fields = [];
  if (input.uri) {
    fields.push(`URI: ${input.uri}`);
  }
  if (input.version) {
    fields.push(`Version: ${input.version}`);
  }
  if (input.chainId) {
    fields.push(`Chain ID: ${input.chainId}`);
  }
  if (input.nonce) {
    fields.push(`Nonce: ${input.nonce}`);
  }
  if (input.issuedAt) {
    fields.push(`Issued At: ${input.issuedAt}`);
  }
  if (input.expirationTime) {
    fields.push(`Expiration Time: ${input.expirationTime}`);
  }
  if (input.notBefore) {
    fields.push(`Not Before: ${input.notBefore}`);
  }
  if (input.requestId) {
    fields.push(`Request ID: ${input.requestId}`);
  }
  if (input.resources) {
    fields.push(`Resources:`);
    for (const resource of input.resources) {
      fields.push(`- ${resource}`);
    }
  }
  if (fields.length) {
    message2 += `

${fields.join("\n")}`;
  }
  return message2;
}
const SolanaMobileWalletAdapterErrorCode = {
  ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
  ERROR_REFLECTOR_ID_OUT_OF_RANGE: "ERROR_REFLECTOR_ID_OUT_OF_RANGE",
  ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
  ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
  ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
  ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
  ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
  ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION"
};
class SolanaMobileWalletAdapterError extends Error {
  constructor(...args) {
    const [code2, message2, data] = args;
    super(message2);
    this.code = code2;
    this.data = data;
    this.name = "SolanaMobileWalletAdapterError";
  }
}
class SolanaMobileWalletAdapterProtocolError extends Error {
  constructor(...args) {
    const [jsonRpcMessageId, code2, message2, data] = args;
    super(message2);
    this.code = code2;
    this.data = data;
    this.jsonRpcMessageId = jsonRpcMessageId;
    this.name = "SolanaMobileWalletAdapterProtocolError";
  }
}
function __awaiter$5(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const publicKeyBuffer = yield crypto.subtle.exportKey("raw", ecdhPublicKey);
    const signatureBuffer = yield crypto.subtle.sign({ hash: "SHA-256", name: "ECDSA" }, associationKeypairPrivateKey, publicKeyBuffer);
    const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);
    response.set(new Uint8Array(publicKeyBuffer), 0);
    response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);
    return response;
  });
}
function encode$2(input) {
  return window.btoa(input);
}
function createSIWSMessage(payload) {
  return createSignInMessageText(payload);
}
function createSIWSMessageBase64(payload) {
  return encode$2(createSIWSMessage(payload));
}
const SolanaSignTransactions = "solana:signTransactions";
const SolanaCloneAuthorization = "solana:cloneAuthorization";
function createMobileWalletProxy(protocolVersion, protocolRequestHandler) {
  return new Proxy({}, {
    get(target, p2) {
      if (target[p2] == null) {
        target[p2] = function(inputParams) {
          return __awaiter$5(this, void 0, void 0, function* () {
            const { method, params } = handleMobileWalletRequest(p2, inputParams, protocolVersion);
            const result = yield protocolRequestHandler(method, params);
            if (method === "authorize" && params.sign_in_payload && !result.sign_in_result) {
              result["sign_in_result"] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);
            }
            return handleMobileWalletResponse(p2, result, protocolVersion);
          });
        };
      }
      return target[p2];
    },
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    }
  });
}
function handleMobileWalletRequest(methodName, methodParams, protocolVersion) {
  let params = methodParams;
  let method = methodName.toString().replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`).toLowerCase();
  switch (methodName) {
    case "authorize": {
      let { chain } = params;
      if (protocolVersion === "legacy") {
        switch (chain) {
          case "solana:testnet": {
            chain = "testnet";
            break;
          }
          case "solana:devnet": {
            chain = "devnet";
            break;
          }
          case "solana:mainnet": {
            chain = "mainnet-beta";
            break;
          }
          default: {
            chain = params.cluster;
          }
        }
        params.cluster = chain;
      } else {
        switch (chain) {
          case "testnet":
          case "devnet": {
            chain = `solana:${chain}`;
            break;
          }
          case "mainnet-beta": {
            chain = "solana:mainnet";
            break;
          }
        }
        params.chain = chain;
      }
    }
    case "reauthorize": {
      const { auth_token, identity } = params;
      if (auth_token) {
        switch (protocolVersion) {
          case "legacy": {
            method = "reauthorize";
            params = { auth_token, identity };
            break;
          }
          default: {
            method = "authorize";
            break;
          }
        }
      }
      break;
    }
  }
  return { method, params };
}
function handleMobileWalletResponse(method, response, protocolVersion) {
  switch (method) {
    case "getCapabilities": {
      const capabilities = response;
      switch (protocolVersion) {
        case "legacy": {
          const features = [SolanaSignTransactions];
          if (capabilities.supports_clone_authorization === true) {
            features.push(SolanaCloneAuthorization);
          }
          return Object.assign(Object.assign({}, capabilities), { features });
        }
        case "v1": {
          return Object.assign(Object.assign({}, capabilities), { supports_sign_and_send_transactions: true, supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization) });
        }
      }
    }
  }
  return response;
}
function signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {
  var _a3;
  return __awaiter$5(this, void 0, void 0, function* () {
    const domain = (_a3 = signInPayload.domain) !== null && _a3 !== void 0 ? _a3 : window.location.host;
    const address2 = authorizationResult.accounts[0].address;
    const siwsMessage = createSIWSMessageBase64(Object.assign(Object.assign({}, signInPayload), { domain, address: address2 }));
    const signMessageResult = yield protocolRequestHandler("sign_messages", {
      addresses: [address2],
      payloads: [siwsMessage]
    });
    const signInResult = {
      address: address2,
      signed_message: siwsMessage,
      signature: signMessageResult.signed_payloads[0].slice(siwsMessage.length)
    };
    return signInResult;
  });
}
const SEQUENCE_NUMBER_BYTES = 4;
function createSequenceNumberVector(sequenceNumber) {
  if (sequenceNumber >= 4294967296) {
    throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
  }
  const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);
  const view = new DataView(byteArray);
  view.setUint32(
    0,
    sequenceNumber,
    /* littleEndian */
    false
  );
  return new Uint8Array(byteArray);
}
const INITIALIZATION_VECTOR_BYTES = 12;
const ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;
function encryptMessage(plaintext, sequenceNumber, sharedSecret) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);
    const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);
    crypto.getRandomValues(initializationVector);
    const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));
    const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);
    response.set(new Uint8Array(sequenceNumberVector), 0);
    response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);
    response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);
    return response;
  });
}
function decryptMessage(message2, sharedSecret) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const sequenceNumberVector = message2.slice(0, SEQUENCE_NUMBER_BYTES);
    const initializationVector = message2.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);
    const ciphertext = message2.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);
    const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);
    const plaintext = getUtf8Decoder().decode(plaintextBuffer);
    return plaintext;
  });
}
function getAlgorithmParams(sequenceNumber, initializationVector) {
  return {
    additionalData: sequenceNumber,
    iv: initializationVector,
    name: "AES-GCM",
    tagLength: 128
    // 16 byte tag => 128 bits
  };
}
let _utf8Decoder;
function getUtf8Decoder() {
  if (_utf8Decoder === void 0) {
    _utf8Decoder = new TextDecoder("utf-8");
  }
  return _utf8Decoder;
}
function generateAssociationKeypair() {
  return __awaiter$5(this, void 0, void 0, function* () {
    return yield crypto.subtle.generateKey(
      {
        name: "ECDSA",
        namedCurve: "P-256"
      },
      false,
      ["sign"]
      /* keyUsages */
    );
  });
}
function generateECDHKeypair() {
  return __awaiter$5(this, void 0, void 0, function* () {
    return yield crypto.subtle.generateKey(
      {
        name: "ECDH",
        namedCurve: "P-256"
      },
      false,
      ["deriveKey", "deriveBits"]
      /* keyUsages */
    );
  });
}
function encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const plaintext = JSON.stringify(jsonRpcMessage);
    const sequenceNumber = jsonRpcMessage.id;
    return encryptMessage(plaintext, sequenceNumber, sharedSecret);
  });
}
function decryptJsonRpcMessage(message2, sharedSecret) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const plaintext = yield decryptMessage(message2, sharedSecret);
    const jsonRpcMessage = JSON.parse(plaintext);
    if (Object.hasOwnProperty.call(jsonRpcMessage, "error")) {
      throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);
    }
    return jsonRpcMessage;
  });
}
function parseHelloRsp(payloadBuffer, associationPublicKey, ecdhPrivateKey) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([
      crypto.subtle.exportKey("raw", associationPublicKey),
      crypto.subtle.importKey(
        "raw",
        payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES),
        { name: "ECDH", namedCurve: "P-256" },
        false,
        []
        /* keyUsages */
      )
    ]);
    const sharedSecret = yield crypto.subtle.deriveBits({ name: "ECDH", public: walletPublicKey }, ecdhPrivateKey, 256);
    const ecdhSecretKey = yield crypto.subtle.importKey(
      "raw",
      sharedSecret,
      "HKDF",
      false,
      ["deriveKey"]
      /* keyUsages */
    );
    const aesKeyMaterialVal = yield crypto.subtle.deriveKey({
      name: "HKDF",
      hash: "SHA-256",
      salt: new Uint8Array(associationPublicKeyBuffer),
      info: new Uint8Array()
    }, ecdhSecretKey, { name: "AES-GCM", length: 128 }, false, ["encrypt", "decrypt"]);
    return aesKeyMaterialVal;
  });
}
function parseSessionProps(message2, sharedSecret) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const plaintext = yield decryptMessage(message2, sharedSecret);
    const jsonProperties = JSON.parse(plaintext);
    let protocolVersion = "legacy";
    if (Object.hasOwnProperty.call(jsonProperties, "v")) {
      switch (jsonProperties.v) {
        case 1:
        case "1":
        case "v1":
          protocolVersion = "v1";
          break;
        case "legacy":
          protocolVersion = "legacy";
          break;
        default:
          throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);
      }
    }
    return {
      protocol_version: protocolVersion
    };
  });
}
function getRandomAssociationPort() {
  return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));
}
function assertAssociationPort(port) {
  if (port < 49152 || port > 65535) {
    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, { port });
  }
  return port;
}
function arrayBufferToBase64String(buffer2) {
  let binary = "";
  const bytes2 = new Uint8Array(buffer2);
  const len = bytes2.byteLength;
  for (let ii2 = 0; ii2 < len; ii2++) {
    binary += String.fromCharCode(bytes2[ii2]);
  }
  return window.btoa(binary);
}
function getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {
  return unsafeBase64EncodedString.replace(/[/+=]/g, (m2) => ({
    "/": "_",
    "+": "-",
    "=": "."
  })[m2]);
}
const INTENT_NAME = "solana-wallet";
function getPathParts(pathString) {
  return pathString.replace(/(^\/+|\/+$)/g, "").split("/");
}
function getIntentURL(methodPathname, intentUrlBase) {
  let baseUrl = null;
  if (intentUrlBase) {
    try {
      baseUrl = new URL(intentUrlBase);
    } catch (_a3) {
    }
    if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== "https:") {
      throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs");
    }
  }
  baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));
  const pathname = methodPathname.startsWith("/") ? (
    // Method is an absolute path. Replace it wholesale.
    methodPathname
  ) : (
    // Method is a relative path. Merge it with the existing one.
    [...getPathParts(baseUrl.pathname), ...getPathParts(methodPathname)].join("/")
  );
  return new URL(pathname, baseUrl);
}
function getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = ["v1"]) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const associationPort = assertAssociationPort(putativePort);
    const exportedKey = yield crypto.subtle.exportKey("raw", associationPublicKey);
    const encodedKey = arrayBufferToBase64String(exportedKey);
    const url = getIntentURL("v1/associate/local", associationURLBase);
    url.searchParams.set("association", getStringWithURLUnsafeCharactersReplaced(encodedKey));
    url.searchParams.set("port", `${associationPort}`);
    protocolVersions.forEach((version2) => {
      url.searchParams.set("v", version2);
    });
    return url;
  });
}
const Browser = {
  Firefox: 0,
  Other: 1
};
function assertUnreachable(x2) {
  return x2;
}
function getBrowser() {
  return navigator.userAgent.indexOf("Firefox/") !== -1 ? Browser.Firefox : Browser.Other;
}
function getDetectionPromise() {
  return new Promise((resolve, reject) => {
    function cleanup() {
      clearTimeout(timeoutId);
      window.removeEventListener("blur", handleBlur);
    }
    function handleBlur() {
      cleanup();
      resolve();
    }
    window.addEventListener("blur", handleBlur);
    const timeoutId = setTimeout(() => {
      cleanup();
      reject();
    }, 2e3);
  });
}
let _frame = null;
function launchUrlThroughHiddenFrame(url) {
  if (_frame == null) {
    _frame = document.createElement("iframe");
    _frame.style.display = "none";
    document.body.appendChild(_frame);
  }
  _frame.contentWindow.location.href = url.toString();
}
function launchAssociation(associationUrl) {
  return __awaiter$5(this, void 0, void 0, function* () {
    if (associationUrl.protocol === "https:") {
      window.location.assign(associationUrl);
    } else {
      try {
        const browser2 = getBrowser();
        switch (browser2) {
          case Browser.Firefox:
            launchUrlThroughHiddenFrame(associationUrl);
            break;
          case Browser.Other: {
            const detectionPromise = getDetectionPromise();
            window.location.assign(associationUrl);
            yield detectionPromise;
            break;
          }
          default:
            assertUnreachable(browser2);
        }
      } catch (e2) {
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, "Found no installed wallet that supports the mobile wallet protocol.");
      }
    }
  });
}
function startSession(associationPublicKey, associationURLBase) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const randomAssociationPort = getRandomAssociationPort();
    const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);
    yield launchAssociation(associationUrl);
    return randomAssociationPort;
  });
}
const WEBSOCKET_CONNECTION_CONFIG = {
  /**
   * 300 milliseconds is a generally accepted threshold for what someone
   * would consider an acceptable response time for a user interface
   * after having performed a low-attention tapping task. We set the initial
   * interval at which we wait for the wallet to set up the websocket at
   * half this, as per the Nyquist frequency, with a progressive backoff
   * sequence from there. The total wait time is 30s, which allows for the
   * user to be presented with a disambiguation dialog, select a wallet, and
   * for the wallet app to subsequently start.
   */
  retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
  timeoutMs: 3e4
};
const WEBSOCKET_PROTOCOL = "com.solana.mobilewalletadapter.v1";
function assertSecureContext() {
  if (typeof window === "undefined" || window.isSecureContext !== true) {
    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, "The mobile wallet adapter protocol must be used in a secure context (`https`).");
  }
}
function assertSecureEndpointSpecificURI(walletUriBase) {
  let url;
  try {
    url = new URL(walletUriBase);
  } catch (_a3) {
    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, "Invalid base URL supplied by wallet");
  }
  if (url.protocol !== "https:") {
    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs");
  }
}
function getSequenceNumberFromByteArray(byteArray) {
  const view = new DataView(byteArray);
  return view.getUint32(
    0,
    /* littleEndian */
    false
  );
}
function transact$1(callback, config2) {
  return __awaiter$5(this, void 0, void 0, function* () {
    assertSecureContext();
    const associationKeypair = yield generateAssociationKeypair();
    const sessionPort = yield startSession(associationKeypair.publicKey, config2 === null || config2 === void 0 ? void 0 : config2.baseUri);
    const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;
    let connectionStartTime;
    const getNextRetryDelayMs = (() => {
      const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];
      return () => schedule.length > 1 ? schedule.shift() : schedule[0];
    })();
    let nextJsonRpcMessageId = 1;
    let lastKnownInboundSequenceNumber = 0;
    let state = { __type: "disconnected" };
    return new Promise((resolve, reject) => {
      let socket;
      const jsonRpcResponsePromises = {};
      const handleOpen = () => __awaiter$5(this, void 0, void 0, function* () {
        if (state.__type !== "connecting") {
          console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${state.__type}\`.`);
          return;
        }
        socket.removeEventListener("open", handleOpen);
        const { associationKeypair: associationKeypair2 } = state;
        const ecdhKeypair = yield generateECDHKeypair();
        socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair2.privateKey));
        state = {
          __type: "hello_req_sent",
          associationPublicKey: associationKeypair2.publicKey,
          ecdhPrivateKey: ecdhKeypair.privateKey
        };
      });
      const handleClose = (evt) => {
        if (evt.wasClean) {
          state = { __type: "disconnected" };
        } else {
          reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));
        }
        disposeSocket();
      };
      const handleError = (_evt) => __awaiter$5(this, void 0, void 0, function* () {
        disposeSocket();
        if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {
          reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));
        } else {
          yield new Promise((resolve2) => {
            const retryDelayMs = getNextRetryDelayMs();
            retryWaitTimeoutId = window.setTimeout(resolve2, retryDelayMs);
          });
          attemptSocketConnection();
        }
      });
      const handleMessage = (evt) => __awaiter$5(this, void 0, void 0, function* () {
        const responseBuffer = yield evt.data.arrayBuffer();
        switch (state.__type) {
          case "connecting":
            if (responseBuffer.byteLength !== 0) {
              throw new Error("Encountered unexpected message while connecting");
            }
            const ecdhKeypair = yield generateECDHKeypair();
            socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));
            state = {
              __type: "hello_req_sent",
              associationPublicKey: associationKeypair.publicKey,
              ecdhPrivateKey: ecdhKeypair.privateKey
            };
            break;
          case "connected":
            try {
              const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);
              const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);
              if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {
                throw new Error("Encrypted message has invalid sequence number");
              }
              lastKnownInboundSequenceNumber = sequenceNumber;
              const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);
              const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];
              delete jsonRpcResponsePromises[jsonRpcMessage.id];
              responsePromise.resolve(jsonRpcMessage.result);
            } catch (e2) {
              if (e2 instanceof SolanaMobileWalletAdapterProtocolError) {
                const responsePromise = jsonRpcResponsePromises[e2.jsonRpcMessageId];
                delete jsonRpcResponsePromises[e2.jsonRpcMessageId];
                responsePromise.reject(e2);
              } else {
                throw e2;
              }
            }
            break;
          case "hello_req_sent": {
            if (responseBuffer.byteLength === 0) {
              const ecdhKeypair2 = yield generateECDHKeypair();
              socket.send(yield createHelloReq(ecdhKeypair2.publicKey, associationKeypair.privateKey));
              state = {
                __type: "hello_req_sent",
                associationPublicKey: associationKeypair.publicKey,
                ecdhPrivateKey: ecdhKeypair2.privateKey
              };
              break;
            }
            const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);
            const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);
            const sessionProperties = sessionPropertiesBuffer.byteLength !== 0 ? yield (() => __awaiter$5(this, void 0, void 0, function* () {
              const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);
              const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);
              if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {
                throw new Error("Encrypted message has invalid sequence number");
              }
              lastKnownInboundSequenceNumber = sequenceNumber;
              return parseSessionProps(sessionPropertiesBuffer, sharedSecret);
            }))() : { protocol_version: "legacy" };
            state = { __type: "connected", sharedSecret, sessionProperties };
            const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter$5(this, void 0, void 0, function* () {
              const id2 = nextJsonRpcMessageId++;
              socket.send(yield encryptJsonRpcMessage({
                id: id2,
                jsonrpc: "2.0",
                method,
                params: params !== null && params !== void 0 ? params : {}
              }, sharedSecret));
              return new Promise((resolve2, reject2) => {
                jsonRpcResponsePromises[id2] = {
                  resolve(result) {
                    switch (method) {
                      case "authorize":
                      case "reauthorize": {
                        const { wallet_uri_base } = result;
                        if (wallet_uri_base != null) {
                          try {
                            assertSecureEndpointSpecificURI(wallet_uri_base);
                          } catch (e2) {
                            reject2(e2);
                            return;
                          }
                        }
                        break;
                      }
                    }
                    resolve2(result);
                  },
                  reject: reject2
                };
              });
            }));
            try {
              resolve(yield callback(wallet));
            } catch (e2) {
              reject(e2);
            } finally {
              disposeSocket();
              socket.close();
            }
            break;
          }
        }
      });
      let disposeSocket;
      let retryWaitTimeoutId;
      const attemptSocketConnection = () => {
        if (disposeSocket) {
          disposeSocket();
        }
        state = { __type: "connecting", associationKeypair };
        if (connectionStartTime === void 0) {
          connectionStartTime = Date.now();
        }
        socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL]);
        socket.addEventListener("open", handleOpen);
        socket.addEventListener("close", handleClose);
        socket.addEventListener("error", handleError);
        socket.addEventListener("message", handleMessage);
        disposeSocket = () => {
          window.clearTimeout(retryWaitTimeoutId);
          socket.removeEventListener("open", handleOpen);
          socket.removeEventListener("close", handleClose);
          socket.removeEventListener("error", handleError);
          socket.removeEventListener("message", handleMessage);
        };
      };
      attemptSocketConnection();
    });
  });
}
function base$1(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x2 = ALPHABET2.charAt(i);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i;
  }
  var BASE2 = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode4(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      pbegin++;
    }
    var it2 = size2 - length;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      psz++;
    }
    var it4 = size2 - length;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode3(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode3
  };
}
var src = base$1;
const basex = src;
const ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$2);
const bs58$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(bs58);
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
function __awaiter$4(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function fromUint8Array(byteArray) {
  return window.btoa(String.fromCharCode.call(null, ...byteArray));
}
function toUint8Array$1(base64EncodedByteArray) {
  return new Uint8Array(window.atob(base64EncodedByteArray).split("").map((c) => c.charCodeAt(0)));
}
function getPayloadFromTransaction(transaction2) {
  const serializedTransaction = "version" in transaction2 ? transaction2.serialize() : transaction2.serialize({
    requireAllSignatures: false,
    verifySignatures: false
  });
  const payload = fromUint8Array(serializedTransaction);
  return payload;
}
function getTransactionFromWireMessage(byteArray) {
  const numSignatures = byteArray[0];
  const messageOffset = numSignatures * SIGNATURE_LENGTH_IN_BYTES + 1;
  const version2 = VersionedMessage.deserializeMessageVersion(byteArray.slice(messageOffset, byteArray.length));
  if (version2 === "legacy") {
    return Transaction$2.from(byteArray);
  } else {
    return VersionedTransaction.deserialize(byteArray);
  }
}
function transact(callback, config2) {
  return __awaiter$4(this, void 0, void 0, function* () {
    const augmentedCallback = (wallet) => {
      const augmentedAPI = new Proxy({}, {
        get(target, p2) {
          if (target[p2] == null) {
            switch (p2) {
              case "signAndSendTransactions":
                target[p2] = function(_a3) {
                  var { minContextSlot, commitment, skipPreflight, maxRetries, waitForCommitmentToSendNextTransaction, transactions } = _a3, rest = __rest(_a3, ["minContextSlot", "commitment", "skipPreflight", "maxRetries", "waitForCommitmentToSendNextTransaction", "transactions"]);
                  return __awaiter$4(this, void 0, void 0, function* () {
                    const payloads = transactions.map(getPayloadFromTransaction);
                    const options = {
                      min_context_slot: minContextSlot,
                      commitment,
                      skip_preflight: skipPreflight,
                      max_retries: maxRetries,
                      wait_for_commitment_to_send_next_transaction: waitForCommitmentToSendNextTransaction
                    };
                    const { signatures: base64EncodedSignatures } = yield wallet.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, rest), Object.values(options).some((element) => element != null) ? { options } : null), { payloads }));
                    const signatures = base64EncodedSignatures.map(toUint8Array$1).map(bs58$1.encode);
                    return signatures;
                  });
                };
                break;
              case "signMessages":
                target[p2] = function(_a3) {
                  var { payloads } = _a3, rest = __rest(_a3, ["payloads"]);
                  return __awaiter$4(this, void 0, void 0, function* () {
                    const base64EncodedPayloads = payloads.map(fromUint8Array);
                    const { signed_payloads: base64EncodedSignedMessages } = yield wallet.signMessages(Object.assign(Object.assign({}, rest), { payloads: base64EncodedPayloads }));
                    const signedMessages = base64EncodedSignedMessages.map(toUint8Array$1);
                    return signedMessages;
                  });
                };
                break;
              case "signTransactions":
                target[p2] = function(_a3) {
                  var { transactions } = _a3, rest = __rest(_a3, ["transactions"]);
                  return __awaiter$4(this, void 0, void 0, function* () {
                    const payloads = transactions.map(getPayloadFromTransaction);
                    const { signed_payloads: base64EncodedCompiledTransactions } = yield wallet.signTransactions(Object.assign(Object.assign({}, rest), { payloads }));
                    const compiledTransactions = base64EncodedCompiledTransactions.map(toUint8Array$1);
                    const signedTransactions = compiledTransactions.map(getTransactionFromWireMessage);
                    return signedTransactions;
                  });
                };
                break;
              default: {
                target[p2] = wallet[p2];
                break;
              }
            }
          }
          return target[p2];
        },
        defineProperty() {
          return false;
        },
        deleteProperty() {
          return false;
        }
      });
      return callback(augmentedAPI);
    };
    return yield transact$1(augmentedCallback, config2);
  });
}
var browser = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var utils$5 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$5.getSymbolSize = function getSymbolSize(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$5.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$5.getBCHDigit = function(data) {
  let digit = 0;
  while (data !== 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
};
utils$5.setToSJISFunction = function setToSJISFunction(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f2;
};
utils$5.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$5.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports) {
  exports.L = { bit: 1 };
  exports.M = { bit: 0 };
  exports.Q = { bit: 3 };
  exports.H = { bit: 2 };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports.L;
      case "m":
      case "medium":
        return exports.M;
      case "q":
      case "quartile":
        return exports.Q;
      case "h":
      case "high":
        return exports.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports.isValid = function isValid2(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit((num >>> length - i - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value, reserved) {
  const index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports) {
  const getSymbolSize3 = utils$5.getSymbolSize;
  exports.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize3(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i = 1; i < posCount - 1; i++) {
      positions[i] = positions[i - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports.getPositions = function getPositions2(version2) {
    const coords = [];
    const pos = exports.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i = 0; i < posLength; i++) {
      for (let j = 0; j < posLength; j++) {
        if (i === 0 && j === 0 || // top-left
        i === 0 && j === posLength - 1 || // bottom-left
        i === posLength - 1 && j === 0) {
          continue;
        }
        coords.push([pos[i], pos[j]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
const getSymbolSize2 = utils$5.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions(version2) {
  const size2 = getSymbolSize2(version2);
  return [
    // top-left
    [0, 0],
    // top-right
    [size2 - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports) {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports.isValid = function isValid2(mask2) {
    return mask2 != null && mask2 !== "" && !isNaN(mask2) && mask2 >= 0 && mask2 <= 7;
  };
  exports.from = function from(value) {
    return exports.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports.getPenaltyN1 = function getPenaltyN1(data) {
    const size2 = data.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size2; col++) {
        let module = data.get(row, col);
        if (module === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module;
          sameCountCol = 1;
        }
        module = data.get(col, row);
        if (module === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports.getPenaltyN2 = function getPenaltyN2(data) {
    const size2 = data.size;
    let points = 0;
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
        if (last === 4 || last === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports.getPenaltyN3 = function getPenaltyN3(data) {
    const size2 = data.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0;
    const modulesCount = data.data.length;
    for (let i = 0; i < modulesCount; i++)
      darkCount += data.data[i];
    const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k2 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i, j) {
    switch (maskPattern2) {
      case exports.Patterns.PATTERN000:
        return (i + j) % 2 === 0;
      case exports.Patterns.PATTERN001:
        return i % 2 === 0;
      case exports.Patterns.PATTERN010:
        return j % 3 === 0;
      case exports.Patterns.PATTERN011:
        return (i + j) % 3 === 0;
      case exports.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
      case exports.Patterns.PATTERN101:
        return i * j % 2 + i * j % 3 === 0;
      case exports.Patterns.PATTERN110:
        return (i * j % 2 + i * j % 3) % 2 === 0;
      case exports.Patterns.PATTERN111:
        return (i * j % 3 + (i + j) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports.applyMask = function applyMask(pattern, data) {
    const size2 = data.size;
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data.isReserved(row, col))
          continue;
        data.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports.applyMask(p2, data);
      const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
      exports.applyMask(p2, data);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel;
const EC_BLOCKS_TABLE = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x2 = 1;
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x2;
    LOG_TABLE[x2] = i;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255];
  }
})();
galoisField.log = function log(n2) {
  if (n2 < 1)
    throw new Error("log(" + n2 + ")");
  return LOG_TABLE[n2];
};
galoisField.exp = function exp(n2) {
  return EXP_TABLE[n2];
};
galoisField.mul = function mul(x2, y2) {
  if (x2 === 0 || y2 === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
};
(function(exports) {
  const GF = galoisField;
  exports.mul = function mul2(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i = 0; i < p1.length; i++) {
      for (let j = 0; j < p2.length; j++) {
        coeff[i + j] ^= GF.mul(p1[i], p2[j]);
      }
    }
    return coeff;
  };
  exports.mod = function mod2(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i = 0; i < divisor.length; i++) {
        result[i] ^= GF.mul(divisor[i], coeff);
      }
      let offset2 = 0;
      while (offset2 < result.length && result[offset2] === 0)
        offset2++;
      result = result.slice(offset2);
    }
    return result;
  };
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i = 0; i < degree; i++) {
      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
    }
    return poly;
  };
})(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode2(data) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data.length + this.degree);
  paddedData.set(data);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version$2 = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
const numeric = "[0-9]+";
const alphanumeric$1 = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric$1, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str);
};
regex.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str);
};
regex.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str);
};
(function(exports) {
  const VersionCheck = versionCheck;
  const Regex = regex;
  exports.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports.MIXED = {
    bit: -1
  };
  exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports.KANJI;
    else
      return exports.BYTE;
  };
  exports.toString = function toString3(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports.isValid = function isValid2(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports.NUMERIC;
      case "alphanumeric":
        return exports.ALPHANUMERIC;
      case "kanji":
        return exports.KANJI;
      case "byte":
        return exports.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode);
(function(exports) {
  const Utils2 = utils$5;
  const ECCode2 = errorCorrectionCode;
  const ECLevel2 = errorCorrectionLevel;
  const Mode2 = mode;
  const VersionCheck = versionCheck;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data) {
      const reservedBits = getReservedBitsCount(data.mode, version2);
      totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports.from = function from(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl);
      }
      if (data.length === 0) {
        return 1;
      }
      seg = data[0];
    } else {
      seg = data;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d = version2 << 12;
    while (Utils2.getBCHDigit(d) - G18_BCH >= 0) {
      d ^= G18 << Utils2.getBCHDigit(d) - G18_BCH;
    }
    return version2 << 12 | d;
  };
})(version$2);
var formatInfo = {};
const Utils$3 = utils$5;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask2) {
  const data = errorCorrectionLevel2.bit << 3 | mask2;
  let d = data << 10;
  while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= G15 << Utils$3.getBCHDigit(d) - G15_BCH;
  }
  return (data << 10 | d) ^ G15_MASK;
};
var segments = {};
const Mode$4 = mode;
function NumericData(data) {
  this.mode = Mode$4.NUMERIC;
  this.data = data.toString();
}
NumericData.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write(bitBuffer2) {
  let i, group, value;
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const Mode$3 = mode;
const ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data;
}
AlphanumericData.getBitsLength = function getBitsLength3(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write2(bitBuffer2) {
  let i;
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
  }
};
var alphanumericData = AlphanumericData;
const Mode$2 = mode;
function ByteData(data) {
  this.mode = Mode$2.BYTE;
  if (typeof data === "string") {
    this.data = new TextEncoder().encode(data);
  } else {
    this.data = new Uint8Array(data);
  }
}
ByteData.getBitsLength = function getBitsLength5(length) {
  return length * 8;
};
ByteData.prototype.getLength = function getLength3() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i = 0, l2 = this.data.length; i < l2; i++) {
    bitBuffer2.put(this.data[i], 8);
  }
};
var byteData = ByteData;
const Mode$1 = mode;
const Utils$2 = utils$5;
function KanjiData(data) {
  this.mode = Mode$1.KANJI;
  this.data = data;
}
KanjiData.getBitsLength = function getBitsLength7(length) {
  return length * 13;
};
KanjiData.prototype.getLength = function getLength4() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i;
  for (i = 0; i < this.data.length; i++) {
    let value = Utils$2.toSJIS(this.data[i]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error(
        "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
      );
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
var dijkstra = { exports: {} };
(function(module) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s, d) {
      var predecessors = {};
      var costs = {};
      costs[s] = 0;
      var open = dijkstra2.PriorityQueue.make();
      open.push(s, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
        var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d) {
      var nodes = [];
      var u2 = d;
      while (u2) {
        nodes.push(u2);
        predecessors[u2];
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s, d) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d);
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(opts) {
        var T9 = dijkstra2.PriorityQueue, t2 = {}, key;
        opts = opts || {};
        for (key in T9) {
          if (T9.hasOwnProperty(key)) {
            t2[key] = T9[key];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T9.default_sorter;
        return t2;
      },
      default_sorter: function(a, b2) {
        return a.cost - b2.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module.exports = dijkstra2;
  }
})(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(exports) {
  const Mode2 = mode;
  const NumericData2 = numericData;
  const AlphanumericData2 = alphanumericData;
  const ByteData2 = byteData;
  const KanjiData2 = kanjiData;
  const Regex = regex;
  const Utils2 = utils$5;
  const dijkstra2 = dijkstraExports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i = 0; i < segs.length; i++) {
      const seg = segs[i];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i = 0; i < nodes.length; i++) {
      const nodeGroup = nodes[i];
      const currentNodeIds = [];
      for (let j = 0; j < nodeGroup.length; j++) {
        const node = nodeGroup[j];
        const key = "" + i + j;
        currentNodeIds.push(key);
        table[key] = { node, lastCount: 0 };
        graph[key] = {};
        for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
          const prevNodeId = prevNodeIds[n2];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode2.getCharCountIndicator(node.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
      graph[prevNodeIds[n2]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data);
      case Mode2.KANJI:
        return new KanjiData2(data);
      case Mode2.BYTE:
        return new ByteData2(data);
    }
  }
  exports.fromArray = function fromArray(array2) {
    return array2.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports.fromString = function fromString(data, version2) {
    const segs = getSegmentsFromString(data, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra2.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i = 1; i < path.length - 1; i++) {
      optimizedSegs.push(graph.table[path[i]].node);
    }
    return exports.fromArray(mergeSegments(optimizedSegs));
  };
  exports.rawSplit = function rawSplit(data) {
    return exports.fromArray(
      getSegmentsFromString(data, Utils2.isKanjiModeEnabled())
    );
  };
})(segments);
const Utils$1 = utils$5;
const ECLevel = errorCorrectionLevel;
const BitBuffer = bitBuffer;
const BitMatrix = bitMatrix;
const AlignmentPattern = alignmentPattern;
const FinderPattern = finderPattern;
const MaskPattern = maskPattern;
const ECCode = errorCorrectionCode;
const ReedSolomonEncoder = reedSolomonEncoder;
const Version = version$2;
const FormatInfo = formatInfo;
const Mode = mode;
const Segments = segments;
function setupFinderPattern(matrix, version2) {
  const size2 = matrix.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (let c = -1; c <= 7; c++) {
        if (col + c <= -1 || size2 <= col + c)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c >= 2 && c <= 4) {
          matrix.set(row + r2, col + c, true, true);
        } else {
          matrix.set(row + r2, col + c, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size2 = matrix.size;
  for (let r2 = 8; r2 < size2 - 8; r2++) {
    const value = r2 % 2 === 0;
    matrix.set(r2, 6, value, true);
    matrix.set(6, r2, value, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r2 = -2; r2 <= 2; r2++) {
      for (let c = -2; c <= 2; c++) {
        if (r2 === -2 || r2 === 2 || c === -2 || c === 2 || r2 === 0 && c === 0) {
          matrix.set(row + r2, col + c, true, true);
        } else {
          matrix.set(row + r2, col + c, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size2 = matrix.size;
  const bits = Version.getEncodedBits(version2);
  let row, col, mod2;
  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3);
    col = i % 3 + size2 - 8 - 3;
    mod2 = (bits >> i & 1) === 1;
    matrix.set(row, col, mod2, true);
    matrix.set(col, row, mod2, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i, mod2;
  for (i = 0; i < 15; i++) {
    mod2 = (bits >> i & 1) === 1;
    if (i < 6) {
      matrix.set(i, 8, mod2, true);
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod2, true);
    } else {
      matrix.set(size2 - 15 + i, 8, mod2, true);
    }
    if (i < 8) {
      matrix.set(8, size2 - i - 1, mod2, true);
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod2, true);
    } else {
      matrix.set(8, 15 - i - 1, mod2, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data) {
  const size2 = matrix.size;
  let inc = -1;
  let row = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (let c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          let dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size2 <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data) {
    buffer2.put(data.mode.bit, 4);
    buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
    data.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i = 0; i < remainingByte; i++) {
    buffer2.put(i % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder(ecCount);
  let offset2 = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
    const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset2, offset2 + dataSize);
    ecData[b2] = rs.encode(dcData[b2]);
    offset2 += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i, r2;
  for (i = 0; i < maxDataSize; i++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i < dcData[r2].length) {
        data[index2++] = dcData[r2][i];
      }
    }
  }
  for (i = 0; i < ecCount; i++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data[index2++] = ecData[r2][i];
    }
  }
  return data;
}
function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data)) {
    segments2 = Segments.fromArray(data);
  } else if (typeof data === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error(
      "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
    );
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
    );
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create2(data, options) {
  if (typeof data === "undefined" || data === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask2;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask2 = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data, version2, errorCorrectionLevel2, mask2);
};
var canvas = {};
var utils$4 = {};
(function(exports) {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
        return [c, c];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue >> 24 & 255,
      g: hexValue >> 16 & 255,
      b: hexValue >> 8 & 255,
      a: hexValue & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size;
    const data = qr.modules.data;
    const scale = exports.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i = 0; i < symbolSize; i++) {
      for (let j = 0; j < symbolSize; j++) {
        let posDst = (i * symbolSize + j) * 4;
        let pxColor = opts.color.light;
        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i - scaledMargin) / scale);
          const jSrc = Math.floor((j - scaledMargin) / scale);
          pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$4);
(function(exports) {
  const Utils2 = utils$4;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports.render = function render2(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports.render(qrData, canvas2, opts);
    const type2 = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type2, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
const Utils = utils$4;
function getColorAttrib(color, attrib) {
  const alpha2 = color.a / 255;
  const str = attrib + '="' + color.hex + '"';
  return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y2) {
  let str = cmd + x2;
  if (typeof y2 !== "undefined")
    str += " " + y2;
  return str;
}
function qrToPath(data, size2, margin) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size2);
    const row = Math.floor(i / size2);
    if (!col && !newRow)
      newRow = true;
    if (data[i]) {
      lineLength++;
      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data[i + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render(qrData, options, cb2) {
  const opts = Utils.getOptions(options);
  const size2 = qrData.modules.size;
  const data = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg2 = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg2 + path + "</svg>\n";
  if (typeof cb2 === "function") {
    cb2(null, svgTag2);
  }
  return svgTag2;
};
const canPromise = canPromise$1;
const QRCode$1 = qrcode;
const CanvasRenderer = canvas;
const SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text, opts, cb2) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb2 = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb2 === "undefined") {
        cb2 = opts;
        opts = void 0;
      } else {
        cb2 = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data = QRCode$1.create(text, opts);
        resolve(renderFunc(data, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data = QRCode$1.create(text, opts);
    cb2(null, renderFunc(data, canvas2, opts));
  } catch (e2) {
    cb2(e2);
  }
}
browser.create = QRCode$1.create;
browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser.toString = renderCanvas.bind(null, function(data, _, opts) {
  return SvgRenderer.render(data, opts);
});
function __awaiter$3(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function toUint8Array(base64EncodedByteArray) {
  return new Uint8Array(window.atob(base64EncodedByteArray).split("").map((c) => c.charCodeAt(0)));
}
function getIsSupported$1() {
  return typeof window !== "undefined" && window.isSecureContext && typeof document !== "undefined" && /android/i.test(navigator.userAgent);
}
const SolanaMobileWalletAdapterWalletName = "Mobile Wallet Adapter";
const SIGNATURE_LENGTH_IN_BYTES$1 = 64;
function getPublicKeyFromAddress$1(address2) {
  const publicKeyByteArray = toUint8Array(address2);
  return new PublicKey(publicKeyByteArray);
}
function isVersionedTransaction(transaction2) {
  return "version" in transaction2;
}
function clusterToChainId(cluster) {
  switch (cluster) {
    case "mainnet-beta":
      return "solana:mainnet";
    case "testnet":
      return "solana:testnet";
    case "devnet":
      return "solana:devnet";
  }
}
class SolanaMobileWalletAdapter extends BaseSignInMessageSignerWalletAdapter {
  constructor(config2) {
    var _a3;
    super();
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(
      // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.
      ["legacy", 0]
    );
    this.name = SolanaMobileWalletAdapterWalletName;
    this.url = "https://solanamobile.com/wallets";
    this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==";
    this._connecting = false;
    this._connectionGeneration = 0;
    this._readyState = getIsSupported$1() ? WalletReadyState$1.Loadable : WalletReadyState$1.Unsupported;
    this._authorizationResultCache = config2.authorizationResultCache;
    this._addressSelector = config2.addressSelector;
    this._appIdentity = config2.appIdentity;
    this._chain = (_a3 = config2.chain) !== null && _a3 !== void 0 ? _a3 : clusterToChainId(config2.cluster);
    this._hostAuthority = config2.remoteHostAuthority;
    this._onWalletNotFound = config2.onWalletNotFound;
    if (this._readyState !== WalletReadyState$1.Unsupported) {
      this._authorizationResultCache.get().then((authorizationResult) => {
        if (authorizationResult) {
          this.declareWalletAsInstalled();
        }
      });
    }
  }
  get publicKey() {
    if (this._publicKey == null && this._selectedAddress != null) {
      try {
        this._publicKey = getPublicKeyFromAddress$1(this._selectedAddress);
      } catch (e2) {
        throw new WalletPublicKeyError(e2 instanceof Error && (e2 === null || e2 === void 0 ? void 0 : e2.message) || "Unknown error", e2);
      }
    }
    return this._publicKey ? this._publicKey : null;
  }
  get connected() {
    return !!this._authorizationResult;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  declareWalletAsInstalled() {
    if (this._readyState !== WalletReadyState$1.Installed) {
      this.emit("readyStateChange", this._readyState = WalletReadyState$1.Installed);
    }
  }
  runWithGuard(callback) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        return yield callback();
      } catch (e2) {
        this.emit("error", e2);
        throw e2;
      }
    });
  }
  /** @deprecated Use `autoConnect()` instead. */
  autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return yield this.autoConnect();
    });
  }
  autoConnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.connecting || this.connected) {
        return;
      }
      return yield this.runWithGuard(() => __awaiter$3(this, void 0, void 0, function* () {
        if (this._readyState !== WalletReadyState$1.Installed && this._readyState !== WalletReadyState$1.Loadable) {
          throw new WalletNotReadyError();
        }
        this._connecting = true;
        try {
          const cachedAuthorizationResult = yield this._authorizationResultCache.get();
          if (cachedAuthorizationResult) {
            this.handleAuthorizationResult(cachedAuthorizationResult);
          }
        } catch (e2) {
          throw new WalletConnectionError$1(e2 instanceof Error && e2.message || "Unknown error", e2);
        } finally {
          this._connecting = false;
        }
      }));
    });
  }
  connect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.connecting || this.connected) {
        return;
      }
      return yield this.runWithGuard(() => __awaiter$3(this, void 0, void 0, function* () {
        if (this._readyState !== WalletReadyState$1.Installed && this._readyState !== WalletReadyState$1.Loadable) {
          throw new WalletNotReadyError();
        }
        this._connecting = true;
        try {
          yield this.performAuthorization();
        } catch (e2) {
          throw new WalletConnectionError$1(e2 instanceof Error && e2.message || "Unknown error", e2);
        } finally {
          this._connecting = false;
        }
      }));
    });
  }
  performAuthorization(signInPayload) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const cachedAuthorizationResult = yield this._authorizationResultCache.get();
        if (cachedAuthorizationResult) {
          this.handleAuthorizationResult(cachedAuthorizationResult);
          return cachedAuthorizationResult;
        }
        return yield this.transact((wallet) => __awaiter$3(this, void 0, void 0, function* () {
          const authorizationResult = yield wallet.authorize({
            chain: this._chain,
            identity: this._appIdentity,
            sign_in_payload: signInPayload
          });
          Promise.all([
            this._authorizationResultCache.set(authorizationResult),
            this.handleAuthorizationResult(authorizationResult)
          ]);
          return authorizationResult;
        }));
      } catch (e2) {
        throw new WalletConnectionError$1(e2 instanceof Error && e2.message || "Unknown error", e2);
      }
    });
  }
  handleAuthorizationResult(authorizationResult) {
    var _a3;
    return __awaiter$3(this, void 0, void 0, function* () {
      const didPublicKeysChange = (
        // Case 1: We started from having no authorization.
        this._authorizationResult == null || // Case 2: The number of authorized accounts changed.
        ((_a3 = this._authorizationResult) === null || _a3 === void 0 ? void 0 : _a3.accounts.length) !== authorizationResult.accounts.length || // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.
        this._authorizationResult.accounts.some((account, ii2) => account.address !== authorizationResult.accounts[ii2].address)
      );
      this._authorizationResult = authorizationResult;
      this.declareWalletAsInstalled();
      if (didPublicKeysChange) {
        const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address: address2 }) => address2));
        if (nextSelectedAddress !== this._selectedAddress) {
          this._selectedAddress = nextSelectedAddress;
          delete this._publicKey;
          this.emit(
            "connect",
            // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.publicKey
          );
        }
      }
    });
  }
  performReauthorization(wallet, authToken) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const authorizationResult = yield wallet.authorize({
          auth_token: authToken,
          identity: this._appIdentity
        });
        Promise.all([
          this._authorizationResultCache.set(authorizationResult),
          this.handleAuthorizationResult(authorizationResult)
        ]);
      } catch (e2) {
        this.disconnect();
        throw new WalletDisconnectedError$1(e2 instanceof Error && (e2 === null || e2 === void 0 ? void 0 : e2.message) || "Unknown error", e2);
      }
    });
  }
  disconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._authorizationResultCache.clear();
      this._connecting = false;
      this._connectionGeneration++;
      delete this._authorizationResult;
      delete this._publicKey;
      delete this._selectedAddress;
      this.emit("disconnect");
    });
  }
  transact(callback) {
    var _a3;
    return __awaiter$3(this, void 0, void 0, function* () {
      const walletUriBase = (_a3 = this._authorizationResult) === null || _a3 === void 0 ? void 0 : _a3.wallet_uri_base;
      const config2 = walletUriBase ? { baseUri: walletUriBase } : void 0;
      const remoteConfig = this._hostAuthority ? { remoteHostAuthority: this._hostAuthority } : void 0;
      const currentConnectionGeneration = this._connectionGeneration;
      try {
        return yield transact(callback, Object.assign(Object.assign({}, config2), remoteConfig));
      } catch (e2) {
        if (this._connectionGeneration !== currentConnectionGeneration) {
          yield new Promise(() => {
          });
        }
        if (e2 instanceof Error && e2.name === "SolanaMobileWalletAdapterError" && e2.code === "ERROR_WALLET_NOT_FOUND") {
          yield this._onWalletNotFound(this);
        }
        throw e2;
      }
    });
  }
  assertIsAuthorized() {
    if (!this._authorizationResult || !this._selectedAddress)
      throw new WalletNotConnectedError();
    return {
      authToken: this._authorizationResult.auth_token,
      selectedAddress: this._selectedAddress
    };
  }
  performSignTransactions(transactions) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const { authToken } = this.assertIsAuthorized();
      try {
        return yield this.transact((wallet) => __awaiter$3(this, void 0, void 0, function* () {
          yield this.performReauthorization(wallet, authToken);
          const signedTransactions = yield wallet.signTransactions({
            transactions
          });
          return signedTransactions;
        }));
      } catch (error) {
        throw new WalletSignTransactionError$1(error === null || error === void 0 ? void 0 : error.message, error);
      }
    });
  }
  sendTransaction(transaction2, connection, options) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() => __awaiter$3(this, void 0, void 0, function* () {
        const { authToken } = this.assertIsAuthorized();
        const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;
        try {
          return yield this.transact((wallet) => __awaiter$3(this, void 0, void 0, function* () {
            function getTargetCommitment() {
              let targetCommitment;
              switch (connection.commitment) {
                case "confirmed":
                case "finalized":
                case "processed":
                  targetCommitment = connection.commitment;
                  break;
                default:
                  targetCommitment = "finalized";
              }
              let targetPreflightCommitment;
              switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {
                case "confirmed":
                case "finalized":
                case "processed":
                  targetPreflightCommitment = options.preflightCommitment;
                  break;
                case void 0:
                  targetPreflightCommitment = targetCommitment;
                  break;
                default:
                  targetPreflightCommitment = "finalized";
              }
              const preflightCommitmentScore = targetPreflightCommitment === "finalized" ? 2 : targetPreflightCommitment === "confirmed" ? 1 : 0;
              const targetCommitmentScore = targetCommitment === "finalized" ? 2 : targetCommitment === "confirmed" ? 1 : 0;
              return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;
            }
            const [capabilities, _1, _2] = yield Promise.all([
              wallet.getCapabilities(),
              this.performReauthorization(wallet, authToken),
              isVersionedTransaction(transaction2) ? null : (
                /**
                 * Unlike versioned transactions, legacy `Transaction` objects
                 * may not have an associated `feePayer` or `recentBlockhash`.
                 * This code exists to patch them up in case they are missing.
                 */
                (() => __awaiter$3(this, void 0, void 0, function* () {
                  var _a3;
                  transaction2.feePayer || (transaction2.feePayer = (_a3 = this.publicKey) !== null && _a3 !== void 0 ? _a3 : void 0);
                  if (transaction2.recentBlockhash == null) {
                    const { blockhash } = yield connection.getLatestBlockhash({
                      commitment: getTargetCommitment()
                    });
                    transaction2.recentBlockhash = blockhash;
                  }
                }))()
              )
            ]);
            if (capabilities.supports_sign_and_send_transactions) {
              const signatures = yield wallet.signAndSendTransactions({
                minContextSlot,
                transactions: [transaction2]
              });
              return signatures[0];
            } else {
              const [signedTransaction] = yield wallet.signTransactions({
                transactions: [transaction2]
              });
              if (isVersionedTransaction(signedTransaction)) {
                return yield connection.sendTransaction(signedTransaction);
              } else {
                const serializedTransaction = signedTransaction.serialize();
                return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), { preflightCommitment: getTargetCommitment() }));
              }
            }
          }));
        } catch (error) {
          throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
        }
      }));
    });
  }
  signTransaction(transaction2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() => __awaiter$3(this, void 0, void 0, function* () {
        const [signedTransaction] = yield this.performSignTransactions([transaction2]);
        return signedTransaction;
      }));
    });
  }
  signAllTransactions(transactions) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() => __awaiter$3(this, void 0, void 0, function* () {
        const signedTransactions = yield this.performSignTransactions(transactions);
        return signedTransactions;
      }));
    });
  }
  signMessage(message2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() => __awaiter$3(this, void 0, void 0, function* () {
        const { authToken, selectedAddress } = this.assertIsAuthorized();
        try {
          return yield this.transact((wallet) => __awaiter$3(this, void 0, void 0, function* () {
            yield this.performReauthorization(wallet, authToken);
            const [signedMessage] = yield wallet.signMessages({
              addresses: [selectedAddress],
              payloads: [message2]
            });
            const signature2 = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES$1);
            return signature2;
          }));
        } catch (error) {
          throw new WalletSignMessageError$1(error === null || error === void 0 ? void 0 : error.message, error);
        }
      }));
    });
  }
  signIn(input) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() => __awaiter$3(this, void 0, void 0, function* () {
        var _a3, _b2;
        if (this._readyState !== WalletReadyState$1.Installed && this._readyState !== WalletReadyState$1.Loadable) {
          throw new WalletNotReadyError();
        }
        this._connecting = true;
        try {
          const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), { domain: (_a3 = input === null || input === void 0 ? void 0 : input.domain) !== null && _a3 !== void 0 ? _a3 : window.location.host }));
          if (!authorizationResult.sign_in_result) {
            throw new Error("Sign in failed, no sign in result returned by wallet");
          }
          const signedInAddress = authorizationResult.sign_in_result.address;
          const signedInAccount = Object.assign(Object.assign({}, (_b2 = authorizationResult.accounts.find((acc) => acc.address == signedInAddress)) !== null && _b2 !== void 0 ? _b2 : {
            address: signedInAddress
          }), { publicKey: toUint8Array(signedInAddress) });
          return {
            account: signedInAccount,
            signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),
            signature: toUint8Array(authorizationResult.sign_in_result.signature)
          };
        } catch (e2) {
          throw new WalletConnectionError$1(e2 instanceof Error && e2.message || "Unknown error", e2);
        } finally {
          this._connecting = false;
        }
      }));
    });
  }
}
function createDefaultAddressSelector() {
  return {
    select(addresses) {
      return __awaiter$3(this, void 0, void 0, function* () {
        return addresses[0];
      });
    }
  };
}
const CACHE_KEY = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
function createDefaultAuthorizationResultCache() {
  let storage;
  try {
    storage = window.localStorage;
  } catch (_a3) {
  }
  return {
    clear() {
      return __awaiter$3(this, void 0, void 0, function* () {
        if (!storage) {
          return;
        }
        try {
          storage.removeItem(CACHE_KEY);
        } catch (_a3) {
        }
      });
    },
    get() {
      return __awaiter$3(this, void 0, void 0, function* () {
        if (!storage) {
          return;
        }
        try {
          return JSON.parse(storage.getItem(CACHE_KEY)) || void 0;
        } catch (_a3) {
        }
      });
    },
    set(authorizationResult) {
      return __awaiter$3(this, void 0, void 0, function* () {
        if (!storage) {
          return;
        }
        try {
          storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));
        } catch (_a3) {
        }
      });
    }
  };
}
function defaultWalletNotFoundHandler(mobileWalletAdapter) {
  return __awaiter$3(this, void 0, void 0, function* () {
    if (typeof window !== "undefined") {
      window.location.assign(mobileWalletAdapter.url);
    }
  });
}
function createDefaultWalletNotFoundHandler() {
  return defaultWalletNotFoundHandler;
}
globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
function arraysEqual(a, b2) {
  if (a === b2)
    return true;
  const length = a.length;
  if (length !== b2.length)
    return false;
  for (let i = 0; i < length; i++) {
    if (a[i] !== b2[i])
      return false;
  }
  return true;
}
var __classPrivateFieldSet$3 = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$3 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;
class StandardWalletAdapter extends BaseWalletAdapter {
  constructor({ wallet }) {
    super();
    _StandardWalletAdapter_instances.add(this);
    _StandardWalletAdapter_account.set(this, void 0);
    _StandardWalletAdapter_publicKey.set(this, void 0);
    _StandardWalletAdapter_connecting.set(this, void 0);
    _StandardWalletAdapter_disconnecting.set(this, void 0);
    _StandardWalletAdapter_off.set(this, void 0);
    _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0);
    _StandardWalletAdapter_wallet.set(this, void 0);
    _StandardWalletAdapter_readyState.set(this, typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState$1.Unsupported : WalletReadyState$1.Installed);
    _StandardWalletAdapter_changed.set(this, (properties) => {
      if ("accounts" in properties) {
        const account = __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").accounts[0];
        if (__classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f") && !__classPrivateFieldGet$3(this, _StandardWalletAdapter_disconnecting, "f") && account !== __classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f")) {
          if (account) {
            __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, account);
          } else {
            this.emit("error", new WalletDisconnectedError$1());
            __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_disconnected).call(this);
          }
        }
      }
      if ("features" in properties) {
        __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this);
      }
    });
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_wallet, wallet, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_account, null, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_publicKey, null, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_connecting, false, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_disconnecting, false, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_off, __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[StandardEvents].on("change", __classPrivateFieldGet$3(this, _StandardWalletAdapter_changed, "f")), "f");
    __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this);
  }
  get name() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").name;
  }
  get url() {
    return "https://github.com/solana-labs/wallet-standard";
  }
  get icon() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").icon;
  }
  get readyState() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_readyState, "f");
  }
  get publicKey() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_publicKey, "f");
  }
  get connecting() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_connecting, "f");
  }
  get supportedTransactionVersions() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_supportedTransactionVersions, "f");
  }
  get wallet() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f");
  }
  get standard() {
    return true;
  }
  destroy() {
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_account, null, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_publicKey, null, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_connecting, false, "f");
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_disconnecting, false, "f");
    const off = __classPrivateFieldGet$3(this, _StandardWalletAdapter_off, "f");
    if (off) {
      __classPrivateFieldSet$3(this, _StandardWalletAdapter_off, null, "f");
      off();
    }
  }
  async autoConnect() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connect).call(this, { silent: true });
  }
  async connect() {
    return __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connect).call(this);
  }
  async disconnect() {
    if (StandardDisconnect in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features) {
      try {
        __classPrivateFieldSet$3(this, _StandardWalletAdapter_disconnecting, true, "f");
        await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[StandardDisconnect].disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error == null ? void 0 : error.message, error));
      } finally {
        __classPrivateFieldSet$3(this, _StandardWalletAdapter_disconnecting, false, "f");
      }
    }
    __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_disconnected).call(this);
  }
  async sendTransaction(transaction2, connection, options = {}) {
    try {
      const account = __classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f");
      if (!account)
        throw new WalletNotConnectedError();
      let feature;
      if (SolanaSignAndSendTransaction in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features) {
        if (account.features.includes(SolanaSignAndSendTransaction)) {
          feature = SolanaSignAndSendTransaction;
        } else if (SolanaSignTransaction in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features && account.features.includes(SolanaSignTransaction)) {
          feature = SolanaSignTransaction;
        } else {
          throw new WalletAccountError();
        }
      } else if (SolanaSignTransaction in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features) {
        if (!account.features.includes(SolanaSignTransaction))
          throw new WalletAccountError();
        feature = SolanaSignTransaction;
      } else {
        throw new WalletConfigError();
      }
      const chain = getChainForEndpoint(connection.rpcEndpoint);
      if (!account.chains.includes(chain))
        throw new WalletSendTransactionError();
      try {
        const { signers, ...sendOptions } = options;
        let serializedTransaction;
        if (isVersionedTransaction$1(transaction2)) {
          (signers == null ? void 0 : signers.length) && transaction2.sign(signers);
          serializedTransaction = transaction2.serialize();
        } else {
          transaction2 = await this.prepareTransaction(transaction2, connection, sendOptions);
          (signers == null ? void 0 : signers.length) && transaction2.partialSign(...signers);
          serializedTransaction = new Uint8Array(transaction2.serialize({
            requireAllSignatures: false,
            verifySignatures: false
          }));
        }
        if (feature === SolanaSignAndSendTransaction) {
          const [output2] = await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignAndSendTransaction].signAndSendTransaction({
            account,
            chain,
            transaction: serializedTransaction,
            options: {
              preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),
              skipPreflight: sendOptions.skipPreflight,
              maxRetries: sendOptions.maxRetries,
              minContextSlot: sendOptions.minContextSlot
            }
          });
          return bs58$1.encode(output2.signature);
        } else {
          const [output2] = await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction({
            account,
            chain,
            transaction: serializedTransaction,
            options: {
              preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),
              minContextSlot: sendOptions.minContextSlot
            }
          });
          return await connection.sendRawTransaction(output2.signedTransaction, {
            ...sendOptions,
            preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment)
          });
        }
      } catch (error) {
        if (error instanceof WalletError$1)
          throw error;
        throw new WalletSendTransactionError(error == null ? void 0 : error.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
}
_StandardWalletAdapter_account = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_publicKey = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_connecting = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_disconnecting = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_off = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_supportedTransactionVersions = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_wallet = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_readyState = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_changed = /* @__PURE__ */ new WeakMap(), _StandardWalletAdapter_instances = /* @__PURE__ */ new WeakSet(), _StandardWalletAdapter_connect = async function _StandardWalletAdapter_connect2(input) {
  try {
    if (this.connected || this.connecting)
      return;
    if (__classPrivateFieldGet$3(this, _StandardWalletAdapter_readyState, "f") !== WalletReadyState$1.Installed)
      throw new WalletNotReadyError();
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_connecting, true, "f");
    if (!__classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").accounts.length) {
      try {
        await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[StandardConnect].connect(input);
      } catch (error) {
        throw new WalletConnectionError$1(error == null ? void 0 : error.message, error);
      }
    }
    const account = __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").accounts[0];
    if (!account)
      throw new WalletAccountError();
    __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, account);
  } catch (error) {
    this.emit("error", error);
    throw error;
  } finally {
    __classPrivateFieldSet$3(this, _StandardWalletAdapter_connecting, false, "f");
  }
}, _StandardWalletAdapter_connected = function _StandardWalletAdapter_connected2(account) {
  let publicKey2;
  try {
    publicKey2 = new PublicKey(account.address);
  } catch (error) {
    throw new WalletPublicKeyError(error == null ? void 0 : error.message, error);
  }
  __classPrivateFieldSet$3(this, _StandardWalletAdapter_account, account, "f");
  __classPrivateFieldSet$3(this, _StandardWalletAdapter_publicKey, publicKey2, "f");
  __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this);
  this.emit("connect", publicKey2);
}, _StandardWalletAdapter_disconnected = function _StandardWalletAdapter_disconnected2() {
  __classPrivateFieldSet$3(this, _StandardWalletAdapter_account, null, "f");
  __classPrivateFieldSet$3(this, _StandardWalletAdapter_publicKey, null, "f");
  __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this);
  this.emit("disconnect");
}, _StandardWalletAdapter_reset = function _StandardWalletAdapter_reset2() {
  var _a3, _b2;
  const supportedTransactionVersions = SolanaSignAndSendTransaction in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features ? __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignAndSendTransaction].supportedTransactionVersions : __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].supportedTransactionVersions;
  __classPrivateFieldSet$3(this, _StandardWalletAdapter_supportedTransactionVersions, arraysEqual(supportedTransactionVersions, ["legacy"]) ? null : new Set(supportedTransactionVersions), "f");
  if (SolanaSignTransaction in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features && ((_a3 = __classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f")) == null ? void 0 : _a3.features.includes(SolanaSignTransaction))) {
    this.signTransaction = __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signTransaction);
    this.signAllTransactions = __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signAllTransactions);
  } else {
    delete this.signTransaction;
    delete this.signAllTransactions;
  }
  if (SolanaSignMessage in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features && ((_b2 = __classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f")) == null ? void 0 : _b2.features.includes(SolanaSignMessage))) {
    this.signMessage = __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signMessage);
  } else {
    delete this.signMessage;
  }
  if (SolanaSignIn in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features) {
    this.signIn = __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signIn);
  } else {
    delete this.signIn;
  }
}, _StandardWalletAdapter_signTransaction = async function _StandardWalletAdapter_signTransaction2(transaction2) {
  try {
    const account = __classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f");
    if (!account)
      throw new WalletNotConnectedError();
    if (!(SolanaSignTransaction in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features))
      throw new WalletConfigError();
    if (!account.features.includes(SolanaSignTransaction))
      throw new WalletAccountError();
    try {
      const signedTransactions = await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction({
        account,
        transaction: isVersionedTransaction$1(transaction2) ? transaction2.serialize() : new Uint8Array(transaction2.serialize({
          requireAllSignatures: false,
          verifySignatures: false
        }))
      });
      const serializedTransaction = signedTransactions[0].signedTransaction;
      return isVersionedTransaction$1(transaction2) ? VersionedTransaction.deserialize(serializedTransaction) : Transaction$2.from(serializedTransaction);
    } catch (error) {
      if (error instanceof WalletError$1)
        throw error;
      throw new WalletSignTransactionError$1(error == null ? void 0 : error.message, error);
    }
  } catch (error) {
    this.emit("error", error);
    throw error;
  }
}, _StandardWalletAdapter_signAllTransactions = async function _StandardWalletAdapter_signAllTransactions2(transactions) {
  try {
    const account = __classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f");
    if (!account)
      throw new WalletNotConnectedError();
    if (!(SolanaSignTransaction in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features))
      throw new WalletConfigError();
    if (!account.features.includes(SolanaSignTransaction))
      throw new WalletAccountError();
    try {
      const signedTransactions = await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction(...transactions.map((transaction2) => ({
        account,
        transaction: isVersionedTransaction$1(transaction2) ? transaction2.serialize() : new Uint8Array(transaction2.serialize({
          requireAllSignatures: false,
          verifySignatures: false
        }))
      })));
      return transactions.map((transaction2, index2) => {
        const signedTransaction = signedTransactions[index2].signedTransaction;
        return isVersionedTransaction$1(transaction2) ? VersionedTransaction.deserialize(signedTransaction) : Transaction$2.from(signedTransaction);
      });
    } catch (error) {
      throw new WalletSignTransactionError$1(error == null ? void 0 : error.message, error);
    }
  } catch (error) {
    this.emit("error", error);
    throw error;
  }
}, _StandardWalletAdapter_signMessage = async function _StandardWalletAdapter_signMessage2(message2) {
  try {
    const account = __classPrivateFieldGet$3(this, _StandardWalletAdapter_account, "f");
    if (!account)
      throw new WalletNotConnectedError();
    if (!(SolanaSignMessage in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features))
      throw new WalletConfigError();
    if (!account.features.includes(SolanaSignMessage))
      throw new WalletAccountError();
    try {
      const signedMessages = await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignMessage].signMessage({
        account,
        message: message2
      });
      return signedMessages[0].signature;
    } catch (error) {
      throw new WalletSignMessageError$1(error == null ? void 0 : error.message, error);
    }
  } catch (error) {
    this.emit("error", error);
    throw error;
  }
}, _StandardWalletAdapter_signIn = async function _StandardWalletAdapter_signIn2(input = {}) {
  try {
    if (!(SolanaSignIn in __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features))
      throw new WalletConfigError();
    let output2;
    try {
      [output2] = await __classPrivateFieldGet$3(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignIn].signIn(input);
    } catch (error) {
      throw new WalletSignInError(error == null ? void 0 : error.message, error);
    }
    if (!output2)
      throw new WalletSignInError();
    __classPrivateFieldGet$3(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, output2.account);
    return output2;
  } catch (error) {
    this.emit("error", error);
    throw error;
  }
};
const isWalletAdapterCompatibleWallet = isWalletAdapterCompatibleStandardWallet;
var __classPrivateFieldGet$2 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AppReadyEvent_detail;
let wallets = void 0;
const registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.add(wallet);
}
function removeRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.delete(wallet);
}
const listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get, on });
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  var _a3;
  wallets2 = wallets2.filter((wallet) => !registeredWalletsSet.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => addRegisteredWallet(wallet));
  (_a3 = listeners["register"]) == null ? void 0 : _a3.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    var _a4;
    wallets2.forEach((wallet) => removeRegisteredWallet(wallet));
    (_a4 = listeners["unregister"]) == null ? void 0 : _a4.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
let cachedWalletsArray;
function get() {
  if (!cachedWalletsArray) {
    cachedWalletsArray = [...registeredWalletsSet];
  }
  return cachedWalletsArray;
}
function on(event, listener) {
  var _a3;
  ((_a3 = listeners[event]) == null ? void 0 : _a3.push(listener)) || (listeners[event] = [listener]);
  return function off() {
    var _a4;
    listeners[event] = (_a4 = listeners[event]) == null ? void 0 : _a4.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
class AppReadyEvent extends Event {
  get detail() {
    return __classPrivateFieldGet$2(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet$2(this, _AppReadyEvent_detail, api, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();
function DEPRECATED_getWallets() {
  if (wallets)
    return wallets;
  wallets = getWallets();
  if (typeof window === "undefined")
    return wallets;
  const callbacks = window.navigator.wallets || [];
  if (!Array.isArray(callbacks)) {
    console.error("window.navigator.wallets is not an array");
    return wallets;
  }
  const { register: register2 } = wallets;
  const push = (...callbacks2) => callbacks2.forEach((callback) => guard(() => callback({ register: register2 })));
  try {
    Object.defineProperty(window.navigator, "wallets", {
      value: Object.freeze({ push })
    });
  } catch (error) {
    console.error("window.navigator.wallets could not be set");
    return wallets;
  }
  push(...callbacks);
  return wallets;
}
function useStandardWalletAdapters(adapters2) {
  const warnings = useConstant(() => /* @__PURE__ */ new Set());
  const { get: get2, on: on2 } = useConstant(() => DEPRECATED_getWallets());
  const [standardAdapters, setStandardAdapters] = reactExports.useState(() => wrapWalletsWithAdapters(get2()));
  reactExports.useEffect(() => {
    const listeners2 = [
      on2("register", (...wallets2) => setStandardAdapters((standardAdapters2) => [...standardAdapters2, ...wrapWalletsWithAdapters(wallets2)])),
      on2("unregister", (...wallets2) => setStandardAdapters((standardAdapters2) => standardAdapters2.filter((standardAdapter) => wallets2.some((wallet) => wallet === standardAdapter.wallet))))
    ];
    return () => listeners2.forEach((off) => off());
  }, [on2]);
  const prevStandardAdapters = usePrevious(standardAdapters);
  reactExports.useEffect(() => {
    if (!prevStandardAdapters)
      return;
    const currentAdapters = new Set(standardAdapters);
    const removedAdapters = new Set(prevStandardAdapters.filter((previousAdapter) => !currentAdapters.has(previousAdapter)));
    removedAdapters.forEach((adapter) => adapter.destroy());
  }, [prevStandardAdapters, standardAdapters]);
  reactExports.useEffect(() => () => standardAdapters.forEach((adapter) => adapter.destroy()), []);
  return reactExports.useMemo(() => [
    ...standardAdapters,
    ...adapters2.filter(({ name }) => {
      if (standardAdapters.some((standardAdapter) => standardAdapter.name === name)) {
        if (!warnings.has(name)) {
          warnings.add(name);
          console.warn(`${name} was registered as a Standard Wallet. The Wallet Adapter for ${name} can be removed from your app.`);
        }
        return false;
      }
      return true;
    })
  ], [standardAdapters, adapters2, warnings]);
}
function useConstant(fn) {
  const ref = reactExports.useRef();
  if (!ref.current) {
    ref.current = { value: fn() };
  }
  return ref.current.value;
}
function usePrevious(state) {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = state;
  });
  return ref.current;
}
function wrapWalletsWithAdapters(wallets2) {
  return wallets2.filter(isWalletAdapterCompatibleWallet).map((wallet) => new StandardWalletAdapter({ wallet }));
}
var Environment;
(function(Environment2) {
  Environment2[Environment2["DESKTOP_WEB"] = 0] = "DESKTOP_WEB";
  Environment2[Environment2["MOBILE_WEB"] = 1] = "MOBILE_WEB";
})(Environment || (Environment = {}));
function isWebView(userAgentString) {
  return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(userAgentString);
}
function getEnvironment({ adapters: adapters2, userAgentString }) {
  if (adapters2.some((adapter) => adapter.name !== SolanaMobileWalletAdapterWalletName && adapter.readyState === WalletReadyState$1.Installed)) {
    return Environment.DESKTOP_WEB;
  }
  if (userAgentString && // Step 1: Check whether we're on a platform that supports MWA at all.
  /android/i.test(userAgentString) && // Step 2: Determine that we are *not* running in a WebView.
  !isWebView(userAgentString)) {
    return Environment.MOBILE_WEB;
  } else {
    return Environment.DESKTOP_WEB;
  }
}
function getInferredClusterFromEndpoint(endpoint) {
  if (!endpoint) {
    return "mainnet-beta";
  }
  if (/devnet/i.test(endpoint)) {
    return "devnet";
  } else if (/testnet/i.test(endpoint)) {
    return "testnet";
  } else {
    return "mainnet-beta";
  }
}
function WalletProviderBase({ children, wallets: adapters2, adapter, isUnloadingRef, onAutoConnectRequest, onConnectError, onError, onSelectWallet }) {
  const isConnectingRef = reactExports.useRef(false);
  const [connecting, setConnecting] = reactExports.useState(false);
  const isDisconnectingRef = reactExports.useRef(false);
  const [disconnecting, setDisconnecting] = reactExports.useState(false);
  const [publicKey2, setPublicKey] = reactExports.useState(() => (adapter == null ? void 0 : adapter.publicKey) ?? null);
  const [connected, setConnected] = reactExports.useState(() => (adapter == null ? void 0 : adapter.connected) ?? false);
  const onErrorRef = reactExports.useRef(onError);
  reactExports.useEffect(() => {
    onErrorRef.current = onError;
    return () => {
      onErrorRef.current = void 0;
    };
  }, [onError]);
  const handleErrorRef = reactExports.useRef((error, adapter2) => {
    if (!isUnloadingRef.current) {
      if (onErrorRef.current) {
        onErrorRef.current(error, adapter2);
      } else {
        console.error(error, adapter2);
        if (error instanceof WalletNotReadyError && typeof window !== "undefined" && adapter2) {
          window.open(adapter2.url, "_blank");
        }
      }
    }
    return error;
  });
  const [wallets2, setWallets] = reactExports.useState(() => adapters2.map((adapter2) => ({
    adapter: adapter2,
    readyState: adapter2.readyState
  })).filter(({ readyState }) => readyState !== WalletReadyState$1.Unsupported));
  reactExports.useEffect(() => {
    setWallets((wallets3) => adapters2.map((adapter2, index2) => {
      const wallet2 = wallets3[index2];
      return wallet2 && wallet2.adapter === adapter2 && wallet2.readyState === adapter2.readyState ? wallet2 : {
        adapter: adapter2,
        readyState: adapter2.readyState
      };
    }).filter(({ readyState }) => readyState !== WalletReadyState$1.Unsupported));
    function handleReadyStateChange(readyState) {
      setWallets((prevWallets) => {
        const index2 = prevWallets.findIndex(({ adapter: adapter3 }) => adapter3 === this);
        if (index2 === -1)
          return prevWallets;
        const { adapter: adapter2 } = prevWallets[index2];
        return [
          ...prevWallets.slice(0, index2),
          { adapter: adapter2, readyState },
          ...prevWallets.slice(index2 + 1)
        ].filter(({ readyState: readyState2 }) => readyState2 !== WalletReadyState$1.Unsupported);
      });
    }
    adapters2.forEach((adapter2) => adapter2.on("readyStateChange", handleReadyStateChange, adapter2));
    return () => {
      adapters2.forEach((adapter2) => adapter2.off("readyStateChange", handleReadyStateChange, adapter2));
    };
  }, [adapter, adapters2]);
  const wallet = reactExports.useMemo(() => wallets2.find((wallet2) => wallet2.adapter === adapter) ?? null, [adapter, wallets2]);
  reactExports.useEffect(() => {
    if (!adapter)
      return;
    const handleConnect2 = (publicKey3) => {
      setPublicKey(publicKey3);
      isConnectingRef.current = false;
      setConnecting(false);
      setConnected(true);
      isDisconnectingRef.current = false;
      setDisconnecting(false);
    };
    const handleDisconnect2 = () => {
      if (isUnloadingRef.current)
        return;
      setPublicKey(null);
      isConnectingRef.current = false;
      setConnecting(false);
      setConnected(false);
      isDisconnectingRef.current = false;
      setDisconnecting(false);
    };
    const handleError = (error) => {
      handleErrorRef.current(error, adapter);
    };
    adapter.on("connect", handleConnect2);
    adapter.on("disconnect", handleDisconnect2);
    adapter.on("error", handleError);
    return () => {
      adapter.off("connect", handleConnect2);
      adapter.off("disconnect", handleDisconnect2);
      adapter.off("error", handleError);
      handleDisconnect2();
    };
  }, [adapter, isUnloadingRef]);
  const didAttemptAutoConnectRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    return () => {
      didAttemptAutoConnectRef.current = false;
    };
  }, [adapter]);
  reactExports.useEffect(() => {
    if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !((wallet == null ? void 0 : wallet.readyState) === WalletReadyState$1.Installed || (wallet == null ? void 0 : wallet.readyState) === WalletReadyState$1.Loadable))
      return;
    isConnectingRef.current = true;
    setConnecting(true);
    didAttemptAutoConnectRef.current = true;
    (async function() {
      try {
        await onAutoConnectRequest();
      } catch {
        onConnectError();
      } finally {
        setConnecting(false);
        isConnectingRef.current = false;
      }
    })();
  }, [connected, onAutoConnectRequest, onConnectError, wallet]);
  const sendTransaction = reactExports.useCallback(async (transaction2, connection, options) => {
    if (!adapter)
      throw handleErrorRef.current(new WalletNotSelectedError$1());
    if (!connected)
      throw handleErrorRef.current(new WalletNotConnectedError(), adapter);
    return await adapter.sendTransaction(transaction2, connection, options);
  }, [adapter, connected]);
  const signTransaction2 = reactExports.useMemo(() => adapter && "signTransaction" in adapter ? async (transaction2) => {
    if (!connected)
      throw handleErrorRef.current(new WalletNotConnectedError(), adapter);
    return await adapter.signTransaction(transaction2);
  } : void 0, [adapter, connected]);
  const signAllTransactions = reactExports.useMemo(() => adapter && "signAllTransactions" in adapter ? async (transactions) => {
    if (!connected)
      throw handleErrorRef.current(new WalletNotConnectedError(), adapter);
    return await adapter.signAllTransactions(transactions);
  } : void 0, [adapter, connected]);
  const signMessage2 = reactExports.useMemo(() => adapter && "signMessage" in adapter ? async (message2) => {
    if (!connected)
      throw handleErrorRef.current(new WalletNotConnectedError(), adapter);
    return await adapter.signMessage(message2);
  } : void 0, [adapter, connected]);
  const signIn = reactExports.useMemo(() => adapter && "signIn" in adapter ? async (input) => {
    return await adapter.signIn(input);
  } : void 0, [adapter]);
  const handleConnect = reactExports.useCallback(async () => {
    if (isConnectingRef.current || isDisconnectingRef.current || (wallet == null ? void 0 : wallet.adapter.connected))
      return;
    if (!wallet)
      throw handleErrorRef.current(new WalletNotSelectedError$1());
    const { adapter: adapter2, readyState } = wallet;
    if (!(readyState === WalletReadyState$1.Installed || readyState === WalletReadyState$1.Loadable))
      throw handleErrorRef.current(new WalletNotReadyError(), adapter2);
    isConnectingRef.current = true;
    setConnecting(true);
    try {
      await adapter2.connect();
    } catch (e2) {
      onConnectError();
      throw e2;
    } finally {
      setConnecting(false);
      isConnectingRef.current = false;
    }
  }, [onConnectError, wallet]);
  const handleDisconnect = reactExports.useCallback(async () => {
    if (isDisconnectingRef.current)
      return;
    if (!adapter)
      return;
    isDisconnectingRef.current = true;
    setDisconnecting(true);
    try {
      await adapter.disconnect();
    } finally {
      setDisconnecting(false);
      isDisconnectingRef.current = false;
    }
  }, [adapter]);
  return React.createElement(WalletContext$1.Provider, { value: {
    autoConnect: !!onAutoConnectRequest,
    wallets: wallets2,
    wallet,
    publicKey: publicKey2,
    connected,
    connecting,
    disconnecting,
    select: onSelectWallet,
    connect: handleConnect,
    disconnect: handleDisconnect,
    sendTransaction,
    signTransaction: signTransaction2,
    signAllTransactions,
    signMessage: signMessage2,
    signIn
  } }, children);
}
let _userAgent;
function getUserAgent() {
  var _a3;
  if (_userAgent === void 0) {
    _userAgent = ((_a3 = globalThis.navigator) == null ? void 0 : _a3.userAgent) ?? null;
  }
  return _userAgent;
}
function getIsMobile(adapters2) {
  const userAgentString = getUserAgent();
  return getEnvironment({ adapters: adapters2, userAgentString }) === Environment.MOBILE_WEB;
}
function getUriForAppIdentity() {
  const location2 = globalThis.location;
  if (!location2)
    return;
  return `${location2.protocol}//${location2.host}`;
}
function WalletProvider$1({ children, wallets: adapters2, autoConnect, localStorageKey = "walletName", onError }) {
  const { connection } = useConnection();
  const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters2);
  const mobileWalletAdapter = reactExports.useMemo(() => {
    if (!getIsMobile(adaptersWithStandardAdapters)) {
      return null;
    }
    const existingMobileWalletAdapter = adaptersWithStandardAdapters.find((adapter2) => adapter2.name === SolanaMobileWalletAdapterWalletName);
    if (existingMobileWalletAdapter) {
      return existingMobileWalletAdapter;
    }
    return new SolanaMobileWalletAdapter({
      addressSelector: createDefaultAddressSelector(),
      appIdentity: {
        uri: getUriForAppIdentity()
      },
      authorizationResultCache: createDefaultAuthorizationResultCache(),
      cluster: getInferredClusterFromEndpoint(connection == null ? void 0 : connection.rpcEndpoint),
      onWalletNotFound: createDefaultWalletNotFoundHandler()
    });
  }, [adaptersWithStandardAdapters, connection == null ? void 0 : connection.rpcEndpoint]);
  const adaptersWithMobileWalletAdapter = reactExports.useMemo(() => {
    if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {
      return adaptersWithStandardAdapters;
    }
    return [mobileWalletAdapter, ...adaptersWithStandardAdapters];
  }, [adaptersWithStandardAdapters, mobileWalletAdapter]);
  const [walletName, setWalletName] = useLocalStorage$1(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null);
  const adapter = reactExports.useMemo(() => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null, [adaptersWithMobileWalletAdapter, walletName]);
  const changeWallet = reactExports.useCallback((nextWalletName) => {
    if (walletName === nextWalletName)
      return;
    if (adapter && // Selecting a wallet other than the mobile wallet adapter is not
    // sufficient reason to call `disconnect` on the mobile wallet adapter.
    // Calling `disconnect` on the mobile wallet adapter causes the entire
    // authorization store to be wiped.
    adapter.name !== SolanaMobileWalletAdapterWalletName) {
      adapter.disconnect();
    }
    setWalletName(nextWalletName);
  }, [adapter, setWalletName, walletName]);
  reactExports.useEffect(() => {
    if (!adapter)
      return;
    function handleDisconnect() {
      if (isUnloadingRef.current)
        return;
      if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters))
        return;
      setWalletName(null);
    }
    adapter.on("disconnect", handleDisconnect);
    return () => {
      adapter.off("disconnect", handleDisconnect);
    };
  }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);
  const hasUserSelectedAWallet = reactExports.useRef(false);
  const handleAutoConnectRequest = reactExports.useMemo(() => {
    if (!autoConnect || !adapter)
      return;
    return async () => {
      if (autoConnect === true || await autoConnect(adapter)) {
        if (hasUserSelectedAWallet.current) {
          await adapter.connect();
        } else {
          await adapter.autoConnect();
        }
      }
    };
  }, [autoConnect, adapter]);
  const isUnloadingRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {
      isUnloadingRef.current = false;
      return;
    }
    function handleBeforeUnload() {
      isUnloadingRef.current = true;
    }
    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [adaptersWithStandardAdapters, walletName]);
  const handleConnectError = reactExports.useCallback(() => {
    if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {
      changeWallet(null);
    }
  }, [adapter, changeWallet]);
  const selectWallet = reactExports.useCallback((walletName2) => {
    hasUserSelectedAWallet.current = true;
    changeWallet(walletName2);
  }, [changeWallet]);
  return React.createElement(WalletProviderBase, { wallets: adaptersWithMobileWalletAdapter, adapter, isUnloadingRef, onAutoConnectRequest: handleAutoConnectRequest, onConnectError: handleConnectError, onError, onSelectWallet: selectWallet }, children);
}
var WalletReadyState;
(function(WalletReadyState2) {
  WalletReadyState2["Loading"] = "Loading";
  WalletReadyState2["NotFound"] = "NotFound";
  WalletReadyState2["Found"] = "Found";
})(WalletReadyState || (WalletReadyState = {}));
var AdapterState;
(function(AdapterState2) {
  AdapterState2["Loading"] = "Loading";
  AdapterState2["NotFound"] = "NotFound";
  AdapterState2["Disconnect"] = "Disconnected";
  AdapterState2["Connected"] = "Connected";
})(AdapterState || (AdapterState = {}));
class Adapter extends EventEmitter$2 {
  get connected() {
    return this.state === AdapterState.Connected;
  }
  /**
   * Some wallets such as TronLink don't support disconnect() method.
   */
  disconnect() {
    console.info("The current adapter doesn't support disconnect by DApp.");
    return Promise.resolve();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  multiSign(...args) {
    return Promise.reject("The current wallet doesn't support multiSign.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  switchChain(_chainId2) {
    return Promise.reject("The current wallet doesn't support switch chain.");
  }
}
class WalletError2 extends Error {
  constructor(message2, error) {
    super(message2);
    this.error = error;
  }
}
class WalletNotFoundError extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletNotFoundError";
    this.message = "The wallet is not found.";
  }
}
class WalletNotSelectedError2 extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
    this.message = "No wallet is selected. Please select a wallet.";
  }
}
class WalletDisconnectedError2 extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectedError";
    this.message = "The wallet is disconnected. Please connect first.";
  }
}
class WalletConnectionError2 extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
}
class WalletSignMessageError2 extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
}
class WalletSignTransactionError2 extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
}
class WalletSwitchChainError extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletSwitchChainError";
  }
}
class WalletGetNetworkError extends WalletError2 {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
}
const _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
class Base64 {
  encode(input) {
    let output2 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2))
        enc3 = enc4 = 64;
      else if (isNaN(chr3))
        enc4 = 64;
      output2 = output2 + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
    }
    return output2;
  }
  encodeIgnoreUtf8(inputBytes) {
    let output2 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    while (i < inputBytes.length) {
      chr1 = inputBytes[i++];
      chr2 = inputBytes[i++];
      chr3 = inputBytes[i++];
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2))
        enc3 = enc4 = 64;
      else if (isNaN(chr3))
        enc4 = 64;
      output2 = output2 + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
    }
    return output2;
  }
  decode(input) {
    let output2 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output2 = output2 + String.fromCharCode(chr1);
      if (enc3 != 64)
        output2 = output2 + String.fromCharCode(chr2);
      if (enc4 != 64)
        output2 = output2 + String.fromCharCode(chr3);
    }
    return this._utf8_decode(output2);
  }
  decodeToByteArray(input) {
    let output2 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output2 = output2 + String.fromCharCode(chr1);
      if (enc3 != 64)
        output2 = output2 + String.fromCharCode(chr2);
      if (enc4 != 64)
        output2 = output2 + String.fromCharCode(chr3);
    }
    return this._out2ByteArray(output2);
  }
  _out2ByteArray(utftext) {
    const byteArray = new Array(utftext.length);
    let i = 0;
    let c = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      byteArray[i] = c;
      i++;
    }
    return byteArray;
  }
  _utf8_encode(string2) {
    string2 = string2.replace(/\r\n/g, "\n");
    let utftext = "";
    for (let n2 = 0; n2 < string2.length; n2++) {
      const c = string2.charCodeAt(n2);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  }
  _utf8_decode(utftext) {
    let string2 = "";
    let i = 0;
    let c = 0;
    let c2 = 0;
    let c3 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string2 += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string2 += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string2 += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string2;
  }
}
function byte2hexStr(byte2) {
  if (byte2 < 0 || byte2 > 255)
    throw new Error("Input must be a byte");
  const hexByteMap = "0123456789ABCDEF";
  let str = "";
  str += hexByteMap.charAt(byte2 >> 4);
  str += hexByteMap.charAt(byte2 & 15);
  return str;
}
function bytesToString(arr) {
  let str = "";
  for (let i = 0; i < arr.length; i++) {
    const one = arr[i].toString(2);
    const v2 = one.match(/^1+?(?=0)/);
    if (v2 && one.length === 8) {
      const bytesLength = v2[0].length;
      let store = arr[i].toString(2).slice(7 - bytesLength);
      for (let st = 1; st < bytesLength; st++)
        store += arr[st + i].toString(2).slice(2);
      str += String.fromCharCode(parseInt(store, 2));
      i += bytesLength - 1;
    } else {
      str += String.fromCharCode(arr[i]);
    }
  }
  return str;
}
function hextoString(hex) {
  const arr = hex.replace(/^0x/, "").split("");
  let out = "";
  for (let i = 0; i < arr.length / 2; i++) {
    const tmp = `0x${arr[i * 2]}${arr[i * 2 + 1]}`;
    out += String.fromCharCode(parseInt(tmp));
  }
  return out;
}
function byteArray2hexStr(byteArray) {
  let str = "";
  for (let i = 0; i < byteArray.length; i++)
    str += byte2hexStr(byteArray[i]);
  return str;
}
function base64DecodeFromString(string64) {
  return new Base64().decodeToByteArray(string64);
}
function base64EncodeToString(bytes2) {
  const b2 = new Base64();
  const string64 = b2.encodeIgnoreUtf8(bytes2);
  return string64;
}
const bytes$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64DecodeFromString,
  base64EncodeToString,
  byte2hexStr,
  byteArray2hexStr,
  bytesToString,
  hextoString
}, Symbol.toStringTag, { value: "Module" }));
function bin2String(array2) {
  return bytesToString(array2);
}
function arrayEquals(array1, array2, strict = false) {
  if (array1.length != array2.length)
    return false;
  for (let i = 0; i < array1.length; i++) {
    if (strict) {
      if (array1[i] != array2[i])
        return false;
    } else if (JSON.stringify(array1[i]) != JSON.stringify(array2[i]))
      return false;
  }
  return true;
}
function stringToBytes(str) {
  const bytes2 = [];
  const len = str.length;
  let c;
  for (let i = 0; i < len; i++) {
    c = str.charCodeAt(i);
    if (c >= 65536 && c <= 1114111) {
      bytes2.push(c >> 18 & 7 | 240);
      bytes2.push(c >> 12 & 63 | 128);
      bytes2.push(c >> 6 & 63 | 128);
      bytes2.push(c & 63 | 128);
    } else if (c >= 2048 && c <= 65535) {
      bytes2.push(c >> 12 & 15 | 224);
      bytes2.push(c >> 6 & 63 | 128);
      bytes2.push(c & 63 | 128);
    } else if (c >= 128 && c <= 2047) {
      bytes2.push(c >> 6 & 31 | 192);
      bytes2.push(c & 63 | 128);
    } else
      bytes2.push(c & 255);
  }
  return bytes2;
}
function hexChar2byte(c) {
  let d;
  if (c >= "A" && c <= "F")
    d = c.charCodeAt(0) - "A".charCodeAt(0) + 10;
  else if (c >= "a" && c <= "f")
    d = c.charCodeAt(0) - "a".charCodeAt(0) + 10;
  else if (c >= "0" && c <= "9")
    d = c.charCodeAt(0) - "0".charCodeAt(0);
  if (typeof d === "number")
    return d;
  else
    throw new Error("The passed hex char is not a valid hex char");
}
function isHexChar(c) {
  if (c >= "A" && c <= "F" || c >= "a" && c <= "f" || c >= "0" && c <= "9") {
    return 1;
  }
  return 0;
}
function hexStr2byteArray(str, strict = false) {
  let len = str.length;
  if (strict) {
    if (len % 2) {
      str = `0${str}`;
      len++;
    }
  }
  const byteArray = [];
  let d = 0;
  let j = 0;
  let k2 = 0;
  for (let i = 0; i < len; i++) {
    const c = str.charAt(i);
    if (isHexChar(c)) {
      d <<= 4;
      d += hexChar2byte(c);
      j++;
      if (0 === j % 2) {
        byteArray[k2++] = d;
        d = 0;
      }
    } else
      throw new Error("The passed hex char is not a valid hex string");
  }
  return byteArray;
}
function strToDate(str) {
  if (!/^\d{4}-\d{2}-\d{2}( \d{2}-\d{2}-\d{2}|)/.test(str))
    throw new Error("The passed date string is not valid");
  const tempStrs = str.split(" ");
  const dateStrs = tempStrs[0].split("-");
  const year = parseInt(dateStrs[0], 10);
  const month = parseInt(dateStrs[1], 10) - 1;
  const day = parseInt(dateStrs[2], 10);
  if (tempStrs.length > 1) {
    const timeStrs = tempStrs[1].split("-");
    const hour = parseInt(timeStrs[0], 10);
    const minute = parseInt(timeStrs[1], 10);
    const second = parseInt(timeStrs[2], 10);
    return new Date(year, month, day, hour, minute, second);
  }
  return new Date(year, month, day);
}
function isNumber$1(c) {
  if (c >= "0" && c <= "9")
    return 1;
  return 0;
}
function getStringType(str) {
  if (null == str)
    return -1;
  if (str.length == 0 || str == "")
    return -1;
  let i = 0;
  if (str.length == 40) {
    for (; i < 40; i++) {
      const c = str.charAt(i);
      if (!isHexChar(c))
        break;
    }
  }
  if (i == 40)
    return 1;
  for (i = 0; i < str.length; i++) {
    const c = str.charAt(i);
    if (!isNumber$1(c))
      break;
  }
  if (i == str.length)
    return 2;
  for (i = 0; i < str.length; i++) {
    const c = str.charAt(i);
    if (c > " ")
      return 3;
  }
  return -1;
}
const code = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayEquals,
  base64DecodeFromString,
  base64EncodeToString,
  bin2String,
  byte2hexStr,
  byteArray2hexStr,
  bytesToString,
  getStringType,
  hexChar2byte,
  hexStr2byteArray,
  hextoString,
  isHexChar,
  isNumber: isNumber$1,
  strToDate,
  stringToBytes
}, Symbol.toStringTag, { value: "Module" }));
var isNumeric$1 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE$1 = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v2, b2) {
    var alphabet, c, caseChanged, e2, i, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber2))
      return new BigNumber2(v2, b2);
    if (b2 == null) {
      if (v2 && v2._isBigNumber === true) {
        x2.s = v2.s;
        if (!v2.c || v2.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v2.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v2.e;
          x2.c = v2.c.slice();
        }
        return;
      }
      if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
        x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
        if (v2 === ~~v2) {
          for (e2 = 0, i = v2; i >= 10; i /= 10, e2++)
            ;
          if (e2 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e2;
            x2.c = [v2];
          }
          return;
        }
        str = String(v2);
      } else {
        if (!isNumeric$1.test(str = String(v2)))
          return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e2 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e2 < 0)
          e2 = i;
        e2 += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e2 < 0) {
        e2 = str.length;
      }
    } else {
      intCheck(b2, 2, ALPHABET2.length, "Base");
      if (b2 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber2(v2);
        return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v2);
      if (isNum = typeof v2 == "number") {
        if (v2 * 0 != 0)
          return parseNumeric(x2, str, isNum, b2);
        x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v2);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET2.slice(0, b2);
      e2 = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e2) {
              e2 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e2 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v2), isNum, b2);
        }
      }
      isNum = false;
      str = convertBase(str, b2, 10, x2.s);
      if ((e2 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e2 = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
        throw Error(tooManyDigits + x2.s * v2);
      }
      if ((e2 = e2 - i - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e2 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e2;
        x2.c = [];
        i = (e2 + 1) % LOG_BASE;
        if (e2 < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x2.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x2.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p2, v2;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          DECIMAL_PLACES = v2;
        }
        if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 8, p2);
          ROUNDING_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, 0, p2);
            intCheck(v2[1], 0, MAX, p2);
            TO_EXP_NEG = v2[0];
            TO_EXP_POS = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "RANGE")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, -1, p2);
            intCheck(v2[1], 1, MAX, p2);
            MIN_EXP = v2[0];
            MAX_EXP = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            if (v2) {
              MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
            } else {
              throw Error(bignumberError + p2 + " cannot be zero: " + v2);
            }
          }
        }
        if (obj.hasOwnProperty(p2 = "CRYPTO")) {
          v2 = obj[p2];
          if (v2 === !!v2) {
            if (v2) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v2;
              } else {
                CRYPTO = !v2;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v2;
            }
          } else {
            throw Error(bignumberError + p2 + " not true or false: " + v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 9, p2);
          MODULO_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          POW_PRECISION = v2;
        }
        if (obj.hasOwnProperty(p2 = "FORMAT")) {
          v2 = obj[p2];
          if (typeof v2 == "object")
            FORMAT = v2;
          else
            throw Error(bignumberError + p2 + " not an object: " + v2);
        }
        if (obj.hasOwnProperty(p2 = "ALPHABET")) {
          v2 = obj[p2];
          if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
            alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
            ALPHABET2 = v2;
          } else {
            throw Error(bignumberError + p2 + " invalid: " + v2);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET: ALPHABET2
    };
  };
  BigNumber2.isBigNumber = function(v2) {
    if (!v2 || v2._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n2, c = v2.c, e2 = v2.e, s = v2.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
          if (c[0] === 0) {
            if (e2 === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e2 + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n2 = c[i];
              if (n2 < 0 || n2 >= BASE$1 || n2 !== mathfloor(n2))
                break out;
            }
            if (n2 !== 0)
              return true;
          }
        }
      } else if (c === null && e2 === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v2);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b2, e2, k2, v2, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i < k2; ) {
            v2 = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v2 >= 9e15) {
              b2 = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b2[0];
              a[i + 1] = b2[1];
            } else {
              c.push(v2 % 1e14);
              i += 2;
            }
          }
          i = k2 / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k2 *= 7);
          for (; i < k2; ) {
            v2 = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v2 >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v2 % 1e14);
              i += 7;
            }
          }
          i = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k2; ) {
          v2 = random53bitInt();
          if (v2 < 9e15)
            c[i++] = v2 % 1e14;
        }
      }
      k2 = c[--i];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v2 = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k2 / v2) * v2;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e2 = 0];
      } else {
        for (e2 = -1; c[0] === 0; c.splice(0, 1), e2 -= LOG_BASE)
          ;
        for (i = 1, v2 = c[0]; v2 >= 10; v2 /= 10, i++)
          ;
        if (i < LOG_BASE)
          e2 -= LOG_BASE - i;
      }
      rand.e = e2;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal2 = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d, e2, k2, r2, x2, xc2, y2, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y2 = new BigNumber2(baseIn);
        x2 = y2.pow(str.length - i);
        POW_PRECISION = k2;
        y2.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal2
        );
        y2.e = y2.c.length;
      }
      xc2 = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET2, decimal2) : (alphabet = decimal2, ALPHABET2));
      e2 = k2 = xc2.length;
      for (; xc2[--k2] == 0; xc2.pop())
        ;
      if (!xc2[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e2;
      } else {
        x2.c = xc2;
        x2.e = e2;
        x2.s = sign2;
        x2 = div(x2, y2, dp, rm, baseOut);
        xc2 = x2.c;
        r2 = x2.r;
        e2 = x2.e;
      }
      d = e2 + dp + 1;
      i = xc2[d];
      k2 = baseOut / 2;
      r2 = r2 || d < 0 || xc2[d + 1] != null;
      r2 = rm < 4 ? (i != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i > k2 || i == k2 && (rm == 4 || r2 || rm == 6 && xc2[d - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d < 1 || !xc2[0]) {
        str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc2.length = d;
        if (r2) {
          for (--baseOut; ++xc2[--d] > baseOut; ) {
            xc2[d] = 0;
            if (!d) {
              ++e2;
              xc2 = [1].concat(xc2);
            }
          }
        }
        for (k2 = xc2.length; !xc2[--k2]; )
          ;
        for (i = 0, str = ""; i <= k2; str += alphabet.charAt(xc2[i++]))
          ;
        str = toFixedPoint(str, e2, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x2, k2, base2) {
      var m2, temp, xlo, xhi, carry = 0, i = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i--; ) {
        xlo = x2[i] % SQRT_BASE;
        xhi = x2[i] / SQRT_BASE | 0;
        m2 = khi * xlo + xhi * klo;
        temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base2 | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
        x2[i] = temp % base2;
      }
      if (carry)
        x2 = [carry].concat(x2);
      return x2;
    }
    function compare2(a, b2, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b2[i]) {
            cmp = a[i] > b2[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b2, aL, base2) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b2[aL] ? 1 : 0;
        a[aL] = i * base2 + a[aL] - b2[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x2, y2, dp, rm, base2) {
      var cmp, e2, i, more, n2, prod, prodL, q2, qc2, rem, remL, rem0, xi2, xL, yc0, yL, yz, s = x2.s == y2.s ? 1 : -1, xc2 = x2.c, yc2 = y2.c;
      if (!xc2 || !xc2[0] || !yc2 || !yc2[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y2.s || (xc2 ? yc2 && xc2[0] == yc2[0] : !yc2) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc2 && xc2[0] == 0 || !yc2 ? s * 0 : s / 0
          )
        );
      }
      q2 = new BigNumber2(s);
      qc2 = q2.c = [];
      e2 = x2.e - y2.e;
      s = dp + e2 + 1;
      if (!base2) {
        base2 = BASE$1;
        e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc2[i] == (xc2[i] || 0); i++)
        ;
      if (yc2[i] > (xc2[i] || 0))
        e2--;
      if (s < 0) {
        qc2.push(1);
        more = true;
      } else {
        xL = xc2.length;
        yL = yc2.length;
        i = 0;
        s += 2;
        n2 = mathfloor(base2 / (yc2[0] + 1));
        if (n2 > 1) {
          yc2 = multiply(yc2, n2, base2);
          xc2 = multiply(xc2, n2, base2);
          yL = yc2.length;
          xL = xc2.length;
        }
        xi2 = yL;
        rem = xc2.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc2.slice();
        yz = [0].concat(yz);
        yc0 = yc2[0];
        if (yc2[1] >= base2 / 2)
          yc0++;
        do {
          n2 = 0;
          cmp = compare2(yc2, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base2 + (rem[1] || 0);
            n2 = mathfloor(rem0 / yc0);
            if (n2 > 1) {
              if (n2 >= base2)
                n2 = base2 - 1;
              prod = multiply(yc2, n2, base2);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n2--;
                subtract(prod, yL < prodL ? yz : yc2, prodL, base2);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n2 == 0) {
                cmp = n2 = 1;
              }
              prod = yc2.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base2);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc2, rem, yL, remL) < 1) {
                n2++;
                subtract(rem, yL < remL ? yz : yc2, remL, base2);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n2++;
            rem = [0];
          }
          qc2[i++] = n2;
          if (rem[0]) {
            rem[remL++] = xc2[xi2] || 0;
          } else {
            rem = [xc2[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc2[0])
          qc2.splice(0, 1);
      }
      if (base2 == BASE$1) {
        for (i = 1, s = qc2[0]; s >= 10; s /= 10, i++)
          ;
        round(q2, dp + (q2.e = i + e2 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q2.e = e2;
        q2.r = +more;
      }
      return q2;
    };
  }();
  function format(n2, i, rm, id2) {
    var c0, e2, ne2, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n2.c)
      return n2.toString();
    c0 = n2.c[0];
    ne2 = n2.e;
    if (i == null) {
      str = coeffToString(n2.c);
      str = id2 == 1 || id2 == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
    } else {
      n2 = round(new BigNumber2(n2), i, rm);
      e2 = n2.e;
      str = coeffToString(n2.c);
      len = str.length;
      if (id2 == 1 || id2 == 2 && (i <= e2 || e2 <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e2);
      } else {
        i -= ne2;
        str = toFixedPoint(str, e2, "0");
        if (e2 + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e2 - len;
          if (i > 0) {
            if (e2 + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n2.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n2) {
    var k2, y2, i = 1, x2 = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y2 = new BigNumber2(args[i]);
      if (!y2.s || (k2 = compare(x2, y2)) === n2 || k2 === 0 && x2.s === n2) {
        x2 = y2;
      }
    }
    return x2;
  }
  function normalise(n2, c, e2) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e2 = i + e2 * LOG_BASE - 1) > MAX_EXP) {
      n2.c = n2.e = null;
    } else if (e2 < MIN_EXP) {
      n2.c = [n2.e = 0];
    } else {
      n2.e = e2;
      n2.c = c;
    }
    return n2;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b2) {
      var base2, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x2.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m2, p1, p2) {
            base2 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b2 || b2 == base2 ? p1 : m2;
          });
          if (b2) {
            base2 = b2;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base2);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  }();
  function round(x2, sd2, rm, r2) {
    var d, i, j, k2, n2, ni2, rd2, xc2 = x2.c, pows10 = POWS_TEN;
    if (xc2) {
      out: {
        for (d = 1, k2 = xc2[0]; k2 >= 10; k2 /= 10, d++)
          ;
        i = sd2 - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd2;
          n2 = xc2[ni2 = 0];
          rd2 = mathfloor(n2 / pows10[d - j - 1] % 10);
        } else {
          ni2 = mathceil((i + 1) / LOG_BASE);
          if (ni2 >= xc2.length) {
            if (r2) {
              for (; xc2.length <= ni2; xc2.push(0))
                ;
              n2 = rd2 = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n2 = k2 = xc2[ni2];
            for (d = 1; k2 >= 10; k2 /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd2 = j < 0 ? 0 : mathfloor(n2 / pows10[d - j - 1] % 10);
          }
        }
        r2 = r2 || sd2 < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc2[ni2 + 1] != null || (j < 0 ? n2 : n2 % pows10[d - j - 1]);
        r2 = rm < 4 ? (rd2 || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n2 / pows10[d - j] : 0 : xc2[ni2 - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd2 < 1 || !xc2[0]) {
          xc2.length = 0;
          if (r2) {
            sd2 -= x2.e + 1;
            xc2[0] = pows10[(LOG_BASE - sd2 % LOG_BASE) % LOG_BASE];
            x2.e = -sd2 || 0;
          } else {
            xc2[0] = x2.e = 0;
          }
          return x2;
        }
        if (i == 0) {
          xc2.length = ni2;
          k2 = 1;
          ni2--;
        } else {
          xc2.length = ni2 + 1;
          k2 = pows10[LOG_BASE - i];
          xc2[ni2] = j > 0 ? mathfloor(n2 / pows10[d - j] % pows10[j]) * k2 : 0;
        }
        if (r2) {
          for (; ; ) {
            if (ni2 == 0) {
              for (i = 1, j = xc2[0]; j >= 10; j /= 10, i++)
                ;
              j = xc2[0] += k2;
              for (k2 = 1; j >= 10; j /= 10, k2++)
                ;
              if (i != k2) {
                x2.e++;
                if (xc2[0] == BASE$1)
                  xc2[0] = 1;
              }
              break;
            } else {
              xc2[ni2] += k2;
              if (xc2[ni2] != BASE$1)
                break;
              xc2[ni2--] = 0;
              k2 = 1;
            }
          }
        }
        for (i = xc2.length; xc2[--i] === 0; xc2.pop())
          ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n2) {
    var str, e2 = n2.e;
    if (e2 === null)
      return n2.toString();
    str = coeffToString(n2.c);
    str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
    return n2.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x2 = new BigNumber2(this);
    if (x2.s < 0)
      x2.s = 1;
    return x2;
  };
  P2.comparedTo = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c, n2, v2, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), dp + x2.e + 1, rm);
    }
    if (!(c = x2.c))
      return null;
    n2 = ((v2 = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v2 = c[v2])
      for (; v2 % 10 == 0; v2 /= 10, n2--)
        ;
    if (n2 < 0)
      n2 = 0;
    return n2;
  };
  P2.dividedBy = P2.div = function(y2, b2) {
    return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
    return div(this, new BigNumber2(y2, b2), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n2, m2) {
    var half, isModExp, i, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
    n2 = new BigNumber2(n2);
    if (n2.c && !n2.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
    }
    if (m2 != null)
      m2 = new BigNumber2(m2);
    nIsBig = n2.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n2.c || !n2.c[0]) {
      y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
      return m2 ? y2.mod(m2) : y2;
    }
    nIsNeg = n2.s < 0;
    if (m2) {
      if (m2.c ? !m2.c[0] : !m2.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
      if (isModExp)
        x2 = x2.mod(m2);
    } else if (n2.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k2 = x2.s < 0 && isOdd(n2) ? -0 : 0;
      if (x2.e > -1)
        k2 = 1 / k2;
      return new BigNumber2(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n2.s = 1;
      nIsOdd = isOdd(n2);
    } else {
      i = Math.abs(+valueOf(n2));
      nIsOdd = i % 2;
    }
    y2 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y2 = y2.times(x2);
        if (!y2.c)
          break;
        if (k2) {
          if (y2.c.length > k2)
            y2.c.length = k2;
        } else if (isModExp) {
          y2 = y2.mod(m2);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n2 = n2.times(half);
        round(n2, n2.e + 1, 1);
        if (n2.e > 14) {
          nIsOdd = isOdd(n2);
        } else {
          i = +valueOf(n2);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x2 = x2.times(x2);
      if (k2) {
        if (x2.c && x2.c.length > k2)
          x2.c.length = k2;
      } else if (isModExp) {
        x2 = x2.mod(m2);
      }
    }
    if (isModExp)
      return y2;
    if (nIsNeg)
      y2 = ONE.div(y2);
    return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
  };
  P2.integerValue = function(rm) {
    var n2 = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n2, n2.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
    return (b2 = compare(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y2, b2) {
    return compare(this, new BigNumber2(y2, b2)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
    return (b2 = compare(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y2, b2) {
    var i, j, t2, xLTy, x2 = this, a = x2.s;
    y2 = new BigNumber2(y2, b2);
    b2 = y2.s;
    if (!a || !b2)
      return new BigNumber2(NaN);
    if (a != b2) {
      y2.s = -b2;
      return x2.plus(y2);
    }
    var xe = x2.e / LOG_BASE, ye = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
    if (!xe || !ye) {
      if (!xc2 || !yc2)
        return xc2 ? (y2.s = -b2, y2) : new BigNumber2(yc2 ? x2 : NaN);
      if (!xc2[0] || !yc2[0]) {
        return yc2[0] ? (y2.s = -b2, y2) : new BigNumber2(xc2[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc2 = xc2.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t2 = xc2;
      } else {
        ye = xe;
        t2 = yc2;
      }
      t2.reverse();
      for (b2 = a; b2--; t2.push(0))
        ;
      t2.reverse();
    } else {
      j = (xLTy = (a = xc2.length) < (b2 = yc2.length)) ? a : b2;
      for (a = b2 = 0; b2 < j; b2++) {
        if (xc2[b2] != yc2[b2]) {
          xLTy = xc2[b2] < yc2[b2];
          break;
        }
      }
    }
    if (xLTy) {
      t2 = xc2;
      xc2 = yc2;
      yc2 = t2;
      y2.s = -y2.s;
    }
    b2 = (j = yc2.length) - (i = xc2.length);
    if (b2 > 0)
      for (; b2--; xc2[i++] = 0)
        ;
    b2 = BASE$1 - 1;
    for (; j > a; ) {
      if (xc2[--j] < yc2[j]) {
        for (i = j; i && !xc2[--i]; xc2[i] = b2)
          ;
        --xc2[i];
        xc2[j] += BASE$1;
      }
      xc2[j] -= yc2[j];
    }
    for (; xc2[0] == 0; xc2.splice(0, 1), --ye)
      ;
    if (!xc2[0]) {
      y2.s = ROUNDING_MODE == 3 ? -1 : 1;
      y2.c = [y2.e = 0];
      return y2;
    }
    return normalise(y2, xc2, ye);
  };
  P2.modulo = P2.mod = function(y2, b2) {
    var q2, s, x2 = this;
    y2 = new BigNumber2(y2, b2);
    if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y2.c || x2.c && !x2.c[0]) {
      return new BigNumber2(x2);
    }
    if (MODULO_MODE == 9) {
      s = y2.s;
      y2.s = 1;
      q2 = div(x2, y2, 0, 3);
      y2.s = s;
      q2.s *= s;
    } else {
      q2 = div(x2, y2, 0, MODULO_MODE);
    }
    y2 = x2.minus(q2.times(y2));
    if (!y2.c[0] && MODULO_MODE == 1)
      y2.s = x2.s;
    return y2;
  };
  P2.multipliedBy = P2.times = function(y2, b2) {
    var c, e2, i, j, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base2, sqrtBase, x2 = this, xc2 = x2.c, yc2 = (y2 = new BigNumber2(y2, b2)).c;
    if (!xc2 || !yc2 || !xc2[0] || !yc2[0]) {
      if (!x2.s || !y2.s || xc2 && !xc2[0] && !yc2 || yc2 && !yc2[0] && !xc2) {
        y2.c = y2.e = y2.s = null;
      } else {
        y2.s *= x2.s;
        if (!xc2 || !yc2) {
          y2.c = y2.e = null;
        } else {
          y2.c = [0];
          y2.e = 0;
        }
      }
      return y2;
    }
    e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
    y2.s *= x2.s;
    xcL = xc2.length;
    ycL = yc2.length;
    if (xcL < ycL) {
      zc2 = xc2;
      xc2 = yc2;
      yc2 = zc2;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc2 = []; i--; zc2.push(0))
      ;
    base2 = BASE$1;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc2[i] % sqrtBase;
      yhi = yc2[i] / sqrtBase | 0;
      for (k2 = xcL, j = i + k2; j > i; ) {
        xlo = xc2[--k2] % sqrtBase;
        xhi = xc2[k2] / sqrtBase | 0;
        m2 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc2[j] + c;
        c = (xlo / base2 | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
        zc2[j--] = xlo % base2;
      }
      zc2[j] = c;
    }
    if (c) {
      ++e2;
    } else {
      zc2.splice(0, 1);
    }
    return normalise(y2, zc2, e2);
  };
  P2.negated = function() {
    var x2 = new BigNumber2(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P2.plus = function(y2, b2) {
    var t2, x2 = this, a = x2.s;
    y2 = new BigNumber2(y2, b2);
    b2 = y2.s;
    if (!a || !b2)
      return new BigNumber2(NaN);
    if (a != b2) {
      y2.s = -b2;
      return x2.minus(y2);
    }
    var xe = x2.e / LOG_BASE, ye = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
    if (!xe || !ye) {
      if (!xc2 || !yc2)
        return new BigNumber2(a / 0);
      if (!xc2[0] || !yc2[0])
        return yc2[0] ? y2 : new BigNumber2(xc2[0] ? x2 : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc2 = xc2.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t2 = yc2;
      } else {
        a = -a;
        t2 = xc2;
      }
      t2.reverse();
      for (; a--; t2.push(0))
        ;
      t2.reverse();
    }
    a = xc2.length;
    b2 = yc2.length;
    if (a - b2 < 0) {
      t2 = yc2;
      yc2 = xc2;
      xc2 = t2;
      b2 = a;
    }
    for (a = 0; b2; ) {
      a = (xc2[--b2] = xc2[b2] + yc2[b2] + a) / BASE$1 | 0;
      xc2[b2] = BASE$1 === xc2[b2] ? 0 : xc2[b2] % BASE$1;
    }
    if (a) {
      xc2 = [a].concat(xc2);
      ++ye;
    }
    return normalise(y2, xc2, ye);
  };
  P2.precision = P2.sd = function(sd2, rm) {
    var c, n2, v2, x2 = this;
    if (sd2 != null && sd2 !== !!sd2) {
      intCheck(sd2, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), sd2, rm);
    }
    if (!(c = x2.c))
      return null;
    v2 = c.length - 1;
    n2 = v2 * LOG_BASE + 1;
    if (v2 = c[v2]) {
      for (; v2 % 10 == 0; v2 /= 10, n2--)
        ;
      for (v2 = c[0]; v2 >= 10; v2 /= 10, n2++)
        ;
    }
    if (sd2 && x2.e + 1 > n2)
      n2 = x2.e + 1;
    return n2;
  };
  P2.shiftedBy = function(k2) {
    intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m2, n2, r2, rep, t2, x2 = this, c = x2.c, s = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x2 : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x2));
    if (s == 0 || s == 1 / 0) {
      n2 = coeffToString(c);
      if ((n2.length + e2) % 2 == 0)
        n2 += "0";
      s = Math.sqrt(+n2);
      e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
      if (s == 1 / 0) {
        n2 = "5e" + e2;
      } else {
        n2 = s.toExponential();
        n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
      }
      r2 = new BigNumber2(n2);
    } else {
      r2 = new BigNumber2(s + "");
    }
    if (r2.c[0]) {
      e2 = r2.e;
      s = e2 + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t2 = r2;
        r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
        if (coeffToString(t2.c).slice(0, s) === (n2 = coeffToString(r2.c)).slice(0, s)) {
          if (r2.e < e2)
            --s;
          n2 = n2.slice(s - 3, s + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              round(t2, t2.e + DECIMAL_PLACES + 2, 0);
              if (t2.times(t2).eq(x2)) {
                r2 = t2;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              round(r2, r2.e + DECIMAL_PLACES + 2, 1);
              m2 = !r2.times(r2).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x2 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md2) {
    var d, d0, d1, d2, e2, exp2, n2, n0, n1, q2, r2, s, x2 = this, xc2 = x2.c;
    if (md2 != null) {
      n2 = new BigNumber2(md2);
      if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
      }
    }
    if (!xc2)
      return new BigNumber2(x2);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc2);
    e2 = d.e = s.length - x2.e - 1;
    d.c[0] = POWS_TEN[(exp2 = e2 % LOG_BASE) < 0 ? LOG_BASE + exp2 : exp2];
    md2 = !md2 || n2.comparedTo(d) > 0 ? e2 > 0 ? d : n1 : n2;
    exp2 = MAX_EXP;
    MAX_EXP = 1 / 0;
    n2 = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q2 = div(n2, d, 0, 1);
      d2 = d0.plus(q2.times(d1));
      if (d2.comparedTo(md2) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q2.times(d2 = n1));
      n0 = d2;
      d = n2.minus(q2.times(d2 = d));
      n2 = d2;
    }
    d2 = div(md2.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x2.s;
    e2 = e2 * 2;
    r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp2;
    return r2;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd2, rm) {
    if (sd2 != null)
      intCheck(sd2, 1, MAX);
    return format(this, sd2, rm, 2);
  };
  P2.toString = function(b2) {
    var str, n2 = this, s = n2.s, e2 = n2.e;
    if (e2 === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b2 == null) {
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
      } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
        n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
      } else {
        intCheck(b2, 2, ALPHABET2.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b2, s, true);
      }
      if (s < 0 && n2.c[0])
        str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n2) {
  var i = n2 | 0;
  return n2 > 0 || n2 === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z2, i = 1, j = a.length, r2 = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z2 = LOG_BASE - s.length;
    for (; z2--; s = "0" + s)
      ;
    r2 += s;
  }
  for (j = r2.length; r2.charCodeAt(--j) === 48; )
    ;
  return r2.slice(0, j + 1 || 1);
}
function compare(x2, y2) {
  var a, b2, xc2 = x2.c, yc2 = y2.c, i = x2.s, j = y2.s, k2 = x2.e, l2 = y2.e;
  if (!i || !j)
    return null;
  a = xc2 && !xc2[0];
  b2 = yc2 && !yc2[0];
  if (a || b2)
    return a ? b2 ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b2 = k2 == l2;
  if (!xc2 || !yc2)
    return b2 ? 0 : !xc2 ^ a ? 1 : -1;
  if (!b2)
    return k2 > l2 ^ a ? 1 : -1;
  j = (k2 = xc2.length) < (l2 = yc2.length) ? k2 : l2;
  for (i = 0; i < j; i++)
    if (xc2[i] != yc2[i])
      return xc2[i] > yc2[i] ^ a ? 1 : -1;
  return k2 == l2 ? 0 : k2 > l2 ^ a ? 1 : -1;
}
function intCheck(n2, min, max, name) {
  if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
  }
}
function isOdd(n2) {
  var k2 = n2.c.length - 1;
  return bitFloor(n2.e / LOG_BASE) == k2 && n2.c[k2] % 2 != 0;
}
function toExponential(str, e2) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
}
function toFixedPoint(str, e2, z2) {
  var len, zs;
  if (e2 < 0) {
    for (zs = z2 + "."; ++e2; zs += z2)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e2 > len) {
      for (zs = z2, e2 -= len; --e2; zs += z2)
        ;
      str += zs;
    } else if (e2 < len) {
      str = str.slice(0, e2) + "." + str.slice(e2);
    }
  }
  return str;
}
var BigNumber = clone();
var validator$2 = { exports: {} };
var toDate = { exports: {} };
var assertString = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString2;
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  function assertString2(input) {
    var isString2 = typeof input === "string" || input instanceof String;
    if (!isString2) {
      var invalidType = _typeof2(input);
      if (input === null)
        invalidType = "null";
      else if (invalidType === "object")
        invalidType = input.constructor.name;
      throw new TypeError("Expected a string but received a ".concat(invalidType));
    }
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(assertString, assertString.exports);
var assertStringExports = assertString.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toDate2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toDate2(date) {
    (0, _assertString2.default)(date);
    date = Date.parse(date);
    return !isNaN(date) ? new Date(date) : null;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toDate, toDate.exports);
var toDateExports = toDate.exports;
var toFloat = { exports: {} };
var isFloat$1 = {};
var alpha$1 = {};
Object.defineProperty(alpha$1, "__esModule", {
  value: true
});
alpha$1.farsiLocales = alpha$1.englishLocales = alpha$1.dotDecimal = alpha$1.decimal = alpha$1.commaDecimal = alpha$1.bengaliLocales = alpha$1.arabicLocales = alpha$1.alphanumeric = alpha$1.alpha = void 0;
var alpha = alpha$1.alpha = {
  "en-US": /^[A-Z]+$/i,
  "az-AZ": /^[A-VXYZ]+$/i,
  "bg-BG": /^[-]+$/i,
  "cs-CZ": /^[A-Z]+$/i,
  "da-DK": /^[A-Z]+$/i,
  "de-DE": /^[A-Z]+$/i,
  "el-GR": /^[-]+$/i,
  "es-ES": /^[A-Z]+$/i,
  "fa-IR": /^[]+$/i,
  "fi-FI": /^[A-Z]+$/i,
  "fr-FR": /^[A-Z]+$/i,
  "it-IT": /^[A-Z]+$/i,
  "ja-JP": /^[----]+$/i,
  "nb-NO": /^[A-Z]+$/i,
  "nl-NL": /^[A-Z]+$/i,
  "nn-NO": /^[A-Z]+$/i,
  "hu-HU": /^[A-Z]+$/i,
  "pl-PL": /^[A-Z]+$/i,
  "pt-PT": /^[A-Z]+$/i,
  "ru-RU": /^[-]+$/i,
  "kk-KZ": /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[A-Z]+$/i,
  "sk-SK": /^[A-Z]+$/i,
  "sr-RS@latin": /^[A-Z]+$/i,
  "sr-RS": /^[-]+$/i,
  "sv-SE": /^[A-Z]+$/i,
  "th-TH": /^[-\s]+$/i,
  "tr-TR": /^[A-Z]+$/i,
  "uk-UA": /^[-I]+$/i,
  "vi-VN": /^[A-Z]+$/i,
  "ko-KR": /^[---]*$/,
  "ku-IQ": /^[]+$/i,
  ar: /^[]+$/,
  he: /^[-]+$/,
  fa: /^['']+$/i,
  bn: /^['']+$/,
  eo: /^[ABCD-GHIJK-PRSTUVZ]+$/i,
  "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
  "si-LK": /^[\u0D80-\u0DFF]+$/
};
var alphanumeric = alpha$1.alphanumeric = {
  "en-US": /^[0-9A-Z]+$/i,
  "az-AZ": /^[0-9A-VXYZ]+$/i,
  "bg-BG": /^[0-9-]+$/i,
  "cs-CZ": /^[0-9A-Z]+$/i,
  "da-DK": /^[0-9A-Z]+$/i,
  "de-DE": /^[0-9A-Z]+$/i,
  "el-GR": /^[0-9-]+$/i,
  "es-ES": /^[0-9A-Z]+$/i,
  "fi-FI": /^[0-9A-Z]+$/i,
  "fr-FR": /^[0-9A-Z]+$/i,
  "it-IT": /^[0-9A-Z]+$/i,
  "ja-JP": /^[0-9-----]+$/i,
  "hu-HU": /^[0-9A-Z]+$/i,
  "nb-NO": /^[0-9A-Z]+$/i,
  "nl-NL": /^[0-9A-Z]+$/i,
  "nn-NO": /^[0-9A-Z]+$/i,
  "pl-PL": /^[0-9A-Z]+$/i,
  "pt-PT": /^[0-9A-Z]+$/i,
  "ru-RU": /^[0-9-]+$/i,
  "kk-KZ": /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[0-9A-Z]+$/i,
  "sk-SK": /^[0-9A-Z]+$/i,
  "sr-RS@latin": /^[0-9A-Z]+$/i,
  "sr-RS": /^[0-9-]+$/i,
  "sv-SE": /^[0-9A-Z]+$/i,
  "th-TH": /^[-\s]+$/i,
  "tr-TR": /^[0-9A-Z]+$/i,
  "uk-UA": /^[0-9-I]+$/i,
  "ko-KR": /^[0-9---]*$/,
  "ku-IQ": /^[0-9]+$/i,
  "vi-VN": /^[0-9A-Z]+$/i,
  ar: /^[0-9]+$/,
  he: /^[0-9-]+$/,
  fa: /^['0-9']+$/i,
  bn: /^['']+$/,
  eo: /^[0-9ABCD-GHIJK-PRSTUVZ]+$/i,
  "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
  "si-LK": /^[0-9\u0D80-\u0DFF]+$/
};
var decimal = alpha$1.decimal = {
  "en-US": ".",
  ar: ""
};
var englishLocales = alpha$1.englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
for (var locale, i = 0; i < englishLocales.length; i++) {
  locale = "en-".concat(englishLocales[i]);
  alpha[locale] = alpha["en-US"];
  alphanumeric[locale] = alphanumeric["en-US"];
  decimal[locale] = decimal["en-US"];
}
var arabicLocales = alpha$1.arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
for (var _locale, _i2 = 0; _i2 < arabicLocales.length; _i2++) {
  _locale = "ar-".concat(arabicLocales[_i2]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
}
var farsiLocales = alpha$1.farsiLocales = ["IR", "AF"];
for (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {
  _locale2 = "fa-".concat(farsiLocales[_i2]);
  alphanumeric[_locale2] = alphanumeric.fa;
  decimal[_locale2] = decimal.ar;
}
var bengaliLocales = alpha$1.bengaliLocales = ["BD", "IN"];
for (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {
  _locale3 = "bn-".concat(bengaliLocales[_i3]);
  alpha[_locale3] = alpha.bn;
  alphanumeric[_locale3] = alphanumeric.bn;
  decimal[_locale3] = decimal["en-US"];
}
var dotDecimal = alpha$1.dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
var commaDecimal = alpha$1.commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
for (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {
  decimal[dotDecimal[_i4]] = decimal["en-US"];
}
for (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {
  decimal[commaDecimal[_i5]] = ",";
}
alpha["fr-CA"] = alpha["fr-FR"];
alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
alpha["pt-BR"] = alpha["pt-PT"];
alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
decimal["pt-BR"] = decimal["pt-PT"];
alpha["pl-Pl"] = alpha["pl-PL"];
alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
decimal["pl-Pl"] = decimal["pl-PL"];
alpha["fa-AF"] = alpha.fa;
Object.defineProperty(isFloat$1, "__esModule", {
  value: true
});
isFloat$1.default = isFloat;
isFloat$1.locales = void 0;
var _assertString$b = _interopRequireDefault$b(assertStringExports);
var _alpha$2 = alpha$1;
function _interopRequireDefault$b(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isFloat(str, options) {
  (0, _assertString$b.default)(str);
  options = options || {};
  var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha$2.decimal[options.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
  if (str === "" || str === "." || str === "," || str === "-" || str === "+") {
    return false;
  }
  var value = parseFloat(str.replace(",", "."));
  return float.test(str) && (!options.hasOwnProperty("min") || value >= options.min) && (!options.hasOwnProperty("max") || value <= options.max) && (!options.hasOwnProperty("lt") || value < options.lt) && (!options.hasOwnProperty("gt") || value > options.gt);
}
isFloat$1.locales = Object.keys(_alpha$2.decimal);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toFloat2;
  var _isFloat = _interopRequireDefault2(isFloat$1);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toFloat2(str) {
    if (!(0, _isFloat.default)(str))
      return NaN;
    return parseFloat(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toFloat, toFloat.exports);
var toFloatExports = toFloat.exports;
var toInt = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toInt2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toInt2(str, radix) {
    (0, _assertString2.default)(str);
    return parseInt(str, radix || 10);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toInt, toInt.exports);
var toIntExports = toInt.exports;
var toBoolean = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBoolean2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toBoolean2(str, strict) {
    (0, _assertString2.default)(str);
    if (strict) {
      return str === "1" || /^true$/i.test(str);
    }
    return str !== "0" && !/^false$/i.test(str) && str !== "";
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toBoolean, toBoolean.exports);
var toBooleanExports = toBoolean.exports;
var equals = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = equals2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function equals2(str, comparison) {
    (0, _assertString2.default)(str);
    return str === comparison;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(equals, equals.exports);
var equalsExports = equals.exports;
var contains = { exports: {} };
var toString$2 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toString3;
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  function toString3(input) {
    if (_typeof2(input) === "object" && input !== null) {
      if (typeof input.toString === "function") {
        input = input.toString();
      } else {
        input = "[object Object]";
      }
    } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
      input = "";
    }
    return String(input);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toString$2, toString$2.exports);
var toStringExports = toString$2.exports;
var merge$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge2;
  function merge2() {
    var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults2 = arguments.length > 1 ? arguments[1] : void 0;
    for (var key in defaults2) {
      if (typeof obj[key] === "undefined") {
        obj[key] = defaults2[key];
      }
    }
    return obj;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(merge$1, merge$1.exports);
var mergeExports = merge$1.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = contains2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toString = _interopRequireDefault2(toStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var defaulContainsOptions = {
    ignoreCase: false,
    minOccurrences: 1
  };
  function contains2(str, elem, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, defaulContainsOptions);
    if (options.ignoreCase) {
      return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
    }
    return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(contains, contains.exports);
var containsExports = contains.exports;
var matches = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = matches2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function matches2(str, pattern, modifiers) {
    (0, _assertString2.default)(str);
    if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
      pattern = new RegExp(pattern, modifiers);
    }
    return !!str.match(pattern);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(matches, matches.exports);
var matchesExports = matches.exports;
var isEmail = { exports: {} };
var isByteLength = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isByteLength2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  function isByteLength2(str, options) {
    (0, _assertString2.default)(str);
    var min;
    var max;
    if (_typeof2(options) === "object") {
      min = options.min || 0;
      max = options.max;
    } else {
      min = arguments[1];
      max = arguments[2];
    }
    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === "undefined" || len <= max);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isByteLength, isByteLength.exports);
var isByteLengthExports = isByteLength.exports;
var isFQDN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_numeric_tld: false,
    allow_wildcard: false,
    ignore_max_length: false
  };
  function isFQDN2(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, default_fqdn_options);
    if (options.allow_trailing_dot && str[str.length - 1] === ".") {
      str = str.substring(0, str.length - 1);
    }
    if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
      str = str.substring(2);
    }
    var parts = str.split(".");
    var tld = parts[parts.length - 1];
    if (options.require_tld) {
      if (parts.length < 2) {
        return false;
      }
      if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      if (/\s/.test(tld)) {
        return false;
      }
    }
    if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }
    return parts.every(function(part) {
      if (part.length > 63 && !options.ignore_max_length) {
        return false;
      }
      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (/^-|-$/.test(part)) {
        return false;
      }
      if (!options.allow_underscores && /_/.test(part)) {
        return false;
      }
      return true;
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isFQDN, isFQDN.exports);
var isFQDNExports = isFQDN.exports;
var isIP = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
  var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
  var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
  var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
  function isIP2(str) {
    var version2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (0, _assertString2.default)(str);
    version2 = String(version2);
    if (!version2) {
      return isIP2(str, 4) || isIP2(str, 6);
    }
    if (version2 === "4") {
      return IPv4AddressRegExp.test(str);
    }
    if (version2 === "6") {
      return IPv6AddressRegExp.test(str);
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIP, isIP.exports);
var isIPExports = isIP.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isByteLength = _interopRequireDefault2(isByteLengthExports);
  var _isFQDN = _interopRequireDefault2(isFQDNExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_email_options = {
    allow_display_name: false,
    allow_underscores: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true,
    blacklisted_chars: "",
    ignore_max_length: false,
    host_blacklist: [],
    host_whitelist: []
  };
  var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  var defaultMaxEmailLength = 254;
  function validateDisplayName(display_name) {
    var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
    if (!display_name_without_quotes.trim()) {
      return false;
    }
    var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
    if (contains_illegal) {
      if (display_name_without_quotes === display_name) {
        return false;
      }
      var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
      if (!all_start_with_back_slash) {
        return false;
      }
    }
    return true;
  }
  function isEmail2(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, default_email_options);
    if (options.require_display_name || options.allow_display_name) {
      var display_email = str.match(splitNameAddress);
      if (display_email) {
        var display_name = display_email[1];
        str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
        if (display_name.endsWith(" ")) {
          display_name = display_name.slice(0, -1);
        }
        if (!validateDisplayName(display_name)) {
          return false;
        }
      } else if (options.require_display_name) {
        return false;
      }
    }
    if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
      return false;
    }
    var parts = str.split("@");
    var domain = parts.pop();
    var lower_domain = domain.toLowerCase();
    if (options.host_blacklist.includes(lower_domain)) {
      return false;
    }
    if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
      return false;
    }
    var user = parts.join("@");
    if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
      user = user.toLowerCase();
      var username = user.split("+")[0];
      if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
        min: 6,
        max: 30
      })) {
        return false;
      }
      var _user_parts = username.split(".");
      for (var i = 0; i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }
    if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
      max: 64
    }) || !(0, _isByteLength.default)(domain, {
      max: 254
    }))) {
      return false;
    }
    if (!(0, _isFQDN.default)(domain, {
      require_tld: options.require_tld,
      ignore_max_length: options.ignore_max_length,
      allow_underscores: options.allow_underscores
    })) {
      if (!options.allow_ip_domain) {
        return false;
      }
      if (!(0, _isIP.default)(domain)) {
        if (!domain.startsWith("[") || !domain.endsWith("]")) {
          return false;
        }
        var noBracketdomain = domain.slice(1, -1);
        if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
          return false;
        }
      }
    }
    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }
    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
    var user_parts = user.split(".");
    for (var _i2 = 0; _i2 < user_parts.length; _i2++) {
      if (!pattern.test(user_parts[_i2])) {
        return false;
      }
    }
    if (options.blacklisted_chars) {
      if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1)
        return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEmail, isEmail.exports);
var isEmailExports = isEmail.exports;
var isURL = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isFQDN = _interopRequireDefault2(isFQDNExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i, u2, a = [], f2 = true, o = false;
      try {
        if (i = (t2 = t2.call(r2)).next, 0 === l2) {
          if (Object(t2) !== t2)
            return;
          f2 = false;
        } else
          for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true)
            ;
      } catch (r3) {
        o = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2))
            return;
        } finally {
          if (o)
            throw n2;
        }
      }
      return a;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var default_url_options = {
    protocols: ["http", "https", "ftp"],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_port: false,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
    allow_fragments: true,
    allow_query_components: true,
    validate_length: true
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
  function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  }
  function checkHost(host, matches2) {
    for (var i = 0; i < matches2.length; i++) {
      var match = matches2[i];
      if (host === match || isRegExp2(match) && match.test(host)) {
        return true;
      }
    }
    return false;
  }
  function isURL2(url, options) {
    (0, _assertString2.default)(url);
    if (!url || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf("mailto:") === 0) {
      return false;
    }
    options = (0, _merge.default)(options, default_url_options);
    if (options.validate_length && url.length >= 2083) {
      return false;
    }
    if (!options.allow_fragments && url.includes("#")) {
      return false;
    }
    if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
      return false;
    }
    var protocol, auth, host, hostname, port, port_str, split2, ipv6;
    split2 = url.split("#");
    url = split2.shift();
    split2 = url.split("?");
    url = split2.shift();
    split2 = url.split("://");
    if (split2.length > 1) {
      protocol = split2.shift().toLowerCase();
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.slice(0, 2) === "//") {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }
      split2[0] = url.slice(2);
    }
    url = split2.join("://");
    if (url === "") {
      return false;
    }
    split2 = url.split("/");
    url = split2.shift();
    if (url === "" && !options.require_host) {
      return true;
    }
    split2 = url.split("@");
    if (split2.length > 1) {
      if (options.disallow_auth) {
        return false;
      }
      if (split2[0] === "") {
        return false;
      }
      auth = split2.shift();
      if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
        return false;
      }
      var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
      if (user === "" && password === "") {
        return false;
      }
    }
    hostname = split2.join("@");
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = "";
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split2 = hostname.split(":");
      host = split2.shift();
      if (split2.length) {
        port_str = split2.join(":");
      }
    }
    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options.require_port) {
      return false;
    }
    if (options.host_whitelist) {
      return checkHost(host, options.host_whitelist);
    }
    if (host === "" && !options.require_host) {
      return true;
    }
    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
      return false;
    }
    host = host || ipv6;
    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isURL, isURL.exports);
var isURLExports = isURL.exports;
var isMACAddress = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMACAddress2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
  var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
  var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
  var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
  var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
  var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
  function isMACAddress2(str, options) {
    (0, _assertString2.default)(str);
    if (options !== null && options !== void 0 && options.eui) {
      options.eui = String(options.eui);
    }
    if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
      if (options.eui === "48") {
        return macAddress48NoSeparators.test(str);
      }
      if (options.eui === "64") {
        return macAddress64NoSeparators.test(str);
      }
      return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
    }
    if ((options === null || options === void 0 ? void 0 : options.eui) === "48") {
      return macAddress48.test(str) || macAddress48WithDots.test(str);
    }
    if ((options === null || options === void 0 ? void 0 : options.eui) === "64") {
      return macAddress64.test(str) || macAddress64WithDots.test(str);
    }
    return isMACAddress2(str, {
      eui: "48"
    }) || isMACAddress2(str, {
      eui: "64"
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMACAddress, isMACAddress.exports);
var isMACAddressExports = isMACAddress.exports;
var isIPRange = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIPRange2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var subnetMaybe = /^\d{1,3}$/;
  var v4Subnet = 32;
  var v6Subnet = 128;
  function isIPRange2(str) {
    var version2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (0, _assertString2.default)(str);
    var parts = str.split("/");
    if (parts.length !== 2) {
      return false;
    }
    if (!subnetMaybe.test(parts[1])) {
      return false;
    }
    if (parts[1].length > 1 && parts[1].startsWith("0")) {
      return false;
    }
    var isValidIP = (0, _isIP.default)(parts[0], version2);
    if (!isValidIP) {
      return false;
    }
    var expectedSubnet = null;
    switch (String(version2)) {
      case "4":
        expectedSubnet = v4Subnet;
        break;
      case "6":
        expectedSubnet = v6Subnet;
        break;
      default:
        expectedSubnet = (0, _isIP.default)(parts[0], "6") ? v6Subnet : v4Subnet;
    }
    return parts[1] <= expectedSubnet && parts[1] >= 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIPRange, isIPRange.exports);
var isIPRangeExports = isIPRange.exports;
var isDate$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDate2;
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i, u2, a = [], f2 = true, o = false;
      try {
        if (i = (t2 = t2.call(r2)).next, 0 === l2) {
          if (Object(t2) !== t2)
            return;
          f2 = false;
        } else
          for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true)
            ;
      } catch (r3) {
        o = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2))
            return;
        } finally {
          if (o)
            throw n2;
        }
      }
      return a;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e2(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n2() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e2(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f2() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var default_date_options = {
    format: "YYYY/MM/DD",
    delimiters: ["/", "-"],
    strictMode: false
  };
  function isValidFormat(format) {
    return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
  }
  function zip(date, format) {
    var zippedArr = [], len = Math.min(date.length, format.length);
    for (var i = 0; i < len; i++) {
      zippedArr.push([date[i], format[i]]);
    }
    return zippedArr;
  }
  function isDate2(input, options) {
    if (typeof options === "string") {
      options = (0, _merge.default)({
        format: options
      }, default_date_options);
    } else {
      options = (0, _merge.default)(options, default_date_options);
    }
    if (typeof input === "string" && isValidFormat(options.format)) {
      var formatDelimiter = options.delimiters.find(function(delimiter) {
        return options.format.indexOf(delimiter) !== -1;
      });
      var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function(delimiter) {
        return input.indexOf(delimiter) !== -1;
      });
      var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
      var dateObj = {};
      var _iterator = _createForOfIteratorHelper(dateAndFormat), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), dateWord = _step$value[0], formatWord = _step$value[1];
          if (dateWord.length !== formatWord.length) {
            return false;
          }
          dateObj[formatWord.charAt(0)] = dateWord;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var fullYear = dateObj.y;
      if (fullYear.startsWith("-")) {
        return false;
      }
      if (dateObj.y.length === 2) {
        var parsedYear = parseInt(dateObj.y, 10);
        if (isNaN(parsedYear)) {
          return false;
        }
        var currentYearLastTwoDigits = (/* @__PURE__ */ new Date()).getFullYear() % 100;
        if (parsedYear < currentYearLastTwoDigits) {
          fullYear = "20".concat(dateObj.y);
        } else {
          fullYear = "19".concat(dateObj.y);
        }
      }
      var month = dateObj.m;
      if (dateObj.m.length === 1) {
        month = "0".concat(dateObj.m);
      }
      var day = dateObj.d;
      if (dateObj.d.length === 1) {
        day = "0".concat(dateObj.d);
      }
      return new Date("".concat(fullYear, "-").concat(month, "-").concat(day, "T00:00:00.000Z")).getUTCDate() === +dateObj.d;
    }
    if (!options.strictMode) {
      return Object.prototype.toString.call(input) === "[object Date]" && isFinite(input);
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDate$1, isDate$1.exports);
var isDateExports = isDate$1.exports;
var isTime = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTime2;
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_time_options = {
    hourFormat: "hour24",
    mode: "default"
  };
  var formats = {
    hour24: {
      default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
      withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
    },
    hour12: {
      default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
      withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
    }
  };
  function isTime2(input, options) {
    options = (0, _merge.default)(options, default_time_options);
    if (typeof input !== "string")
      return false;
    return formats[options.hourFormat][options.mode].test(input);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isTime, isTime.exports);
var isTimeExports = isTime.exports;
var isBoolean$2 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBoolean2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var defaultOptions = {
    loose: false
  };
  var strictBooleans = ["true", "false", "1", "0"];
  var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
  function isBoolean2(str) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions;
    (0, _assertString2.default)(str);
    if (options.loose) {
      return looseBooleans.includes(str.toLowerCase());
    }
    return strictBooleans.includes(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBoolean$2, isBoolean$2.exports);
var isBooleanExports = isBoolean$2.exports;
var isLocale = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLocale2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var extlang = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
  var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");
  var script = "([A-Za-z]{4})";
  var region = "([A-Za-z]{2}|\\d{3})";
  var variant = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))";
  var singleton = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])";
  var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");
  var privateuse = "(x(-[A-Za-z0-9]{1,8})+)";
  var irregular = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))";
  var regular = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))";
  var grandfathered = "(".concat(irregular, "|").concat(regular, ")");
  var delimiter = "(-|_)";
  var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");
  var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
  function isLocale2(str) {
    (0, _assertString2.default)(str);
    return languageTagRegex.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLocale, isLocale.exports);
var isLocaleExports = isLocale.exports;
var isAbaRouting = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAbaRouting2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
  function isAbaRouting2(str) {
    (0, _assertString2.default)(str);
    if (!isRoutingReg.test(str))
      return false;
    var checkSumVal = 0;
    for (var i = 0; i < str.length; i++) {
      if (i % 3 === 0)
        checkSumVal += str[i] * 3;
      else if (i % 3 === 1)
        checkSumVal += str[i] * 7;
      else
        checkSumVal += str[i] * 1;
    }
    return checkSumVal % 10 === 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isAbaRouting, isAbaRouting.exports);
var isAbaRoutingExports = isAbaRouting.exports;
var isAlpha$1 = {};
Object.defineProperty(isAlpha$1, "__esModule", {
  value: true
});
isAlpha$1.default = isAlpha;
isAlpha$1.locales = void 0;
var _assertString$a = _interopRequireDefault$a(assertStringExports);
var _alpha$1 = alpha$1;
function _interopRequireDefault$a(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isAlpha(_str) {
  var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  (0, _assertString$a.default)(_str);
  var str = _str;
  var ignore = options.ignore;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str = str.replace(ignore, "");
    } else if (typeof ignore === "string") {
      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
    } else {
      throw new Error("ignore should be instance of a String or RegExp");
    }
  }
  if (locale in _alpha$1.alpha) {
    return _alpha$1.alpha[locale].test(str);
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
isAlpha$1.locales = Object.keys(_alpha$1.alpha);
var isAlphanumeric$1 = {};
Object.defineProperty(isAlphanumeric$1, "__esModule", {
  value: true
});
isAlphanumeric$1.default = isAlphanumeric;
isAlphanumeric$1.locales = void 0;
var _assertString$9 = _interopRequireDefault$9(assertStringExports);
var _alpha = alpha$1;
function _interopRequireDefault$9(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isAlphanumeric(_str) {
  var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  (0, _assertString$9.default)(_str);
  var str = _str;
  var ignore = options.ignore;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str = str.replace(ignore, "");
    } else if (typeof ignore === "string") {
      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
    } else {
      throw new Error("ignore should be instance of a String or RegExp");
    }
  }
  if (locale in _alpha.alphanumeric) {
    return _alpha.alphanumeric[locale].test(str);
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
isAlphanumeric$1.locales = Object.keys(_alpha.alphanumeric);
var isNumeric = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNumeric2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _alpha2 = alpha$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var numericNoSymbols = /^[0-9]+$/;
  function isNumeric2(str, options) {
    (0, _assertString2.default)(str);
    if (options && options.no_symbols) {
      return numericNoSymbols.test(str);
    }
    return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha2.decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isNumeric, isNumeric.exports);
var isNumericExports = isNumeric.exports;
var isPassportNumber = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPassportNumber2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var passportRegexByCountryCode = {
    AM: /^[A-Z]{2}\d{7}$/,
    // ARMENIA
    AR: /^[A-Z]{3}\d{6}$/,
    // ARGENTINA
    AT: /^[A-Z]\d{7}$/,
    // AUSTRIA
    AU: /^[A-Z]\d{7}$/,
    // AUSTRALIA
    AZ: /^[A-Z]{1}\d{8}$/,
    // AZERBAIJAN
    BE: /^[A-Z]{2}\d{6}$/,
    // BELGIUM
    BG: /^\d{9}$/,
    // BULGARIA
    BR: /^[A-Z]{2}\d{6}$/,
    // BRAZIL
    BY: /^[A-Z]{2}\d{7}$/,
    // BELARUS
    CA: /^[A-Z]{2}\d{6}$/,
    // CANADA
    CH: /^[A-Z]\d{7}$/,
    // SWITZERLAND
    CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
    // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
    CY: /^[A-Z](\d{6}|\d{8})$/,
    // CYPRUS
    CZ: /^\d{8}$/,
    // CZECH REPUBLIC
    DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
    // GERMANY
    DK: /^\d{9}$/,
    // DENMARK
    DZ: /^\d{9}$/,
    // ALGERIA
    EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
    // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
    ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
    // SPAIN
    FI: /^[A-Z]{2}\d{7}$/,
    // FINLAND
    FR: /^\d{2}[A-Z]{2}\d{5}$/,
    // FRANCE
    GB: /^\d{9}$/,
    // UNITED KINGDOM
    GR: /^[A-Z]{2}\d{7}$/,
    // GREECE
    HR: /^\d{9}$/,
    // CROATIA
    HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
    // HUNGARY
    IE: /^[A-Z0-9]{2}\d{7}$/,
    // IRELAND
    IN: /^[A-Z]{1}-?\d{7}$/,
    // INDIA
    ID: /^[A-C]\d{7}$/,
    // INDONESIA
    IR: /^[A-Z]\d{8}$/,
    // IRAN
    IS: /^(A)\d{7}$/,
    // ICELAND
    IT: /^[A-Z0-9]{2}\d{7}$/,
    // ITALY
    JM: /^[Aa]\d{7}$/,
    // JAMAICA
    JP: /^[A-Z]{2}\d{7}$/,
    // JAPAN
    KR: /^[MS]\d{8}$/,
    // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
    KZ: /^[a-zA-Z]\d{7}$/,
    // KAZAKHSTAN
    LI: /^[a-zA-Z]\d{5}$/,
    // LIECHTENSTEIN
    LT: /^[A-Z0-9]{8}$/,
    // LITHUANIA
    LU: /^[A-Z0-9]{8}$/,
    // LUXEMBURG
    LV: /^[A-Z0-9]{2}\d{7}$/,
    // LATVIA
    LY: /^[A-Z0-9]{8}$/,
    // LIBYA
    MT: /^\d{7}$/,
    // MALTA
    MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
    // MOZAMBIQUE
    MY: /^[AHK]\d{8}$/,
    // MALAYSIA
    MX: /^\d{10,11}$/,
    // MEXICO
    NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
    // NETHERLANDS
    NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
    // NEW ZEALAND
    PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
    // PHILIPPINES
    PK: /^[A-Z]{2}\d{7}$/,
    // PAKISTAN
    PL: /^[A-Z]{2}\d{7}$/,
    // POLAND
    PT: /^[A-Z]\d{6}$/,
    // PORTUGAL
    RO: /^\d{8,9}$/,
    // ROMANIA
    RU: /^\d{9}$/,
    // RUSSIAN FEDERATION
    SE: /^\d{8}$/,
    // SWEDEN
    SL: /^(P)[A-Z]\d{7}$/,
    // SLOVENIA
    SK: /^[0-9A-Z]\d{7}$/,
    // SLOVAKIA
    TH: /^[A-Z]{1,2}\d{6,7}$/,
    // THAILAND
    TR: /^[A-Z]\d{8}$/,
    // TURKEY
    UA: /^[A-Z]{2}\d{6}$/,
    // UKRAINE
    US: /^\d{9}$/,
    // UNITED STATES
    ZA: /^[TAMD]\d{8}$/
    // SOUTH AFRICA
  };
  function isPassportNumber2(str, countryCode) {
    (0, _assertString2.default)(str);
    var normalizedStr = str.replace(/\s/g, "").toUpperCase();
    return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isPassportNumber, isPassportNumber.exports);
var isPassportNumberExports = isPassportNumber.exports;
var isPort = { exports: {} };
var isInt = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isInt2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
  var intLeadingZeroes = /^[-+]?[0-9]+$/;
  function isInt2(str, options) {
    (0, _assertString2.default)(str);
    options = options || {};
    var regex2 = options.allow_leading_zeroes === false ? int : intLeadingZeroes;
    var minCheckPassed = !options.hasOwnProperty("min") || str >= options.min;
    var maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max;
    var ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt;
    var gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
    return regex2.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isInt, isInt.exports);
var isIntExports = isInt.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPort2;
  var _isInt = _interopRequireDefault2(isIntExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isPort2(str) {
    return (0, _isInt.default)(str, {
      allow_leading_zeroes: false,
      min: 0,
      max: 65535
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isPort, isPort.exports);
var isPortExports = isPort.exports;
var isLowercase = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLowercase2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isLowercase2(str) {
    (0, _assertString2.default)(str);
    return str === str.toLowerCase();
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLowercase, isLowercase.exports);
var isLowercaseExports = isLowercase.exports;
var isUppercase = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUppercase2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isUppercase2(str) {
    (0, _assertString2.default)(str);
    return str === str.toUpperCase();
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isUppercase, isUppercase.exports);
var isUppercaseExports = isUppercase.exports;
var isIMEI = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIMEI2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var imeiRegexWithoutHypens = /^[0-9]{15}$/;
  var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
  function isIMEI2(str, options) {
    (0, _assertString2.default)(str);
    options = options || {};
    var imeiRegex = imeiRegexWithoutHypens;
    if (options.allow_hyphens) {
      imeiRegex = imeiRegexWithHypens;
    }
    if (!imeiRegex.test(str)) {
      return false;
    }
    str = str.replace(/-/g, "");
    var sum = 0, mul2 = 2, l2 = 14;
    for (var i = 0; i < l2; i++) {
      var digit = str.substring(l2 - i - 1, l2 - i);
      var tp = parseInt(digit, 10) * mul2;
      if (tp >= 10) {
        sum += tp % 10 + 1;
      } else {
        sum += tp;
      }
      if (mul2 === 1) {
        mul2 += 1;
      } else {
        mul2 -= 1;
      }
    }
    var chk = (10 - sum % 10) % 10;
    if (chk !== parseInt(str.substring(14, 15), 10)) {
      return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIMEI, isIMEI.exports);
var isIMEIExports = isIMEI.exports;
var isAscii = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAscii2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ascii = /^[\x00-\x7F]+$/;
  function isAscii2(str) {
    (0, _assertString2.default)(str);
    return ascii.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isAscii, isAscii.exports);
var isAsciiExports = isAscii.exports;
var isFullWidth$1 = {};
Object.defineProperty(isFullWidth$1, "__esModule", {
  value: true
});
isFullWidth$1.default = isFullWidth;
isFullWidth$1.fullWidth = void 0;
var _assertString$8 = _interopRequireDefault$8(assertStringExports);
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var fullWidth = isFullWidth$1.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
function isFullWidth(str) {
  (0, _assertString$8.default)(str);
  return fullWidth.test(str);
}
var isHalfWidth$1 = {};
Object.defineProperty(isHalfWidth$1, "__esModule", {
  value: true
});
isHalfWidth$1.default = isHalfWidth;
isHalfWidth$1.halfWidth = void 0;
var _assertString$7 = _interopRequireDefault$7(assertStringExports);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var halfWidth = isHalfWidth$1.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
function isHalfWidth(str) {
  (0, _assertString$7.default)(str);
  return halfWidth.test(str);
}
var isVariableWidth = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isVariableWidth2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isFullWidth = isFullWidth$1;
  var _isHalfWidth = isHalfWidth$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isVariableWidth2(str) {
    (0, _assertString2.default)(str);
    return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isVariableWidth, isVariableWidth.exports);
var isVariableWidthExports = isVariableWidth.exports;
var isMultibyte = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMultibyte2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var multibyte = /[^\x00-\x7F]/;
  function isMultibyte2(str) {
    (0, _assertString2.default)(str);
    return multibyte.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMultibyte, isMultibyte.exports);
var isMultibyteExports = isMultibyte.exports;
var isSemVer = { exports: {} };
var multilineRegex = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = multilineRegexp;
  function multilineRegexp(parts, flags) {
    var regexpAsStringLiteral = parts.join("");
    return new RegExp(regexpAsStringLiteral, flags);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(multilineRegex, multilineRegex.exports);
var multilineRegexExports = multilineRegex.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSemVer2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _multilineRegex = _interopRequireDefault2(multilineRegexExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var semanticVersioningRegex = (0, _multilineRegex.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
  function isSemVer2(str) {
    (0, _assertString2.default)(str);
    return semanticVersioningRegex.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isSemVer, isSemVer.exports);
var isSemVerExports = isSemVer.exports;
var isSurrogatePair = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSurrogatePair2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
  function isSurrogatePair2(str) {
    (0, _assertString2.default)(str);
    return surrogatePair.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isSurrogatePair, isSurrogatePair.exports);
var isSurrogatePairExports = isSurrogatePair.exports;
var isDecimal = { exports: {} };
var includes = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var includes2 = function includes3(arr, val) {
    return arr.some(function(arrVal) {
      return val === arrVal;
    });
  };
  exports.default = includes2;
  module.exports = exports.default;
  module.exports.default = exports.default;
})(includes, includes.exports);
var includesExports = includes.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDecimal2;
  var _merge = _interopRequireDefault2(mergeExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _includes = _interopRequireDefault2(includesExports);
  var _alpha2 = alpha$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function decimalRegExp(options) {
    var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha2.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
    return regExp;
  }
  var default_decimal_options = {
    force_decimal: false,
    decimal_digits: "1,",
    locale: "en-US"
  };
  var blacklist2 = ["", "-", "+"];
  function isDecimal2(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, default_decimal_options);
    if (options.locale in _alpha2.decimal) {
      return !(0, _includes.default)(blacklist2, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
    }
    throw new Error("Invalid locale '".concat(options.locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDecimal, isDecimal.exports);
var isDecimalExports = isDecimal.exports;
var isHexadecimal = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHexadecimal2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
  function isHexadecimal2(str) {
    (0, _assertString2.default)(str);
    return hexadecimal.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHexadecimal, isHexadecimal.exports);
var isHexadecimalExports = isHexadecimal.exports;
var isOctal = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isOctal2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var octal = /^(0o)?[0-7]+$/i;
  function isOctal2(str) {
    (0, _assertString2.default)(str);
    return octal.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isOctal, isOctal.exports);
var isOctalExports = isOctal.exports;
var isDivisibleBy = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDivisibleBy2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toFloat = _interopRequireDefault2(toFloatExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isDivisibleBy2(str, num) {
    (0, _assertString2.default)(str);
    return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDivisibleBy, isDivisibleBy.exports);
var isDivisibleByExports = isDivisibleBy.exports;
var isHexColor = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHexColor2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
  function isHexColor2(str) {
    (0, _assertString2.default)(str);
    return hexcolor.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHexColor, isHexColor.exports);
var isHexColorExports = isHexColor.exports;
var isRgbColor = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isRgbColor2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
  var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
  var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
  var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
  function isRgbColor2(str) {
    var includePercentValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    (0, _assertString2.default)(str);
    if (!includePercentValues) {
      return rgbColor.test(str) || rgbaColor.test(str);
    }
    return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isRgbColor, isRgbColor.exports);
var isRgbColorExports = isRgbColor.exports;
var isHSL = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHSL2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
  var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
  function isHSL2(str) {
    (0, _assertString2.default)(str);
    var strippedStr = str.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
    if (strippedStr.indexOf(",") !== -1) {
      return hslComma.test(strippedStr);
    }
    return hslSpace.test(strippedStr);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHSL, isHSL.exports);
var isHSLExports = isHSL.exports;
var isISRC = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISRC2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
  function isISRC2(str) {
    (0, _assertString2.default)(str);
    return isrc.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISRC, isISRC.exports);
var isISRCExports = isISRC.exports;
var isIBAN$1 = {};
Object.defineProperty(isIBAN$1, "__esModule", {
  value: true
});
isIBAN$1.default = isIBAN;
isIBAN$1.locales = void 0;
var _assertString$6 = _interopRequireDefault$6(assertStringExports);
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var ibanRegexThroughCountryCode = {
  AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
  AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
  AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
  AT: /^(AT[0-9]{2})\d{16}$/,
  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  BA: /^(BA[0-9]{2})\d{16}$/,
  BE: /^(BE[0-9]{2})\d{12}$/,
  BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
  BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
  CR: /^(CR[0-9]{2})\d{18}$/,
  CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
  CZ: /^(CZ[0-9]{2})\d{20}$/,
  DE: /^(DE[0-9]{2})\d{18}$/,
  DK: /^(DK[0-9]{2})\d{14}$/,
  DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
  DZ: /^(DZ\d{24})$/,
  EE: /^(EE[0-9]{2})\d{16}$/,
  EG: /^(EG[0-9]{2})\d{25}$/,
  ES: /^(ES[0-9]{2})\d{20}$/,
  FI: /^(FI[0-9]{2})\d{14}$/,
  FO: /^(FO[0-9]{2})\d{14}$/,
  FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
  GL: /^(GL[0-9]{2})\d{14}$/,
  GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
  HR: /^(HR[0-9]{2})\d{17}$/,
  HU: /^(HU[0-9]{2})\d{24}$/,
  IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
  IL: /^(IL[0-9]{2})\d{19}$/,
  IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
  IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
  IS: /^(IS[0-9]{2})\d{22}$/,
  IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
  JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
  KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
  LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
  LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
  LT: /^(LT[0-9]{2})\d{16}$/,
  LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
  MA: /^(MA[0-9]{26})$/,
  MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
  ME: /^(ME[0-9]{2})\d{18}$/,
  MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
  MR: /^(MR[0-9]{2})\d{23}$/,
  MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
  MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
  MZ: /^(MZ[0-9]{2})\d{21}$/,
  NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
  NO: /^(NO[0-9]{2})\d{11}$/,
  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
  PL: /^(PL[0-9]{2})\d{24}$/,
  PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
  PT: /^(PT[0-9]{2})\d{21}$/,
  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
  RS: /^(RS[0-9]{2})\d{18}$/,
  SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
  SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
  SE: /^(SE[0-9]{2})\d{20}$/,
  SI: /^(SI[0-9]{2})\d{15}$/,
  SK: /^(SK[0-9]{2})\d{20}$/,
  SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  TL: /^(TL[0-9]{2})\d{19}$/,
  TN: /^(TN[0-9]{2})\d{20}$/,
  TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
  UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
  VA: /^(VA[0-9]{2})\d{18}$/,
  VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
  XK: /^(XK[0-9]{2})\d{16}$/
};
function hasOnlyValidCountryCodes(countryCodeArray) {
  var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function(countryCode) {
    return !(countryCode in ibanRegexThroughCountryCode);
  });
  if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
    return false;
  }
  return true;
}
function hasValidIbanFormat(str, options) {
  var strippedStr = str.replace(/[\s\-]+/gi, "").toUpperCase();
  var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
  var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
  if (options.whitelist) {
    if (!hasOnlyValidCountryCodes(options.whitelist)) {
      return false;
    }
    var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);
    if (!isoCountryCodeInWhiteList) {
      return false;
    }
  }
  if (options.blacklist) {
    var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);
    if (isoCountryCodeInBlackList) {
      return false;
    }
  }
  return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
}
function hasValidIbanChecksum(str) {
  var strippedStr = str.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
  var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
  var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char) {
    return char.charCodeAt(0) - 55;
  });
  var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value) {
    return Number(acc + value) % 97;
  }, "");
  return remainder === 1;
}
function isIBAN(str) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  (0, _assertString$6.default)(str);
  return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
}
isIBAN$1.locales = Object.keys(ibanRegexThroughCountryCode);
var isBIC = { exports: {} };
var isISO31661Alpha2$1 = {};
Object.defineProperty(isISO31661Alpha2$1, "__esModule", {
  value: true
});
isISO31661Alpha2$1.CountryCodes = void 0;
isISO31661Alpha2$1.default = isISO31661Alpha2;
var _assertString$5 = _interopRequireDefault$5(assertStringExports);
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var validISO31661Alpha2CountriesCodes = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
function isISO31661Alpha2(str) {
  (0, _assertString$5.default)(str);
  return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
}
isISO31661Alpha2$1.CountryCodes = validISO31661Alpha2CountriesCodes;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBIC2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isISO31661Alpha = isISO31661Alpha2$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
  function isBIC2(str) {
    (0, _assertString2.default)(str);
    var countryCode = str.slice(4, 6).toUpperCase();
    if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== "XK") {
      return false;
    }
    return isBICReg.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBIC, isBIC.exports);
var isBICExports = isBIC.exports;
var isMD5 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMD52;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var md52 = /^[a-f0-9]{32}$/;
  function isMD52(str) {
    (0, _assertString2.default)(str);
    return md52.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMD5, isMD5.exports);
var isMD5Exports = isMD5.exports;
var isHash = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHash2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var lengths = {
    md5: 32,
    md4: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8
  };
  function isHash2(str, algorithm) {
    (0, _assertString2.default)(str);
    var hash2 = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
    return hash2.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHash, isHash.exports);
var isHashExports = isHash.exports;
var isJWT = { exports: {} };
var isBase64 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase642;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var notBase64 = /[^A-Z0-9+\/=]/i;
  var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
  var defaultBase64Options = {
    urlSafe: false
  };
  function isBase642(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, defaultBase64Options);
    var len = str.length;
    if (options.urlSafe) {
      return urlSafeBase64.test(str);
    }
    if (len % 4 !== 0 || notBase64.test(str)) {
      return false;
    }
    var firstPaddingChar = str.indexOf("=");
    return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBase64, isBase64.exports);
var isBase64Exports = isBase64.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isJWT2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isBase = _interopRequireDefault2(isBase64Exports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isJWT2(str) {
    (0, _assertString2.default)(str);
    var dotSplit = str.split(".");
    var len = dotSplit.length;
    if (len !== 3) {
      return false;
    }
    return dotSplit.reduce(function(acc, currElem) {
      return acc && (0, _isBase.default)(currElem, {
        urlSafe: true
      });
    }, true);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isJWT, isJWT.exports);
var isJWTExports = isJWT.exports;
var isJSON = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isJSON2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  var default_json_options = {
    allow_primitives: false
  };
  function isJSON2(str, options) {
    (0, _assertString2.default)(str);
    try {
      options = (0, _merge.default)(options, default_json_options);
      var primitives = [];
      if (options.allow_primitives) {
        primitives = [null, false, true];
      }
      var obj = JSON.parse(str);
      return primitives.includes(obj) || !!obj && _typeof2(obj) === "object";
    } catch (e2) {
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isJSON, isJSON.exports);
var isJSONExports = isJSON.exports;
var isEmpty = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmpty2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_is_empty_options = {
    ignore_whitespace: false
  };
  function isEmpty2(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, default_is_empty_options);
    return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEmpty, isEmpty.exports);
var isEmptyExports = isEmpty.exports;
var isLength = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLength2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  function isLength2(str, options) {
    (0, _assertString2.default)(str);
    var min;
    var max;
    if (_typeof2(options) === "object") {
      min = options.min || 0;
      max = options.max;
    } else {
      min = arguments[1] || 0;
      max = arguments[2];
    }
    var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
    var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
    var len = str.length - presentationSequences.length - surrogatePairs.length;
    return len >= min && (typeof max === "undefined" || len <= max);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLength, isLength.exports);
var isLengthExports = isLength.exports;
var isUUID = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUUID2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var uuid2 = {
    1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
  };
  function isUUID2(str, version2) {
    (0, _assertString2.default)(str);
    var pattern = uuid2[![void 0, null].includes(version2) ? version2 : "all"];
    return !!pattern && pattern.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isUUID, isUUID.exports);
var isUUIDExports = isUUID.exports;
var isMongoId = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMongoId2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isHexadecimal = _interopRequireDefault2(isHexadecimalExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isMongoId2(str) {
    (0, _assertString2.default)(str);
    return (0, _isHexadecimal.default)(str) && str.length === 24;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMongoId, isMongoId.exports);
var isMongoIdExports = isMongoId.exports;
var isAfter = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAfter2;
  var _toDate = _interopRequireDefault2(toDateExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isAfter2(date, options) {
    var comparisonDate = (options === null || options === void 0 ? void 0 : options.comparisonDate) || options || Date().toString();
    var comparison = (0, _toDate.default)(comparisonDate);
    var original = (0, _toDate.default)(date);
    return !!(original && comparison && original > comparison);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isAfter, isAfter.exports);
var isAfterExports = isAfter.exports;
var isBefore = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBefore2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toDate = _interopRequireDefault2(toDateExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isBefore2(str) {
    var date = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : String(/* @__PURE__ */ new Date());
    (0, _assertString2.default)(str);
    var comparison = (0, _toDate.default)(date);
    var original = (0, _toDate.default)(str);
    return !!(original && comparison && original < comparison);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBefore, isBefore.exports);
var isBeforeExports = isBefore.exports;
var isIn = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIn2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toString = _interopRequireDefault2(toStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  function isIn2(str, options) {
    (0, _assertString2.default)(str);
    var i;
    if (Object.prototype.toString.call(options) === "[object Array]") {
      var array2 = [];
      for (i in options) {
        if ({}.hasOwnProperty.call(options, i)) {
          array2[i] = (0, _toString.default)(options[i]);
        }
      }
      return array2.indexOf(str) >= 0;
    } else if (_typeof2(options) === "object") {
      return options.hasOwnProperty(str);
    } else if (options && typeof options.indexOf === "function") {
      return options.indexOf(str) >= 0;
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIn, isIn.exports);
var isInExports = isIn.exports;
var isLuhnNumber = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLuhnNumber2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isLuhnNumber2(str) {
    (0, _assertString2.default)(str);
    var sanitized = str.replace(/[- ]+/g, "");
    var sum = 0;
    var digit;
    var tmpNum;
    var shouldDouble;
    for (var i = sanitized.length - 1; i >= 0; i--) {
      digit = sanitized.substring(i, i + 1);
      tmpNum = parseInt(digit, 10);
      if (shouldDouble) {
        tmpNum *= 2;
        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }
      shouldDouble = !shouldDouble;
    }
    return !!(sum % 10 === 0 ? sanitized : false);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLuhnNumber, isLuhnNumber.exports);
var isLuhnNumberExports = isLuhnNumber.exports;
var isCreditCard = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isLuhnNumber = _interopRequireDefault2(isLuhnNumberExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var cards = {
    amex: /^3[47][0-9]{13}$/,
    dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
    discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
    jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
    mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
    // /^[25][1-7][0-9]{14}$/;
    unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
    visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
  };
  var allCards = function() {
    var tmpCardsArray = [];
    for (var cardProvider in cards) {
      if (cards.hasOwnProperty(cardProvider)) {
        tmpCardsArray.push(cards[cardProvider]);
      }
    }
    return tmpCardsArray;
  }();
  function isCreditCard2(card) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _assertString2.default)(card);
    var provider = options.provider;
    var sanitized = card.replace(/[- ]+/g, "");
    if (provider && provider.toLowerCase() in cards) {
      if (!cards[provider.toLowerCase()].test(sanitized)) {
        return false;
      }
    } else if (provider && !(provider.toLowerCase() in cards)) {
      throw new Error("".concat(provider, " is not a valid credit card provider."));
    } else if (!allCards.some(function(cardProvider) {
      return cardProvider.test(sanitized);
    })) {
      return false;
    }
    return (0, _isLuhnNumber.default)(card);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isCreditCard, isCreditCard.exports);
var isCreditCardExports = isCreditCard.exports;
var isIdentityCard = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIdentityCard2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isInt = _interopRequireDefault2(isIntExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validators2 = {
    PL: function PL2(str) {
      (0, _assertString2.default)(str);
      var weightOfDigits = {
        1: 1,
        2: 3,
        3: 7,
        4: 9,
        5: 1,
        6: 3,
        7: 7,
        8: 9,
        9: 1,
        10: 3,
        11: 0
      };
      if (str != null && str.length === 11 && (0, _isInt.default)(str, {
        allow_leading_zeroes: true
      })) {
        var digits = str.split("").slice(0, -1);
        var sum = digits.reduce(function(acc, digit, index2) {
          return acc + Number(digit) * weightOfDigits[index2 + 1];
        }, 0);
        var modulo = sum % 10;
        var lastDigit = Number(str.charAt(str.length - 1));
        if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
          return true;
        }
      }
      return false;
    },
    ES: function ES2(str) {
      (0, _assertString2.default)(str);
      var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
      var charsValue = {
        X: 0,
        Y: 1,
        Z: 2
      };
      var controlDigits = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
      var sanitized = str.trim().toUpperCase();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var number2 = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function(char) {
        return charsValue[char];
      });
      return sanitized.endsWith(controlDigits[number2 % 23]);
    },
    FI: function FI2(str) {
      (0, _assertString2.default)(str);
      if (str.length !== 11) {
        return false;
      }
      if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
        return false;
      }
      var checkDigits = "0123456789ABCDEFHJKLMNPRSTUVWXY";
      var idAsNumber = parseInt(str.slice(0, 6), 10) * 1e3 + parseInt(str.slice(7, 10), 10);
      var remainder = idAsNumber % 31;
      var checkDigit = checkDigits[remainder];
      return checkDigit === str.slice(10, 11);
    },
    IN: function IN2(str) {
      var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;
      var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
      var p2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
      var sanitized = str.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var c = 0;
      var invertedArray = sanitized.replace(/\s/g, "").split("").map(Number).reverse();
      invertedArray.forEach(function(val, i) {
        c = d[c][p2[i % 8][val]];
      });
      return c === 0;
    },
    IR: function IR(str) {
      if (!str.match(/^\d{10}$/))
        return false;
      str = "0000".concat(str).slice(str.length - 6);
      if (parseInt(str.slice(3, 9), 10) === 0)
        return false;
      var lastNumber = parseInt(str.slice(9, 10), 10);
      var sum = 0;
      for (var i = 0; i < 9; i++) {
        sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
      }
      sum %= 11;
      return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
    },
    IT: function IT2(str) {
      if (str.length !== 9)
        return false;
      if (str === "CA00000AA")
        return false;
      return str.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1;
    },
    NO: function NO2(str) {
      var sanitized = str.trim();
      if (isNaN(Number(sanitized)))
        return false;
      if (sanitized.length !== 11)
        return false;
      if (sanitized === "00000000000")
        return false;
      var f2 = sanitized.split("").map(Number);
      var k1 = (11 - (3 * f2[0] + 7 * f2[1] + 6 * f2[2] + 1 * f2[3] + 8 * f2[4] + 9 * f2[5] + 4 * f2[6] + 5 * f2[7] + 2 * f2[8]) % 11) % 11;
      var k2 = (11 - (5 * f2[0] + 4 * f2[1] + 3 * f2[2] + 2 * f2[3] + 7 * f2[4] + 6 * f2[5] + 5 * f2[6] + 4 * f2[7] + 3 * f2[8] + 2 * k1) % 11) % 11;
      if (k1 !== f2[9] || k2 !== f2[10])
        return false;
      return true;
    },
    TH: function TH(str) {
      if (!str.match(/^[1-8]\d{12}$/))
        return false;
      var sum = 0;
      for (var i = 0; i < 12; i++) {
        sum += parseInt(str[i], 10) * (13 - i);
      }
      return str[12] === ((11 - sum % 11) % 10).toString();
    },
    LK: function LK(str) {
      var old_nic = /^[1-9]\d{8}[vx]$/i;
      var new_nic = /^[1-9]\d{11}$/i;
      if (str.length === 10 && old_nic.test(str))
        return true;
      else if (str.length === 12 && new_nic.test(str))
        return true;
      return false;
    },
    "he-IL": function heIL(str) {
      var DNI = /^\d{9}$/;
      var sanitized = str.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var id2 = sanitized;
      var sum = 0, incNum;
      for (var i = 0; i < id2.length; i++) {
        incNum = Number(id2[i]) * (i % 2 + 1);
        sum += incNum > 9 ? incNum - 9 : incNum;
      }
      return sum % 10 === 0;
    },
    "ar-LY": function arLY(str) {
      var NIN = /^(1|2)\d{11}$/;
      var sanitized = str.trim();
      if (!NIN.test(sanitized)) {
        return false;
      }
      return true;
    },
    "ar-TN": function arTN(str) {
      var DNI = /^\d{8}$/;
      var sanitized = str.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      return true;
    },
    "zh-CN": function zhCN(str) {
      var provincesAndCities = [
        "11",
        // 
        "12",
        // 
        "13",
        // 
        "14",
        // 
        "15",
        // 
        "21",
        // 
        "22",
        // 
        "23",
        // 
        "31",
        // 
        "32",
        // 
        "33",
        // 
        "34",
        // 
        "35",
        // 
        "36",
        // 
        "37",
        // 
        "41",
        // 
        "42",
        // 
        "43",
        // 
        "44",
        // 
        "45",
        // 
        "46",
        // 
        "50",
        // 
        "51",
        // 
        "52",
        // 
        "53",
        // 
        "54",
        // 
        "61",
        // 
        "62",
        // 
        "63",
        // 
        "64",
        // 
        "65",
        // 
        "71",
        // 
        "81",
        // 
        "82",
        // 
        "91"
        // 
      ];
      var powers = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"];
      var parityBit = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
      var checkAddressCode = function checkAddressCode2(addressCode) {
        return provincesAndCities.includes(addressCode);
      };
      var checkBirthDayCode = function checkBirthDayCode2(birDayCode) {
        var yyyy = parseInt(birDayCode.substring(0, 4), 10);
        var mm = parseInt(birDayCode.substring(4, 6), 10);
        var dd2 = parseInt(birDayCode.substring(6), 10);
        var xdata = new Date(yyyy, mm - 1, dd2);
        if (xdata > /* @__PURE__ */ new Date()) {
          return false;
        } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd2) {
          return true;
        }
        return false;
      };
      var getParityBit = function getParityBit2(idCardNo) {
        var id17 = idCardNo.substring(0, 17);
        var power = 0;
        for (var i = 0; i < 17; i++) {
          power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
        }
        var mod2 = power % 11;
        return parityBit[mod2];
      };
      var checkParityBit = function checkParityBit2(idCardNo) {
        return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
      };
      var check15IdCardNo = function check15IdCardNo2(idCardNo) {
        var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
        if (!check)
          return false;
        var addressCode = idCardNo.substring(0, 2);
        check = checkAddressCode(addressCode);
        if (!check)
          return false;
        var birDayCode = "19".concat(idCardNo.substring(6, 12));
        check = checkBirthDayCode(birDayCode);
        if (!check)
          return false;
        return true;
      };
      var check18IdCardNo = function check18IdCardNo2(idCardNo) {
        var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
        if (!check)
          return false;
        var addressCode = idCardNo.substring(0, 2);
        check = checkAddressCode(addressCode);
        if (!check)
          return false;
        var birDayCode = idCardNo.substring(6, 14);
        check = checkBirthDayCode(birDayCode);
        if (!check)
          return false;
        return checkParityBit(idCardNo);
      };
      var checkIdCardNo = function checkIdCardNo2(idCardNo) {
        var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
        if (!check)
          return false;
        if (idCardNo.length === 15) {
          return check15IdCardNo(idCardNo);
        }
        return check18IdCardNo(idCardNo);
      };
      return checkIdCardNo(str);
    },
    "zh-HK": function zhHK(str) {
      str = str.trim();
      var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
      var regexIsDigit = /^[0-9]$/;
      str = str.toUpperCase();
      if (!regexHKID.test(str))
        return false;
      str = str.replace(/\[|\]|\(|\)/g, "");
      if (str.length === 8)
        str = "3".concat(str);
      var checkSumVal = 0;
      for (var i = 0; i <= 7; i++) {
        var convertedChar = void 0;
        if (!regexIsDigit.test(str[i]))
          convertedChar = (str[i].charCodeAt(0) - 55) % 11;
        else
          convertedChar = str[i];
        checkSumVal += convertedChar * (9 - i);
      }
      checkSumVal %= 11;
      var checkSumConverted;
      if (checkSumVal === 0)
        checkSumConverted = "0";
      else if (checkSumVal === 1)
        checkSumConverted = "A";
      else
        checkSumConverted = String(11 - checkSumVal);
      if (checkSumConverted === str[str.length - 1])
        return true;
      return false;
    },
    "zh-TW": function zhTW(str) {
      var ALPHABET_CODES = {
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        G: 16,
        H: 17,
        I: 34,
        J: 18,
        K: 19,
        L: 20,
        M: 21,
        N: 22,
        O: 35,
        P: 23,
        Q: 24,
        R: 25,
        S: 26,
        T: 27,
        U: 28,
        V: 29,
        W: 32,
        X: 30,
        Y: 31,
        Z: 33
      };
      var sanitized = str.trim().toUpperCase();
      if (!/^[A-Z][0-9]{9}$/.test(sanitized))
        return false;
      return Array.from(sanitized).reduce(function(sum, number2, index2) {
        if (index2 === 0) {
          var code2 = ALPHABET_CODES[number2];
          return code2 % 10 * 9 + Math.floor(code2 / 10);
        }
        if (index2 === 9) {
          return (10 - sum % 10 - Number(number2)) % 10 === 0;
        }
        return sum + Number(number2) * (9 - index2);
      }, 0);
    }
  };
  function isIdentityCard2(str, locale) {
    (0, _assertString2.default)(str);
    if (locale in validators2) {
      return validators2[locale](str);
    } else if (locale === "any") {
      for (var key in validators2) {
        if (validators2.hasOwnProperty(key)) {
          var validator2 = validators2[key];
          if (validator2(str)) {
            return true;
          }
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIdentityCard, isIdentityCard.exports);
var isIdentityCardExports = isIdentityCard.exports;
var isEAN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEAN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var LENGTH_EAN_8 = 8;
  var LENGTH_EAN_14 = 14;
  var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;
  function getPositionWeightThroughLengthAndIndex(length, index2) {
    if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
      return index2 % 2 === 0 ? 3 : 1;
    }
    return index2 % 2 === 0 ? 1 : 3;
  }
  function calculateCheckDigit(ean) {
    var checksum2 = ean.slice(0, -1).split("").map(function(char, index2) {
      return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index2);
    }).reduce(function(acc, partialSum) {
      return acc + partialSum;
    }, 0);
    var remainder = 10 - checksum2 % 10;
    return remainder < 10 ? remainder : 0;
  }
  function isEAN2(str) {
    (0, _assertString2.default)(str);
    var actualCheckDigit = Number(str.slice(-1));
    return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEAN, isEAN.exports);
var isEANExports = isEAN.exports;
var isISIN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISIN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
  function isISIN2(str) {
    (0, _assertString2.default)(str);
    if (!isin.test(str)) {
      return false;
    }
    var double = true;
    var sum = 0;
    for (var i = str.length - 2; i >= 0; i--) {
      if (str[i] >= "A" && str[i] <= "Z") {
        var value = str[i].charCodeAt(0) - 55;
        var lo = value % 10;
        var hi2 = Math.trunc(value / 10);
        for (var _i2 = 0, _arr = [lo, hi2]; _i2 < _arr.length; _i2++) {
          var digit = _arr[_i2];
          if (double) {
            if (digit >= 5) {
              sum += 1 + (digit - 5) * 2;
            } else {
              sum += digit * 2;
            }
          } else {
            sum += digit;
          }
          double = !double;
        }
      } else {
        var _digit = str[i].charCodeAt(0) - "0".charCodeAt(0);
        if (double) {
          if (_digit >= 5) {
            sum += 1 + (_digit - 5) * 2;
          } else {
            sum += _digit * 2;
          }
        } else {
          sum += _digit;
        }
        double = !double;
      }
    }
    var check = Math.trunc((sum + 9) / 10) * 10 - sum;
    return +str[str.length - 1] === check;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISIN, isISIN.exports);
var isISINExports = isISIN.exports;
var isISBN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISBN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
  var possibleIsbn13 = /^(?:[0-9]{13})$/;
  var factor = [1, 3];
  function isISBN2(isbn, options) {
    (0, _assertString2.default)(isbn);
    var version2 = String((options === null || options === void 0 ? void 0 : options.version) || options);
    if (!(options !== null && options !== void 0 && options.version || options)) {
      return isISBN2(isbn, {
        version: 10
      }) || isISBN2(isbn, {
        version: 13
      });
    }
    var sanitizedIsbn = isbn.replace(/[\s-]+/g, "");
    var checksum2 = 0;
    if (version2 === "10") {
      if (!possibleIsbn10.test(sanitizedIsbn)) {
        return false;
      }
      for (var i = 0; i < version2 - 1; i++) {
        checksum2 += (i + 1) * sanitizedIsbn.charAt(i);
      }
      if (sanitizedIsbn.charAt(9) === "X") {
        checksum2 += 10 * 10;
      } else {
        checksum2 += 10 * sanitizedIsbn.charAt(9);
      }
      if (checksum2 % 11 === 0) {
        return true;
      }
    } else if (version2 === "13") {
      if (!possibleIsbn13.test(sanitizedIsbn)) {
        return false;
      }
      for (var _i2 = 0; _i2 < 12; _i2++) {
        checksum2 += factor[_i2 % 2] * sanitizedIsbn.charAt(_i2);
      }
      if (sanitizedIsbn.charAt(12) - (10 - checksum2 % 10) % 10 === 0) {
        return true;
      }
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISBN, isISBN.exports);
var isISBNExports = isISBN.exports;
var isISSN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISSN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var issn = "^\\d{4}-?\\d{3}[\\dX]$";
  function isISSN2(str) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _assertString2.default)(str);
    var testIssn = issn;
    testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn;
    testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
    if (!testIssn.test(str)) {
      return false;
    }
    var digits = str.replace("-", "").toUpperCase();
    var checksum2 = 0;
    for (var i = 0; i < digits.length; i++) {
      var digit = digits[i];
      checksum2 += (digit === "X" ? 10 : +digit) * (8 - i);
    }
    return checksum2 % 11 === 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISSN, isISSN.exports);
var isISSNExports = isISSN.exports;
var isTaxID = { exports: {} };
var algorithms$1 = {};
Object.defineProperty(algorithms$1, "__esModule", {
  value: true
});
algorithms$1.iso7064Check = iso7064Check;
algorithms$1.luhnCheck = luhnCheck;
algorithms$1.reverseMultiplyAndSum = reverseMultiplyAndSum;
algorithms$1.verhoeffCheck = verhoeffCheck;
function iso7064Check(str) {
  var checkvalue = 10;
  for (var i = 0; i < str.length - 1; i++) {
    checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;
  }
  checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
  return checkvalue === parseInt(str[10], 10);
}
function luhnCheck(str) {
  var checksum2 = 0;
  var second = false;
  for (var i = str.length - 1; i >= 0; i--) {
    if (second) {
      var product = parseInt(str[i], 10) * 2;
      if (product > 9) {
        checksum2 += product.toString().split("").map(function(a) {
          return parseInt(a, 10);
        }).reduce(function(a, b2) {
          return a + b2;
        }, 0);
      } else {
        checksum2 += product;
      }
    } else {
      checksum2 += parseInt(str[i], 10);
    }
    second = !second;
  }
  return checksum2 % 10 === 0;
}
function reverseMultiplyAndSum(digits, base2) {
  var total = 0;
  for (var i = 0; i < digits.length; i++) {
    total += digits[i] * (base2 - i);
  }
  return total;
}
function verhoeffCheck(str) {
  var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
  var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
  var str_copy = str.split("").reverse().join("");
  var checksum2 = 0;
  for (var i = 0; i < str_copy.length; i++) {
    checksum2 = d_table[checksum2][p_table[i % 8][parseInt(str_copy[i], 10)]];
  }
  return checksum2 === 0;
}
(function(module, exports) {
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTaxID2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var algorithms2 = _interopRequireWildcard2(algorithms$1);
  var _isDate = _interopRequireDefault2(isDateExports);
  function _getRequireWildcardCache2(e2) {
    if ("function" != typeof WeakMap)
      return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(e3) {
      return e3 ? t2 : r2;
    })(e2);
  }
  function _interopRequireWildcard2(e2, r2) {
    if (!r2 && e2 && e2.__esModule)
      return e2;
    if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2)
      return { default: e2 };
    var t2 = _getRequireWildcardCache2(r2);
    if (t2 && t2.has(e2))
      return t2.get(e2);
    var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u2 in e2)
      if ("default" !== u2 && {}.hasOwnProperty.call(e2, u2)) {
        var i = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
        i && (i.get || i.set) ? Object.defineProperty(n2, u2, i) : n2[u2] = e2[u2];
      }
    return n2.default = e2, t2 && t2.set(e2, n2), n2;
  }
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function bgBgCheck(tin) {
    var century_year = tin.slice(0, 2);
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 40) {
      month -= 40;
      century_year = "20".concat(century_year);
    } else if (month > 20) {
      month -= 20;
      century_year = "18".concat(century_year);
    } else {
      century_year = "19".concat(century_year);
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
    var checksum2 = 0;
    for (var i = 0; i < multip_lookup.length; i++) {
      checksum2 += digits[i] * multip_lookup[i];
    }
    checksum2 = checksum2 % 11 === 10 ? 0 : checksum2 % 11;
    return checksum2 === digits[9];
  }
  function isCanadianSIN(input) {
    var digitsArray = input.split("");
    var even = digitsArray.filter(function(_, idx) {
      return idx % 2;
    }).map(function(i) {
      return Number(i) * 2;
    }).join("").split("");
    var total = digitsArray.filter(function(_, idx) {
      return !(idx % 2);
    }).concat(even).map(function(i) {
      return Number(i);
    }).reduce(function(acc, cur) {
      return acc + cur;
    });
    return total % 10 === 0;
  }
  function csCzCheck(tin) {
    tin = tin.replace(/\W/, "");
    var full_year = parseInt(tin.slice(0, 2), 10);
    if (tin.length === 10) {
      if (full_year < 54) {
        full_year = "20".concat(full_year);
      } else {
        full_year = "19".concat(full_year);
      }
    } else {
      if (tin.slice(6) === "000") {
        return false;
      }
      if (full_year < 54) {
        full_year = "19".concat(full_year);
      } else {
        return false;
      }
    }
    if (full_year.length === 3) {
      full_year = [full_year.slice(0, 2), "0", full_year.slice(2)].join("");
    }
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 50) {
      month -= 50;
    }
    if (month > 20) {
      if (parseInt(full_year, 10) < 2004) {
        return false;
      }
      month -= 20;
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    if (tin.length === 10) {
      if (parseInt(tin, 10) % 11 !== 0) {
        var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
        if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
          if (parseInt(tin.slice(9), 10) !== 0) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  }
  function deAtCheck(tin) {
    return algorithms2.luhnCheck(tin);
  }
  function deDeCheck(tin) {
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var occurences = [];
    for (var i = 0; i < digits.length - 1; i++) {
      occurences.push("");
      for (var j = 0; j < digits.length - 1; j++) {
        if (digits[i] === digits[j]) {
          occurences[i] += j;
        }
      }
    }
    occurences = occurences.filter(function(a) {
      return a.length > 1;
    });
    if (occurences.length !== 2 && occurences.length !== 3) {
      return false;
    }
    if (occurences[0].length === 3) {
      var trip_locations = occurences[0].split("").map(function(a) {
        return parseInt(a, 10);
      });
      var recurrent = 0;
      for (var _i2 = 0; _i2 < trip_locations.length - 1; _i2++) {
        if (trip_locations[_i2] + 1 === trip_locations[_i2 + 1]) {
          recurrent += 1;
        }
      }
      if (recurrent === 2) {
        return false;
      }
    }
    return algorithms2.iso7064Check(tin);
  }
  function dkDkCheck(tin) {
    tin = tin.replace(/\W/, "");
    var year = parseInt(tin.slice(4, 6), 10);
    var century_digit = tin.slice(6, 7);
    switch (century_digit) {
      case "0":
      case "1":
      case "2":
      case "3":
        year = "19".concat(year);
        break;
      case "4":
      case "9":
        if (year < 37) {
          year = "20".concat(year);
        } else {
          year = "19".concat(year);
        }
        break;
      default:
        if (year < 37) {
          year = "20".concat(year);
        } else if (year > 58) {
          year = "18".concat(year);
        } else {
          return false;
        }
        break;
    }
    if (year.length === 3) {
      year = [year.slice(0, 2), "0", year.slice(2)].join("");
    }
    var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum2 = 0;
    var weight = 4;
    for (var i = 0; i < 9; i++) {
      checksum2 += digits[i] * weight;
      weight -= 1;
      if (weight === 1) {
        weight = 7;
      }
    }
    checksum2 %= 11;
    if (checksum2 === 1) {
      return false;
    }
    return checksum2 === 0 ? digits[9] === 0 : digits[9] === 11 - checksum2;
  }
  function elCyCheck(tin) {
    var digits = tin.slice(0, 8).split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum2 = 0;
    for (var i = 1; i < digits.length; i += 2) {
      checksum2 += digits[i];
    }
    for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {
      if (digits[_i2] < 2) {
        checksum2 += 1 - digits[_i2];
      } else {
        checksum2 += 2 * (digits[_i2] - 2) + 5;
        if (digits[_i2] > 4) {
          checksum2 += 2;
        }
      }
    }
    return String.fromCharCode(checksum2 % 26 + 65) === tin.charAt(8);
  }
  function elGrCheck(tin) {
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum2 = 0;
    for (var i = 0; i < 8; i++) {
      checksum2 += digits[i] * Math.pow(2, 8 - i);
    }
    return checksum2 % 11 % 10 === digits[8];
  }
  function enIeCheck(tin) {
    var checksum2 = algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
      return parseInt(a, 10);
    }), 8);
    if (tin.length === 9 && tin[8] !== "W") {
      checksum2 += (tin[8].charCodeAt(0) - 64) * 9;
    }
    checksum2 %= 23;
    if (checksum2 === 0) {
      return tin[7].toUpperCase() === "W";
    }
    return tin[7].toUpperCase() === String.fromCharCode(64 + checksum2);
  }
  var enUsCampusPrefix = {
    andover: ["10", "12"],
    atlanta: ["60", "67"],
    austin: ["50", "53"],
    brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
    cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
    fresno: ["15", "24"],
    internet: ["20", "26", "27", "45", "46", "47"],
    kansas: ["40", "44"],
    memphis: ["94", "95"],
    ogden: ["80", "90"],
    philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
    sba: ["31"]
  };
  function enUsGetPrefixes() {
    var prefixes = [];
    for (var location2 in enUsCampusPrefix) {
      if (enUsCampusPrefix.hasOwnProperty(location2)) {
        prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location2]));
      }
    }
    return prefixes;
  }
  function enUsCheck(tin) {
    return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
  }
  function esArCheck(tin) {
    var accum = 0;
    var digits = tin.split("");
    var digit = parseInt(digits.pop(), 10);
    for (var i = 0; i < digits.length; i++) {
      accum += digits[9 - i] * (2 + i % 6);
    }
    var verif = 11 - accum % 11;
    if (verif === 11) {
      verif = 0;
    } else if (verif === 10) {
      verif = 9;
    }
    return digit === verif;
  }
  function esEsCheck(tin) {
    var chars = tin.toUpperCase().split("");
    if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
      var lead_replace = 0;
      switch (chars[0]) {
        case "Y":
          lead_replace = 1;
          break;
        case "Z":
          lead_replace = 2;
          break;
      }
      chars.splice(0, 1, lead_replace);
    } else {
      while (chars.length < 9) {
        chars.unshift(0);
      }
    }
    var lookup2 = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
    chars = chars.join("");
    var checksum2 = parseInt(chars.slice(0, 8), 10) % 23;
    return chars[8] === lookup2[checksum2];
  }
  function etEeCheck(tin) {
    var full_year = tin.slice(1, 3);
    var century_digit = tin.slice(0, 1);
    switch (century_digit) {
      case "1":
      case "2":
        full_year = "18".concat(full_year);
        break;
      case "3":
      case "4":
        full_year = "19".concat(full_year);
        break;
      default:
        full_year = "20".concat(full_year);
        break;
    }
    var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum2 = 0;
    var weight = 1;
    for (var i = 0; i < 10; i++) {
      checksum2 += digits[i] * weight;
      weight += 1;
      if (weight === 10) {
        weight = 1;
      }
    }
    if (checksum2 % 11 === 10) {
      checksum2 = 0;
      weight = 3;
      for (var _i3 = 0; _i3 < 10; _i3++) {
        checksum2 += digits[_i3] * weight;
        weight += 1;
        if (weight === 10) {
          weight = 1;
        }
      }
      if (checksum2 % 11 === 10) {
        return digits[10] === 0;
      }
    }
    return checksum2 % 11 === digits[10];
  }
  function fiFiCheck(tin) {
    var full_year = tin.slice(4, 6);
    var century_symbol = tin.slice(6, 7);
    switch (century_symbol) {
      case "+":
        full_year = "18".concat(full_year);
        break;
      case "-":
        full_year = "19".concat(full_year);
        break;
      default:
        full_year = "20".concat(full_year);
        break;
    }
    var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var checksum2 = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
    if (checksum2 < 10) {
      return checksum2 === parseInt(tin.slice(10), 10);
    }
    checksum2 -= 10;
    var letters_lookup = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
    return letters_lookup[checksum2] === tin.slice(10);
  }
  function frBeCheck(tin) {
    if (tin.slice(2, 4) !== "00" || tin.slice(4, 6) !== "00") {
      var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YY/MM/DD")) {
        return false;
      }
    }
    var checksum2 = 97 - parseInt(tin.slice(0, 9), 10) % 97;
    var checkdigits = parseInt(tin.slice(9, 11), 10);
    if (checksum2 !== checkdigits) {
      checksum2 = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
      if (checksum2 !== checkdigits) {
        return false;
      }
    }
    return true;
  }
  function frFrCheck(tin) {
    tin = tin.replace(/\s/g, "");
    var checksum2 = parseInt(tin.slice(0, 10), 10) % 511;
    var checkdigits = parseInt(tin.slice(10, 13), 10);
    return checksum2 === checkdigits;
  }
  function frLuCheck(tin) {
    var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    if (!algorithms2.luhnCheck(tin.slice(0, 12))) {
      return false;
    }
    return algorithms2.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
  }
  function hrHrCheck(tin) {
    return algorithms2.iso7064Check(tin);
  }
  function huHuCheck(tin) {
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum2 = 8;
    for (var i = 1; i < 9; i++) {
      checksum2 += digits[i] * (i + 1);
    }
    return checksum2 % 11 === digits[9];
  }
  function itItNameCheck(name) {
    var vowelflag = false;
    var xflag = false;
    for (var i = 0; i < 3; i++) {
      if (!vowelflag && /[AEIOU]/.test(name[i])) {
        vowelflag = true;
      } else if (!xflag && vowelflag && name[i] === "X") {
        xflag = true;
      } else if (i > 0) {
        if (vowelflag && !xflag) {
          if (!/[AEIOU]/.test(name[i])) {
            return false;
          }
        }
        if (xflag) {
          if (!/X/.test(name[i])) {
            return false;
          }
        }
      }
    }
    return true;
  }
  function itItCheck(tin) {
    var chars = tin.toUpperCase().split("");
    if (!itItNameCheck(chars.slice(0, 3))) {
      return false;
    }
    if (!itItNameCheck(chars.slice(3, 6))) {
      return false;
    }
    var number_locations = [6, 7, 9, 10, 12, 13, 14];
    var number_replace = {
      L: "0",
      M: "1",
      N: "2",
      P: "3",
      Q: "4",
      R: "5",
      S: "6",
      T: "7",
      U: "8",
      V: "9"
    };
    for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
      var i = _number_locations[_i4];
      if (chars[i] in number_replace) {
        chars.splice(i, 1, number_replace[chars[i]]);
      }
    }
    var month_replace = {
      A: "01",
      B: "02",
      C: "03",
      D: "04",
      E: "05",
      H: "06",
      L: "07",
      M: "08",
      P: "09",
      R: "10",
      S: "11",
      T: "12"
    };
    var month = month_replace[chars[8]];
    var day = parseInt(chars[9] + chars[10], 10);
    if (day > 40) {
      day -= 40;
    }
    if (day < 10) {
      day = "0".concat(day);
    }
    var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
    if (!(0, _isDate.default)(date, "YY/MM/DD")) {
      return false;
    }
    var checksum2 = 0;
    for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
      var char_to_int = parseInt(chars[_i5], 10);
      if (isNaN(char_to_int)) {
        char_to_int = chars[_i5].charCodeAt(0) - 65;
      }
      checksum2 += char_to_int;
    }
    var odd_convert = {
      // Maps of characters at odd places
      A: 1,
      B: 0,
      C: 5,
      D: 7,
      E: 9,
      F: 13,
      G: 15,
      H: 17,
      I: 19,
      J: 21,
      K: 2,
      L: 4,
      M: 18,
      N: 20,
      O: 11,
      P: 3,
      Q: 6,
      R: 8,
      S: 12,
      T: 14,
      U: 16,
      V: 10,
      W: 22,
      X: 25,
      Y: 24,
      Z: 23,
      0: 1,
      1: 0
    };
    for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
      var _char_to_int = 0;
      if (chars[_i6] in odd_convert) {
        _char_to_int = odd_convert[chars[_i6]];
      } else {
        var multiplier = parseInt(chars[_i6], 10);
        _char_to_int = 2 * multiplier + 1;
        if (multiplier > 4) {
          _char_to_int += 2;
        }
      }
      checksum2 += _char_to_int;
    }
    if (String.fromCharCode(65 + checksum2 % 26) !== chars[15]) {
      return false;
    }
    return true;
  }
  function lvLvCheck(tin) {
    tin = tin.replace(/\W/, "");
    var day = tin.slice(0, 2);
    if (day !== "32") {
      var month = tin.slice(2, 4);
      if (month !== "00") {
        var full_year = tin.slice(4, 6);
        switch (tin[6]) {
          case "0":
            full_year = "18".concat(full_year);
            break;
          case "1":
            full_year = "19".concat(full_year);
            break;
          default:
            full_year = "20".concat(full_year);
            break;
        }
        var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
      }
      var checksum2 = 1101;
      var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
      for (var i = 0; i < tin.length - 1; i++) {
        checksum2 -= parseInt(tin[i], 10) * multip_lookup[i];
      }
      return parseInt(tin[10], 10) === checksum2 % 11;
    }
    return true;
  }
  function mtMtCheck(tin) {
    if (tin.length !== 9) {
      var chars = tin.toUpperCase().split("");
      while (chars.length < 8) {
        chars.unshift(0);
      }
      switch (tin[7]) {
        case "A":
        case "P":
          if (parseInt(chars[6], 10) === 0) {
            return false;
          }
          break;
        default: {
          var first_part = parseInt(chars.join("").slice(0, 5), 10);
          if (first_part > 32e3) {
            return false;
          }
          var second_part = parseInt(chars.join("").slice(5, 7), 10);
          if (first_part === second_part) {
            return false;
          }
        }
      }
    }
    return true;
  }
  function nlNlCheck(tin) {
    return algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
      return parseInt(a, 10);
    }), 9) % 11 === parseInt(tin[8], 10);
  }
  function plPlCheck(tin) {
    if (tin.length === 10) {
      var lookup2 = [6, 5, 7, 2, 3, 4, 5, 6, 7];
      var _checksum2 = 0;
      for (var i = 0; i < lookup2.length; i++) {
        _checksum2 += parseInt(tin[i], 10) * lookup2[i];
      }
      _checksum2 %= 11;
      if (_checksum2 === 10) {
        return false;
      }
      return _checksum2 === parseInt(tin[9], 10);
    }
    var full_year = tin.slice(0, 2);
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 80) {
      full_year = "18".concat(full_year);
      month -= 80;
    } else if (month > 60) {
      full_year = "22".concat(full_year);
      month -= 60;
    } else if (month > 40) {
      full_year = "21".concat(full_year);
      month -= 40;
    } else if (month > 20) {
      full_year = "20".concat(full_year);
      month -= 20;
    } else {
      full_year = "19".concat(full_year);
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var checksum2 = 0;
    var multiplier = 1;
    for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
      checksum2 += parseInt(tin[_i7], 10) * multiplier % 10;
      multiplier += 2;
      if (multiplier > 10) {
        multiplier = 1;
      } else if (multiplier === 5) {
        multiplier += 2;
      }
    }
    checksum2 = 10 - checksum2 % 10;
    return checksum2 === parseInt(tin[10], 10);
  }
  function ptBrCheck(tin) {
    if (tin.length === 11) {
      var _sum;
      var remainder;
      _sum = 0;
      if (
        // Reject known invalid CPFs
        tin === "11111111111" || tin === "22222222222" || tin === "33333333333" || tin === "44444444444" || tin === "55555555555" || tin === "66666666666" || tin === "77777777777" || tin === "88888888888" || tin === "99999999999" || tin === "00000000000"
      )
        return false;
      for (var i = 1; i <= 9; i++)
        _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
      remainder = _sum * 10 % 11;
      if (remainder === 10)
        remainder = 0;
      if (remainder !== parseInt(tin.substring(9, 10), 10))
        return false;
      _sum = 0;
      for (var _i8 = 1; _i8 <= 10; _i8++)
        _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
      remainder = _sum * 10 % 11;
      if (remainder === 10)
        remainder = 0;
      if (remainder !== parseInt(tin.substring(10, 11), 10))
        return false;
      return true;
    }
    if (
      // Reject know invalid CNPJs
      tin === "00000000000000" || tin === "11111111111111" || tin === "22222222222222" || tin === "33333333333333" || tin === "44444444444444" || tin === "55555555555555" || tin === "66666666666666" || tin === "77777777777777" || tin === "88888888888888" || tin === "99999999999999"
    ) {
      return false;
    }
    var length = tin.length - 2;
    var identifiers = tin.substring(0, length);
    var verificators = tin.substring(length);
    var sum = 0;
    var pos = length - 7;
    for (var _i9 = length; _i9 >= 1; _i9--) {
      sum += identifiers.charAt(length - _i9) * pos;
      pos -= 1;
      if (pos < 2) {
        pos = 9;
      }
    }
    var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
    if (result !== parseInt(verificators.charAt(0), 10)) {
      return false;
    }
    length += 1;
    identifiers = tin.substring(0, length);
    sum = 0;
    pos = length - 7;
    for (var _i10 = length; _i10 >= 1; _i10--) {
      sum += identifiers.charAt(length - _i10) * pos;
      pos -= 1;
      if (pos < 2) {
        pos = 9;
      }
    }
    result = sum % 11 < 2 ? 0 : 11 - sum % 11;
    if (result !== parseInt(verificators.charAt(1), 10)) {
      return false;
    }
    return true;
  }
  function ptPtCheck(tin) {
    var checksum2 = 11 - algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
      return parseInt(a, 10);
    }), 9) % 11;
    if (checksum2 > 9) {
      return parseInt(tin[8], 10) === 0;
    }
    return checksum2 === parseInt(tin[8], 10);
  }
  function roRoCheck(tin) {
    if (tin.slice(0, 4) !== "9000") {
      var full_year = tin.slice(1, 3);
      switch (tin[0]) {
        case "1":
        case "2":
          full_year = "19".concat(full_year);
          break;
        case "3":
        case "4":
          full_year = "18".concat(full_year);
          break;
        case "5":
        case "6":
          full_year = "20".concat(full_year);
          break;
      }
      var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
      if (date.length === 8) {
        if (!(0, _isDate.default)(date, "YY/MM/DD")) {
          return false;
        }
      } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
      var checksum2 = 0;
      for (var i = 0; i < multipliers.length; i++) {
        checksum2 += digits[i] * multipliers[i];
      }
      if (checksum2 % 11 === 10) {
        return digits[12] === 1;
      }
      return digits[12] === checksum2 % 11;
    }
    return true;
  }
  function skSkCheck(tin) {
    if (tin.length === 9) {
      tin = tin.replace(/\W/, "");
      if (tin.slice(6) === "000") {
        return false;
      }
      var full_year = parseInt(tin.slice(0, 2), 10);
      if (full_year > 53) {
        return false;
      }
      if (full_year < 10) {
        full_year = "190".concat(full_year);
      } else {
        full_year = "19".concat(full_year);
      }
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 50) {
        month -= 50;
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
    }
    return true;
  }
  function slSiCheck(tin) {
    var checksum2 = 11 - algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
      return parseInt(a, 10);
    }), 8) % 11;
    if (checksum2 === 10) {
      return parseInt(tin[7], 10) === 0;
    }
    return checksum2 === parseInt(tin[7], 10);
  }
  function svSeCheck(tin) {
    var tin_copy = tin.slice(0);
    if (tin.length > 11) {
      tin_copy = tin_copy.slice(2);
    }
    var full_year = "";
    var month = tin_copy.slice(2, 4);
    var day = parseInt(tin_copy.slice(4, 6), 10);
    if (tin.length > 11) {
      full_year = tin.slice(0, 4);
    } else {
      full_year = tin.slice(0, 2);
      if (tin.length === 11 && day < 60) {
        var current_year = (/* @__PURE__ */ new Date()).getFullYear().toString();
        var current_century = parseInt(current_year.slice(0, 2), 10);
        current_year = parseInt(current_year, 10);
        if (tin[6] === "-") {
          if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
            full_year = "".concat(current_century - 1).concat(full_year);
          } else {
            full_year = "".concat(current_century).concat(full_year);
          }
        } else {
          full_year = "".concat(current_century - 1).concat(full_year);
          if (current_year - parseInt(full_year, 10) < 100) {
            return false;
          }
        }
      }
    }
    if (day > 60) {
      day -= 60;
    }
    if (day < 10) {
      day = "0".concat(day);
    }
    var date = "".concat(full_year, "/").concat(month, "/").concat(day);
    if (date.length === 8) {
      if (!(0, _isDate.default)(date, "YY/MM/DD")) {
        return false;
      }
    } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    return algorithms2.luhnCheck(tin.replace(/\W/, ""));
  }
  function ukUaCheck(tin) {
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
    var checksum2 = 0;
    for (var i = 0; i < multipliers.length; i++) {
      checksum2 += digits[i] * multipliers[i];
    }
    return checksum2 % 11 === 10 ? digits[9] === 0 : digits[9] === checksum2 % 11;
  }
  var taxIdFormat = {
    "bg-BG": /^\d{10}$/,
    "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
    "de-AT": /^\d{9}$/,
    "de-DE": /^[1-9]\d{10}$/,
    "dk-DK": /^\d{6}-{0,1}\d{4}$/,
    "el-CY": /^[09]\d{7}[A-Z]$/,
    "el-GR": /^([0-4]|[7-9])\d{8}$/,
    "en-CA": /^\d{9}$/,
    "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
    "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
    "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
    "es-AR": /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
    "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
    "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
    "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
    "fr-BE": /^\d{11}$/,
    "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
    // Conforms both to official spec and provided example
    "fr-LU": /^\d{13}$/,
    "hr-HR": /^\d{11}$/,
    "hu-HU": /^8\d{9}$/,
    "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
    "lv-LV": /^\d{6}-{0,1}\d{5}$/,
    // Conforms both to DG TAXUD spec and original research
    "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
    "nl-NL": /^\d{9}$/,
    "pl-PL": /^\d{10,11}$/,
    "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
    "pt-PT": /^\d{9}$/,
    "ro-RO": /^\d{13}$/,
    "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
    "sl-SI": /^[1-9]\d{7}$/,
    "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
    "uk-UA": /^\d{10}$/
  };
  taxIdFormat["lb-LU"] = taxIdFormat["fr-LU"];
  taxIdFormat["lt-LT"] = taxIdFormat["et-EE"];
  taxIdFormat["nl-BE"] = taxIdFormat["fr-BE"];
  taxIdFormat["fr-CA"] = taxIdFormat["en-CA"];
  var taxIdCheck = {
    "bg-BG": bgBgCheck,
    "cs-CZ": csCzCheck,
    "de-AT": deAtCheck,
    "de-DE": deDeCheck,
    "dk-DK": dkDkCheck,
    "el-CY": elCyCheck,
    "el-GR": elGrCheck,
    "en-CA": isCanadianSIN,
    "en-IE": enIeCheck,
    "en-US": enUsCheck,
    "es-AR": esArCheck,
    "es-ES": esEsCheck,
    "et-EE": etEeCheck,
    "fi-FI": fiFiCheck,
    "fr-BE": frBeCheck,
    "fr-FR": frFrCheck,
    "fr-LU": frLuCheck,
    "hr-HR": hrHrCheck,
    "hu-HU": huHuCheck,
    "it-IT": itItCheck,
    "lv-LV": lvLvCheck,
    "mt-MT": mtMtCheck,
    "nl-NL": nlNlCheck,
    "pl-PL": plPlCheck,
    "pt-BR": ptBrCheck,
    "pt-PT": ptPtCheck,
    "ro-RO": roRoCheck,
    "sk-SK": skSkCheck,
    "sl-SI": slSiCheck,
    "sv-SE": svSeCheck,
    "uk-UA": ukUaCheck
  };
  taxIdCheck["lb-LU"] = taxIdCheck["fr-LU"];
  taxIdCheck["lt-LT"] = taxIdCheck["et-EE"];
  taxIdCheck["nl-BE"] = taxIdCheck["fr-BE"];
  taxIdCheck["fr-CA"] = taxIdCheck["en-CA"];
  var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
  var sanitizeRegexes = {
    "de-AT": allsymbols,
    "de-DE": /[\/\\]/g,
    "fr-BE": allsymbols
  };
  sanitizeRegexes["nl-BE"] = sanitizeRegexes["fr-BE"];
  function isTaxID2(str) {
    var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
    (0, _assertString2.default)(str);
    var strcopy = str.slice(0);
    if (locale in taxIdFormat) {
      if (locale in sanitizeRegexes) {
        strcopy = strcopy.replace(sanitizeRegexes[locale], "");
      }
      if (!taxIdFormat[locale].test(strcopy)) {
        return false;
      }
      if (locale in taxIdCheck) {
        return taxIdCheck[locale](strcopy);
      }
      return true;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isTaxID, isTaxID.exports);
var isTaxIDExports = isTaxID.exports;
var isMobilePhone$1 = {};
Object.defineProperty(isMobilePhone$1, "__esModule", {
  value: true
});
isMobilePhone$1.default = isMobilePhone;
isMobilePhone$1.locales = void 0;
var _assertString$4 = _interopRequireDefault$4(assertStringExports);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var phones = {
  "am-AM": /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
  "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
  "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
  "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
  "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
  "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
  "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
  "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
  "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
  "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
  "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
  "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
  "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
  "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
  "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
  "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
  "ar-TN": /^(\+?216)?[2459]\d{7}$/,
  "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
  "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
  "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
  "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
  "ca-AD": /^(\+376)?[346]\d{5}$/,
  "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
  "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
  "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
  "de-LU": /^(\+352)?((6\d1)\d{6})$/,
  "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
  "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
  "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
  "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
  "en-AU": /^(\+?61|0)4\d{8}$/,
  "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
  "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
  "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
  "en-GB": /^(\+?44|0)7\d{9}$/,
  "en-GG": /^(\+?44|0)1481\d{6}$/,
  "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
  "en-GY": /^(\+592|0)6\d{6}$/,
  "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
  "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
  "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
  "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
  "en-JM": /^(\+?876)?\d{7}$/,
  "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
  "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
  "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
  "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
  "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
  "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
  "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
  "en-MU": /^(\+?230|0)?\d{8}$/,
  "en-MW": /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
  "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
  "en-NG": /^(\+?234|0)?[789]\d{9}$/,
  "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
  "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
  "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
  "en-PH": /^(09|\+639)\d{9}$/,
  "en-RW": /^(\+?250|0)?[7]\d{8}$/,
  "en-SG": /^(\+65)?[3689]\d{7}$/,
  "en-SL": /^(\+?232|0)\d{8}$/,
  "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
  "en-UG": /^(\+?256|0)?[7]\d{8}$/,
  "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
  "en-ZA": /^(\+?27|0)\d{9}$/,
  "en-ZM": /^(\+?26)?09[567]\d{7}$/,
  "en-ZW": /^(\+263)[0-9]{9}$/,
  "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
  "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
  "es-BO": /^(\+?591)?(6|7)\d{7}$/,
  "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
  "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
  "es-CR": /^(\+506)?[2-8]\d{7}$/,
  "es-CU": /^(\+53|0053)?5\d{7}$/,
  "es-DO": /^(\+?1)?8[024]9\d{7}$/,
  "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
  "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
  "es-ES": /^(\+?34)?[6|7]\d{8}$/,
  "es-PE": /^(\+?51)?9\d{8}$/,
  "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
  "es-NI": /^(\+?505)\d{7,8}$/,
  "es-PA": /^(\+?507)\d{7,8}$/,
  "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
  "es-SV": /^(\+?503)?[67]\d{7}$/,
  "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
  "es-VE": /^(\+?58)?(2|4)\d{9}$/,
  "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
  "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
  "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
  "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "fr-BF": /^(\+226|0)[67]\d{7}$/,
  "fr-BJ": /^(\+229)\d{8}$/,
  "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
  "fr-CM": /^(\+?237)6[0-9]{8}$/,
  "fr-FR": /^(\+?33|0)[67]\d{8}$/,
  "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
  "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
  "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
  "fr-PF": /^(\+?689)?8[789]\d{6}$/,
  "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
  "fr-WF": /^(\+681)?\d{6}$/,
  "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
  "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
  "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
  "ir-IR": /^(\+98|0)?9\d{9}$/,
  "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
  "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
  "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
  "kk-KZ": /^(\+?7|8)?7\d{9}$/,
  "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
  "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
  "lt-LT": /^(\+370|8)\d{8}$/,
  "lv-LV": /^(\+?371)2\d{7}$/,
  "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
  "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
  "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
  "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
  "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
  "nb-NO": /^(\+?47)?[49]\d{7}$/,
  "ne-NP": /^(\+?977)?9[78]\d{8}$/,
  "nl-BE": /^(\+?32|0)4\d{8}$/,
  "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
  "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
  "nn-NO": /^(\+?47)?[49]\d{7}$/,
  "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
  "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
  "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
  "pt-AO": /^(\+244)\d{9}$/,
  "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
  "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
  "ru-RU": /^(\+?7|8)?9\d{9}$/,
  "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
  "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
  "sq-AL": /^(\+355|0)6[789]\d{6}$/,
  "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
  "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
  "th-TH": /^(\+66|66|0)\d{9}$/,
  "tr-TR": /^(\+?90|0)?5\d{9}$/,
  "tk-TM": /^(\+993|993|8)\d{8}$/,
  "uk-UA": /^(\+?38|8)?0\d{9}$/,
  "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
  "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
  "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
  "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
  "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
  "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
  "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
  "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
};
phones["en-CA"] = phones["en-US"];
phones["fr-CA"] = phones["en-CA"];
phones["fr-BE"] = phones["nl-BE"];
phones["zh-HK"] = phones["en-HK"];
phones["zh-MO"] = phones["en-MO"];
phones["ga-IE"] = phones["en-IE"];
phones["fr-CH"] = phones["de-CH"];
phones["it-CH"] = phones["fr-CH"];
function isMobilePhone(str, locale, options) {
  (0, _assertString$4.default)(str);
  if (options && options.strictMode && !str.startsWith("+")) {
    return false;
  }
  if (Array.isArray(locale)) {
    return locale.some(function(key2) {
      if (phones.hasOwnProperty(key2)) {
        var phone2 = phones[key2];
        if (phone2.test(str)) {
          return true;
        }
      }
      return false;
    });
  } else if (locale in phones) {
    return phones[locale].test(str);
  } else if (!locale || locale === "any") {
    for (var key in phones) {
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];
        if (phone.test(str)) {
          return true;
        }
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
isMobilePhone$1.locales = Object.keys(phones);
var isEthereumAddress = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEthereumAddress2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var eth = /^(0x)[0-9a-f]{40}$/i;
  function isEthereumAddress2(str) {
    (0, _assertString2.default)(str);
    return eth.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEthereumAddress, isEthereumAddress.exports);
var isEthereumAddressExports = isEthereumAddress.exports;
var isCurrency = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCurrency2;
  var _merge = _interopRequireDefault2(mergeExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function currencyRegex(options) {
    var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
    options.digits_after_decimal.forEach(function(digit, index2) {
      if (index2 !== 0)
        decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
    });
    var symbol = "(".concat(options.symbol.replace(/\W/, function(m2) {
      return "\\".concat(m2);
    }), ")").concat(options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"), valid_whole_dollar_amounts = ["0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep], whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join("|"), ")?"), decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? "" : "?");
    var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : "");
    if (options.allow_negatives && !options.parens_for_negatives) {
      if (options.negative_sign_after_digits) {
        pattern += negative;
      } else if (options.negative_sign_before_digits) {
        pattern = negative + pattern;
      }
    }
    if (options.allow_negative_sign_placeholder) {
      pattern = "( (?!\\-))?".concat(pattern);
    } else if (options.allow_space_after_symbol) {
      pattern = " ?".concat(pattern);
    } else if (options.allow_space_after_digits) {
      pattern += "( (?!$))?";
    }
    if (options.symbol_after_digits) {
      pattern += symbol;
    } else {
      pattern = symbol + pattern;
    }
    if (options.allow_negatives) {
      if (options.parens_for_negatives) {
        pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
      } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
        pattern = negative + pattern;
      }
    }
    return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
  }
  var default_currency_options = {
    symbol: "$",
    require_symbol: false,
    allow_space_after_symbol: false,
    symbol_after_digits: false,
    allow_negatives: true,
    parens_for_negatives: false,
    negative_sign_before_digits: false,
    negative_sign_after_digits: false,
    allow_negative_sign_placeholder: false,
    thousands_separator: ",",
    decimal_separator: ".",
    allow_decimal: true,
    require_decimal: false,
    digits_after_decimal: [2],
    allow_space_after_digits: false
  };
  function isCurrency2(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, default_currency_options);
    return currencyRegex(options).test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isCurrency, isCurrency.exports);
var isCurrencyExports = isCurrency.exports;
var isBtcAddress = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBtcAddress2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
  var base582 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
  function isBtcAddress2(str) {
    (0, _assertString2.default)(str);
    return bech32.test(str) || base582.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBtcAddress, isBtcAddress.exports);
var isBtcAddressExports = isBtcAddress.exports;
var isISO6346$1 = {};
Object.defineProperty(isISO6346$1, "__esModule", {
  value: true
});
isISO6346$1.isFreightContainerID = void 0;
isISO6346$1.isISO6346 = isISO6346;
var _assertString$3 = _interopRequireDefault$3(assertStringExports);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
var isDigit = /^[0-9]$/;
function isISO6346(str) {
  (0, _assertString$3.default)(str);
  str = str.toUpperCase();
  if (!isISO6346Str.test(str))
    return false;
  if (str.length === 11) {
    var sum = 0;
    for (var i = 0; i < str.length - 1; i++) {
      if (!isDigit.test(str[i])) {
        var convertedCode = void 0;
        var letterCode = str.charCodeAt(i) - 55;
        if (letterCode < 11)
          convertedCode = letterCode;
        else if (letterCode >= 11 && letterCode <= 20)
          convertedCode = 12 + letterCode % 11;
        else if (letterCode >= 21 && letterCode <= 30)
          convertedCode = 23 + letterCode % 21;
        else
          convertedCode = 34 + letterCode % 31;
        sum += convertedCode * Math.pow(2, i);
      } else
        sum += str[i] * Math.pow(2, i);
    }
    var checkSumDigit = sum % 11;
    return Number(str[str.length - 1]) === checkSumDigit;
  }
  return true;
}
isISO6346$1.isFreightContainerID = isISO6346;
var isISO6391 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO63912;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isISO6391Set = /* @__PURE__ */ new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
  function isISO63912(str) {
    (0, _assertString2.default)(str);
    return isISO6391Set.has(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISO6391, isISO6391.exports);
var isISO6391Exports = isISO6391.exports;
var isISO8601 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO86012;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var isValidDate = function isValidDate2(str) {
    var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
    if (ordinalMatch) {
      var oYear = Number(ordinalMatch[1]);
      var oDay = Number(ordinalMatch[2]);
      if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
        return oDay <= 366;
      return oDay <= 365;
    }
    var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
    var year = match[1];
    var month = match[2];
    var day = match[3];
    var monthString = month ? "0".concat(month).slice(-2) : month;
    var dayString = day ? "0".concat(day).slice(-2) : day;
    var d = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
    if (month && day) {
      return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
    }
    return true;
  };
  function isISO86012(str) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _assertString2.default)(str);
    var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
    if (check && options.strict)
      return isValidDate(str);
    return check;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISO8601, isISO8601.exports);
var isISO8601Exports = isISO8601.exports;
var isRFC3339 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isRFC33392;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var dateFullYear = /[0-9]{4}/;
  var dateMonth = /(0[1-9]|1[0-2])/;
  var dateMDay = /([12]\d|0[1-9]|3[01])/;
  var timeHour = /([01][0-9]|2[0-3])/;
  var timeMinute = /[0-5][0-9]/;
  var timeSecond = /([0-5][0-9]|60)/;
  var timeSecFrac = /(\.[0-9]+)?/;
  var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
  var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
  var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
  var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
  var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
  var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
  function isRFC33392(str) {
    (0, _assertString2.default)(str);
    return rfc3339.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isRFC3339, isRFC3339.exports);
var isRFC3339Exports = isRFC3339.exports;
var isISO31661Alpha3 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO31661Alpha32;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validISO31661Alpha3CountriesCodes = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
  function isISO31661Alpha32(str) {
    (0, _assertString2.default)(str);
    return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISO31661Alpha3, isISO31661Alpha3.exports);
var isISO31661Alpha3Exports = isISO31661Alpha3.exports;
var isISO4217$1 = {};
Object.defineProperty(isISO4217$1, "__esModule", {
  value: true
});
isISO4217$1.CurrencyCodes = void 0;
isISO4217$1.default = isISO4217;
var _assertString$2 = _interopRequireDefault$2(assertStringExports);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var validISO4217CurrencyCodes = /* @__PURE__ */ new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLE", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
function isISO4217(str) {
  (0, _assertString$2.default)(str);
  return validISO4217CurrencyCodes.has(str.toUpperCase());
}
isISO4217$1.CurrencyCodes = validISO4217CurrencyCodes;
var isBase32 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase322;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var base32 = /^[A-Z2-7]+=*$/;
  var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
  var defaultBase32Options = {
    crockford: false
  };
  function isBase322(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, defaultBase32Options);
    if (options.crockford) {
      return crockfordBase32.test(str);
    }
    var len = str.length;
    if (len % 8 === 0 && base32.test(str)) {
      return true;
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBase32, isBase32.exports);
var isBase32Exports = isBase32.exports;
var isBase58 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase582;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
  function isBase582(str) {
    (0, _assertString2.default)(str);
    if (base58Reg.test(str)) {
      return true;
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBase58, isBase58.exports);
var isBase58Exports = isBase58.exports;
var isDataURI = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDataURI2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
  var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
  var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
  function isDataURI2(str) {
    (0, _assertString2.default)(str);
    var data = str.split(",");
    if (data.length < 2) {
      return false;
    }
    var attributes = data.shift().trim().split(";");
    var schemeAndMediaType = attributes.shift();
    if (schemeAndMediaType.slice(0, 5) !== "data:") {
      return false;
    }
    var mediaType = schemeAndMediaType.slice(5);
    if (mediaType !== "" && !validMediaType.test(mediaType)) {
      return false;
    }
    for (var i = 0; i < attributes.length; i++) {
      if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === "base64") && !validAttribute.test(attributes[i])) {
        return false;
      }
    }
    for (var _i2 = 0; _i2 < data.length; _i2++) {
      if (!validData.test(data[_i2])) {
        return false;
      }
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDataURI, isDataURI.exports);
var isDataURIExports = isDataURI.exports;
var isMagnetURI = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMagnetURI2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
  function isMagnetURI2(url) {
    (0, _assertString2.default)(url);
    if (url.indexOf("magnet:?") !== 0) {
      return false;
    }
    return magnetURIComponent.test(url);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMagnetURI, isMagnetURI.exports);
var isMagnetURIExports = isMagnetURI.exports;
var isMailtoURI = { exports: {} };
var trim$1 = { exports: {} };
var rtrim = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rtrim2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function rtrim2(str, chars) {
    (0, _assertString2.default)(str);
    if (chars) {
      var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
      return str.replace(pattern, "");
    }
    var strIndex = str.length - 1;
    while (/\s/.test(str.charAt(strIndex))) {
      strIndex -= 1;
    }
    return str.slice(0, strIndex + 1);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(rtrim, rtrim.exports);
var rtrimExports = rtrim.exports;
var ltrim = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ltrim2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ltrim2(str, chars) {
    (0, _assertString2.default)(str);
    var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
    return str.replace(pattern, "");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(ltrim, ltrim.exports);
var ltrimExports = ltrim.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = trim2;
  var _rtrim = _interopRequireDefault2(rtrimExports);
  var _ltrim = _interopRequireDefault2(ltrimExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function trim2(str, chars) {
    return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(trim$1, trim$1.exports);
var trimExports = trim$1.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMailtoURI2;
  var _trim = _interopRequireDefault2(trimExports);
  var _isEmail = _interopRequireDefault2(isEmailExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i, u2, a = [], f2 = true, o = false;
      try {
        if (i = (t2 = t2.call(r2)).next, 0 === l2) {
          if (Object(t2) !== t2)
            return;
          f2 = false;
        } else
          for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true)
            ;
      } catch (r3) {
        o = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2))
            return;
        } finally {
          if (o)
            throw n2;
        }
      }
      return a;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e2(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n2() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e2(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f2() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function parseMailtoQueryString(queryString) {
    var allowedParams = /* @__PURE__ */ new Set(["subject", "body", "cc", "bcc"]), query = {
      cc: "",
      bcc: ""
    };
    var isParseFailed = false;
    var queryParams = queryString.split("&");
    if (queryParams.length > 4) {
      return false;
    }
    var _iterator = _createForOfIteratorHelper(queryParams), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var q2 = _step.value;
        var _q$split = q2.split("="), _q$split2 = _slicedToArray(_q$split, 2), key = _q$split2[0], value = _q$split2[1];
        if (key && !allowedParams.has(key)) {
          isParseFailed = true;
          break;
        }
        if (value && (key === "cc" || key === "bcc")) {
          query[key] = value;
        }
        if (key) {
          allowedParams.delete(key);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return isParseFailed ? false : query;
  }
  function isMailtoURI2(url, options) {
    (0, _assertString2.default)(url);
    if (url.indexOf("mailto:") !== 0) {
      return false;
    }
    var _url$replace$split = url.replace("mailto:", "").split("?"), _url$replace$split2 = _slicedToArray(_url$replace$split, 2), to = _url$replace$split2[0], _url$replace$split2$ = _url$replace$split2[1], queryString = _url$replace$split2$ === void 0 ? "" : _url$replace$split2$;
    if (!to && !queryString) {
      return true;
    }
    var query = parseMailtoQueryString(queryString);
    if (!query) {
      return false;
    }
    return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(",").every(function(email) {
      email = (0, _trim.default)(email, " ");
      if (email) {
        return (0, _isEmail.default)(email, options);
      }
      return true;
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMailtoURI, isMailtoURI.exports);
var isMailtoURIExports = isMailtoURI.exports;
var isMimeType = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMimeType2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i;
  var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
  var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
  function isMimeType2(str) {
    (0, _assertString2.default)(str);
    return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMimeType, isMimeType.exports);
var isMimeTypeExports = isMimeType.exports;
var isLatLong = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLatLong2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
  var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
  var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
  var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
  var defaultLatLongOptions = {
    checkDMS: false
  };
  function isLatLong2(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge.default)(options, defaultLatLongOptions);
    if (!str.includes(","))
      return false;
    var pair = str.split(",");
    if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("("))
      return false;
    if (options.checkDMS) {
      return latDMS.test(pair[0]) && longDMS.test(pair[1]);
    }
    return lat.test(pair[0]) && long.test(pair[1]);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLatLong, isLatLong.exports);
var isLatLongExports = isLatLong.exports;
var isPostalCode$1 = {};
Object.defineProperty(isPostalCode$1, "__esModule", {
  value: true
});
isPostalCode$1.default = isPostalCode;
isPostalCode$1.locales = void 0;
var _assertString$1 = _interopRequireDefault$1(assertStringExports);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var threeDigit = /^\d{3}$/;
var fourDigit = /^\d{4}$/;
var fiveDigit = /^\d{5}$/;
var sixDigit = /^\d{6}$/;
var patterns = {
  AD: /^AD\d{3}$/,
  AT: fourDigit,
  AU: fourDigit,
  AZ: /^AZ\d{4}$/,
  BA: /^([7-8]\d{4}$)/,
  BE: fourDigit,
  BG: fourDigit,
  BR: /^\d{5}-\d{3}$/,
  BY: /^2[1-4]\d{4}$/,
  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
  CH: fourDigit,
  CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
  CZ: /^\d{3}\s?\d{2}$/,
  DE: fiveDigit,
  DK: fourDigit,
  DO: fiveDigit,
  DZ: fiveDigit,
  EE: fiveDigit,
  ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
  FI: fiveDigit,
  FR: /^\d{2}\s?\d{3}$/,
  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
  GR: /^\d{3}\s?\d{2}$/,
  HR: /^([1-5]\d{4}$)/,
  HT: /^HT\d{4}$/,
  HU: fourDigit,
  ID: fiveDigit,
  IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
  IL: /^(\d{5}|\d{7})$/,
  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
  IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
  IS: threeDigit,
  IT: fiveDigit,
  JP: /^\d{3}\-\d{4}$/,
  KE: fiveDigit,
  KR: /^(\d{5}|\d{6})$/,
  LI: /^(948[5-9]|949[0-7])$/,
  LT: /^LT\-\d{5}$/,
  LU: fourDigit,
  LV: /^LV\-\d{4}$/,
  LK: fiveDigit,
  MG: threeDigit,
  MX: fiveDigit,
  MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
  MY: fiveDigit,
  NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
  NO: fourDigit,
  NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
  NZ: fourDigit,
  PL: /^\d{2}\-\d{3}$/,
  PR: /^00[679]\d{2}([ -]\d{4})?$/,
  PT: /^\d{4}\-\d{3}?$/,
  RO: sixDigit,
  RU: sixDigit,
  SA: fiveDigit,
  SE: /^[1-9]\d{2}\s?\d{2}$/,
  SG: sixDigit,
  SI: fourDigit,
  SK: /^\d{3}\s?\d{2}$/,
  TH: fiveDigit,
  TN: fourDigit,
  TW: /^\d{3}(\d{2})?$/,
  UA: fiveDigit,
  US: /^\d{5}(-\d{4})?$/,
  ZA: fourDigit,
  ZM: fiveDigit
};
isPostalCode$1.locales = Object.keys(patterns);
function isPostalCode(str, locale) {
  (0, _assertString$1.default)(str);
  if (locale in patterns) {
    return patterns[locale].test(str);
  } else if (locale === "any") {
    for (var key in patterns) {
      if (patterns.hasOwnProperty(key)) {
        var pattern = patterns[key];
        if (pattern.test(str)) {
          return true;
        }
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var _escape = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = escape2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function escape2(str) {
    (0, _assertString2.default)(str);
    return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(_escape, _escape.exports);
var _escapeExports = _escape.exports;
var _unescape = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = unescape2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function unescape2(str) {
    (0, _assertString2.default)(str);
    return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(_unescape, _unescape.exports);
var _unescapeExports = _unescape.exports;
var stripLow = { exports: {} };
var blacklist = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = blacklist2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function blacklist2(str, chars) {
    (0, _assertString2.default)(str);
    return str.replace(new RegExp("[".concat(chars, "]+"), "g"), "");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(blacklist, blacklist.exports);
var blacklistExports = blacklist.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = stripLow2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _blacklist = _interopRequireDefault2(blacklistExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stripLow2(str, keep_new_lines) {
    (0, _assertString2.default)(str);
    var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
    return (0, _blacklist.default)(str, chars);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(stripLow, stripLow.exports);
var stripLowExports = stripLow.exports;
var whitelist = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = whitelist2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function whitelist2(str, chars) {
    (0, _assertString2.default)(str);
    return str.replace(new RegExp("[^".concat(chars, "]+"), "g"), "");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(whitelist, whitelist.exports);
var whitelistExports = whitelist.exports;
var isWhitelisted = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isWhitelisted2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isWhitelisted2(str, chars) {
    (0, _assertString2.default)(str);
    for (var i = str.length - 1; i >= 0; i--) {
      if (chars.indexOf(str[i]) === -1) {
        return false;
      }
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isWhitelisted, isWhitelisted.exports);
var isWhitelistedExports = isWhitelisted.exports;
var normalizeEmail = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeEmail2;
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_normalize_email_options = {
    // The following options apply to all email addresses
    // Lowercases the local part of the email address.
    // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
    // The domain is always lowercased, as per RFC 1035
    all_lowercase: true,
    // The following conversions are specific to GMail
    // Lowercases the local part of the GMail address (known to be case-insensitive)
    gmail_lowercase: true,
    // Removes dots from the local part of the email address, as that's ignored by GMail
    gmail_remove_dots: true,
    // Removes the subaddress (e.g. "+foo") from the email address
    gmail_remove_subaddress: true,
    // Conversts the googlemail.com domain to gmail.com
    gmail_convert_googlemaildotcom: true,
    // The following conversions are specific to Outlook.com / Windows Live / Hotmail
    // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
    outlookdotcom_lowercase: true,
    // Removes the subaddress (e.g. "+foo") from the email address
    outlookdotcom_remove_subaddress: true,
    // The following conversions are specific to Yahoo
    // Lowercases the local part of the Yahoo address (known to be case-insensitive)
    yahoo_lowercase: true,
    // Removes the subaddress (e.g. "-foo") from the email address
    yahoo_remove_subaddress: true,
    // The following conversions are specific to Yandex
    // Lowercases the local part of the Yandex address (known to be case-insensitive)
    yandex_lowercase: true,
    // The following conversions are specific to iCloud
    // Lowercases the local part of the iCloud address (known to be case-insensitive)
    icloud_lowercase: true,
    // Removes the subaddress (e.g. "+foo") from the email address
    icloud_remove_subaddress: true
  };
  var icloud_domains = ["icloud.com", "me.com"];
  var outlookdotcom_domains = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"];
  var yahoo_domains = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"];
  var yandex_domains = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
  function dotsReplacer(match) {
    if (match.length > 1) {
      return match;
    }
    return "";
  }
  function normalizeEmail2(email, options) {
    options = (0, _merge.default)(options, default_normalize_email_options);
    var raw_parts = email.split("@");
    var domain = raw_parts.pop();
    var user = raw_parts.join("@");
    var parts = [user, domain];
    parts[1] = parts[1].toLowerCase();
    if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
      if (options.gmail_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (options.gmail_remove_dots) {
        parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.gmail_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
    } else if (icloud_domains.indexOf(parts[1]) >= 0) {
      if (options.icloud_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.icloud_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
      if (options.outlookdotcom_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.outlookdotcom_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
      if (options.yahoo_remove_subaddress) {
        var components = parts[0].split("-");
        parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.yahoo_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yandex_domains.indexOf(parts[1]) >= 0) {
      if (options.all_lowercase || options.yandex_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = "yandex.ru";
    } else if (options.all_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
    return parts.join("@");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(normalizeEmail, normalizeEmail.exports);
var normalizeEmailExports = normalizeEmail.exports;
var isSlug = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSlug2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
  function isSlug2(str) {
    (0, _assertString2.default)(str);
    return charsetRegex.test(str);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isSlug, isSlug.exports);
var isSlugExports = isSlug.exports;
var isLicensePlate = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLicensePlate2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validators2 = {
    "cs-CZ": function csCZ(str) {
      return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
    },
    "de-DE": function deDE(str) {
      return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G|GP|GR|GS|GT|G|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T|B|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BD|BUL|BR|BS|BZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL|FOR|FRG|FRI|FRW|FTL|FS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM|HOG|HOH|HOL|HOM|HOR|HS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JL|KEH|KEL|KEM|KIB|KLE|KLZ|KN|KT|KZ|KRU|KN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LB|LOS|LRO|LSZ|LN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MB|MR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL|PR|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RD|RG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL|SLZ|SM|SOB|SOG|SOK|SM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SW|SWA|SZB|TBB|TDO|TET|TIR|TL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
    },
    "de-LI": function deLI(str) {
      return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
    },
    "en-IN": function enIN(str) {
      return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
    },
    "es-AR": function esAR(str) {
      return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
    },
    "fi-FI": function fiFI(str) {
      return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
    },
    "hu-HU": function huHU(str) {
      return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
    },
    "pt-BR": function ptBR(str) {
      return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
    },
    "pt-PT": function ptPT(str) {
      return /^([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})$/.test(str);
    },
    "sq-AL": function sqAL(str) {
      return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
    },
    "sv-SE": function svSE(str) {
      return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z ]{2,7}$)/.test(str.trim());
    },
    "en-PK": function enPK(str) {
      return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(str.trim());
    }
  };
  function isLicensePlate2(str, locale) {
    (0, _assertString2.default)(str);
    if (locale in validators2) {
      return validators2[locale](str);
    } else if (locale === "any") {
      for (var key in validators2) {
        var validator2 = validators2[key];
        if (validator2(str)) {
          return true;
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLicensePlate, isLicensePlate.exports);
var isLicensePlateExports = isLicensePlate.exports;
var isStrongPassword = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isStrongPassword2;
  var _merge = _interopRequireDefault2(mergeExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var upperCaseRegex = /^[A-Z]$/;
  var lowerCaseRegex = /^[a-z]$/;
  var numberRegex = /^[0-9]$/;
  var symbolRegex = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/;
  var defaultOptions = {
    minLength: 8,
    minLowercase: 1,
    minUppercase: 1,
    minNumbers: 1,
    minSymbols: 1,
    returnScore: false,
    pointsPerUnique: 1,
    pointsPerRepeat: 0.5,
    pointsForContainingLower: 10,
    pointsForContainingUpper: 10,
    pointsForContainingNumber: 10,
    pointsForContainingSymbol: 10
  };
  function countChars(str) {
    var result = {};
    Array.from(str).forEach(function(char) {
      var curVal = result[char];
      if (curVal) {
        result[char] += 1;
      } else {
        result[char] = 1;
      }
    });
    return result;
  }
  function analyzePassword(password) {
    var charMap = countChars(password);
    var analysis = {
      length: password.length,
      uniqueChars: Object.keys(charMap).length,
      uppercaseCount: 0,
      lowercaseCount: 0,
      numberCount: 0,
      symbolCount: 0
    };
    Object.keys(charMap).forEach(function(char) {
      if (upperCaseRegex.test(char)) {
        analysis.uppercaseCount += charMap[char];
      } else if (lowerCaseRegex.test(char)) {
        analysis.lowercaseCount += charMap[char];
      } else if (numberRegex.test(char)) {
        analysis.numberCount += charMap[char];
      } else if (symbolRegex.test(char)) {
        analysis.symbolCount += charMap[char];
      }
    });
    return analysis;
  }
  function scorePassword(analysis, scoringOptions) {
    var points = 0;
    points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
    points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
    if (analysis.lowercaseCount > 0) {
      points += scoringOptions.pointsForContainingLower;
    }
    if (analysis.uppercaseCount > 0) {
      points += scoringOptions.pointsForContainingUpper;
    }
    if (analysis.numberCount > 0) {
      points += scoringOptions.pointsForContainingNumber;
    }
    if (analysis.symbolCount > 0) {
      points += scoringOptions.pointsForContainingSymbol;
    }
    return points;
  }
  function isStrongPassword2(str) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    (0, _assertString2.default)(str);
    var analysis = analyzePassword(str);
    options = (0, _merge.default)(options || {}, defaultOptions);
    if (options.returnScore) {
      return scorePassword(analysis, options);
    }
    return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isStrongPassword, isStrongPassword.exports);
var isStrongPasswordExports = isStrongPassword.exports;
var isVAT$1 = {};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
Object.defineProperty(isVAT$1, "__esModule", {
  value: true
});
isVAT$1.default = isVAT;
isVAT$1.vatMatchers = void 0;
var _assertString = _interopRequireDefault(assertStringExports);
var algorithms = _interopRequireWildcard(algorithms$1);
function _getRequireWildcardCache(e2) {
  if ("function" != typeof WeakMap)
    return null;
  var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache2(e3) {
    return e3 ? t2 : r2;
  })(e2);
}
function _interopRequireWildcard(e2, r2) {
  if (!r2 && e2 && e2.__esModule)
    return e2;
  if (null === e2 || "object" != _typeof(e2) && "function" != typeof e2)
    return { default: e2 };
  var t2 = _getRequireWildcardCache(r2);
  if (t2 && t2.has(e2))
    return t2.get(e2);
  var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u2 in e2)
    if ("default" !== u2 && {}.hasOwnProperty.call(e2, u2)) {
      var i = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
      i && (i.get || i.set) ? Object.defineProperty(n2, u2, i) : n2[u2] = e2[u2];
    }
  return n2.default = e2, t2 && t2.set(e2, n2), n2;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var AU = function AU2(str) {
  var match = str.match(/^(AU)?(\d{11})$/);
  if (!match) {
    return false;
  }
  var weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
  str = str.replace(/^AU/, "");
  var ABN = (parseInt(str.slice(0, 1), 10) - 1).toString() + str.slice(1);
  var total = 0;
  for (var i = 0; i < 11; i++) {
    total += weights[i] * ABN.charAt(i);
  }
  return total !== 0 && total % 89 === 0;
};
var CH = function CH2(str) {
  var hasValidCheckNumber = function hasValidCheckNumber2(digits) {
    var lastDigit = digits.pop();
    var weights = [5, 4, 3, 2, 7, 6, 5, 4];
    var calculatedCheckNumber = (11 - digits.reduce(function(acc, el2, idx) {
      return acc + el2 * weights[idx];
    }, 0) % 11) % 11;
    return lastDigit === calculatedCheckNumber;
  };
  return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function(el2) {
    return +el2;
  }));
};
var PT = function PT2(str) {
  var match = str.match(/^(PT)?(\d{9})$/);
  if (!match) {
    return false;
  }
  var tin = match[2];
  var checksum2 = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
    return parseInt(a, 10);
  }), 9) % 11;
  if (checksum2 > 9) {
    return parseInt(tin[8], 10) === 0;
  }
  return checksum2 === parseInt(tin[8], 10);
};
var vatMatchers = isVAT$1.vatMatchers = {
  /**
   * European Union VAT identification numbers
   */
  AT: function AT(str) {
    return /^(AT)?U\d{8}$/.test(str);
  },
  BE: function BE(str) {
    return /^(BE)?\d{10}$/.test(str);
  },
  BG: function BG(str) {
    return /^(BG)?\d{9,10}$/.test(str);
  },
  HR: function HR(str) {
    return /^(HR)?\d{11}$/.test(str);
  },
  CY: function CY(str) {
    return /^(CY)?\w{9}$/.test(str);
  },
  CZ: function CZ(str) {
    return /^(CZ)?\d{8,10}$/.test(str);
  },
  DK: function DK(str) {
    return /^(DK)?\d{8}$/.test(str);
  },
  EE: function EE(str) {
    return /^(EE)?\d{9}$/.test(str);
  },
  FI: function FI(str) {
    return /^(FI)?\d{8}$/.test(str);
  },
  FR: function FR(str) {
    return /^(FR)?\w{2}\d{9}$/.test(str);
  },
  DE: function DE(str) {
    return /^(DE)?\d{9}$/.test(str);
  },
  EL: function EL(str) {
    return /^(EL)?\d{9}$/.test(str);
  },
  HU: function HU(str) {
    return /^(HU)?\d{8}$/.test(str);
  },
  IE: function IE(str) {
    return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
  },
  IT: function IT(str) {
    return /^(IT)?\d{11}$/.test(str);
  },
  LV: function LV(str) {
    return /^(LV)?\d{11}$/.test(str);
  },
  LT: function LT(str) {
    return /^(LT)?\d{9,12}$/.test(str);
  },
  LU: function LU(str) {
    return /^(LU)?\d{8}$/.test(str);
  },
  MT: function MT(str) {
    return /^(MT)?\d{8}$/.test(str);
  },
  NL: function NL(str) {
    return /^(NL)?\d{9}B\d{2}$/.test(str);
  },
  PL: function PL(str) {
    return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
  },
  PT,
  RO: function RO(str) {
    return /^(RO)?\d{2,10}$/.test(str);
  },
  SK: function SK(str) {
    return /^(SK)?\d{10}$/.test(str);
  },
  SI: function SI(str) {
    return /^(SI)?\d{8}$/.test(str);
  },
  ES: function ES(str) {
    return /^(ES)?\w\d{7}[A-Z]$/.test(str);
  },
  SE: function SE(str) {
    return /^(SE)?\d{12}$/.test(str);
  },
  /**
   * VAT numbers of non-EU countries
   */
  AL: function AL(str) {
    return /^(AL)?\w{9}[A-Z]$/.test(str);
  },
  MK: function MK(str) {
    return /^(MK)?\d{13}$/.test(str);
  },
  AU,
  BY: function BY(str) {
    return /^( )?\d{9}$/.test(str);
  },
  CA: function CA(str) {
    return /^(CA)?\d{9}$/.test(str);
  },
  IS: function IS(str) {
    return /^(IS)?\d{5,6}$/.test(str);
  },
  IN: function IN(str) {
    return /^(IN)?\d{15}$/.test(str);
  },
  ID: function ID(str) {
    return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
  },
  IL: function IL(str) {
    return /^(IL)?\d{9}$/.test(str);
  },
  KZ: function KZ(str) {
    return /^(KZ)?\d{12}$/.test(str);
  },
  NZ: function NZ(str) {
    return /^(NZ)?\d{9}$/.test(str);
  },
  NG: function NG(str) {
    return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
  },
  NO: function NO(str) {
    return /^(NO)?\d{9}MVA$/.test(str);
  },
  PH: function PH(str) {
    return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
  },
  RU: function RU(str) {
    return /^(RU)?(\d{10}|\d{12})$/.test(str);
  },
  SM: function SM(str) {
    return /^(SM)?\d{5}$/.test(str);
  },
  SA: function SA(str) {
    return /^(SA)?\d{15}$/.test(str);
  },
  RS: function RS(str) {
    return /^(RS)?\d{9}$/.test(str);
  },
  CH,
  TR: function TR(str) {
    return /^(TR)?\d{10}$/.test(str);
  },
  UA: function UA(str) {
    return /^(UA)?\d{12}$/.test(str);
  },
  GB: function GB(str) {
    return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
  },
  UZ: function UZ(str) {
    return /^(UZ)?\d{9}$/.test(str);
  },
  /**
   * VAT numbers of Latin American countries
   */
  AR: function AR(str) {
    return /^(AR)?\d{11}$/.test(str);
  },
  BO: function BO(str) {
    return /^(BO)?\d{7}$/.test(str);
  },
  BR: function BR(str) {
    return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
  },
  CL: function CL(str) {
    return /^(CL)?\d{8}-\d{1}$/.test(str);
  },
  CO: function CO(str) {
    return /^(CO)?\d{10}$/.test(str);
  },
  CR: function CR(str) {
    return /^(CR)?\d{9,12}$/.test(str);
  },
  EC: function EC(str) {
    return /^(EC)?\d{13}$/.test(str);
  },
  SV: function SV(str) {
    return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
  },
  GT: function GT(str) {
    return /^(GT)?\d{7}-\d{1}$/.test(str);
  },
  HN: function HN(str) {
    return /^(HN)?$/.test(str);
  },
  MX: function MX(str) {
    return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
  },
  NI: function NI(str) {
    return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
  },
  PA: function PA(str) {
    return /^(PA)?$/.test(str);
  },
  PY: function PY(str) {
    return /^(PY)?\d{6,8}-\d{1}$/.test(str);
  },
  PE: function PE(str) {
    return /^(PE)?\d{11}$/.test(str);
  },
  DO: function DO(str) {
    return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
  },
  UY: function UY(str) {
    return /^(UY)?\d{12}$/.test(str);
  },
  VE: function VE(str) {
    return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
  }
};
function isVAT(str, countryCode) {
  (0, _assertString.default)(str);
  (0, _assertString.default)(countryCode);
  if (countryCode in vatMatchers) {
    return vatMatchers[countryCode](str);
  }
  throw new Error("Invalid country code: '".concat(countryCode, "'"));
}
(function(module, exports) {
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _toDate = _interopRequireDefault2(toDateExports);
  var _toFloat = _interopRequireDefault2(toFloatExports);
  var _toInt = _interopRequireDefault2(toIntExports);
  var _toBoolean = _interopRequireDefault2(toBooleanExports);
  var _equals = _interopRequireDefault2(equalsExports);
  var _contains = _interopRequireDefault2(containsExports);
  var _matches = _interopRequireDefault2(matchesExports);
  var _isEmail = _interopRequireDefault2(isEmailExports);
  var _isURL = _interopRequireDefault2(isURLExports);
  var _isMACAddress = _interopRequireDefault2(isMACAddressExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  var _isIPRange = _interopRequireDefault2(isIPRangeExports);
  var _isFQDN = _interopRequireDefault2(isFQDNExports);
  var _isDate = _interopRequireDefault2(isDateExports);
  var _isTime = _interopRequireDefault2(isTimeExports);
  var _isBoolean = _interopRequireDefault2(isBooleanExports);
  var _isLocale = _interopRequireDefault2(isLocaleExports);
  var _isAbaRouting = _interopRequireDefault2(isAbaRoutingExports);
  var _isAlpha = _interopRequireWildcard2(isAlpha$1);
  var _isAlphanumeric = _interopRequireWildcard2(isAlphanumeric$1);
  var _isNumeric = _interopRequireDefault2(isNumericExports);
  var _isPassportNumber = _interopRequireDefault2(isPassportNumberExports);
  var _isPort = _interopRequireDefault2(isPortExports);
  var _isLowercase = _interopRequireDefault2(isLowercaseExports);
  var _isUppercase = _interopRequireDefault2(isUppercaseExports);
  var _isIMEI = _interopRequireDefault2(isIMEIExports);
  var _isAscii = _interopRequireDefault2(isAsciiExports);
  var _isFullWidth = _interopRequireDefault2(isFullWidth$1);
  var _isHalfWidth = _interopRequireDefault2(isHalfWidth$1);
  var _isVariableWidth = _interopRequireDefault2(isVariableWidthExports);
  var _isMultibyte = _interopRequireDefault2(isMultibyteExports);
  var _isSemVer = _interopRequireDefault2(isSemVerExports);
  var _isSurrogatePair = _interopRequireDefault2(isSurrogatePairExports);
  var _isInt = _interopRequireDefault2(isIntExports);
  var _isFloat = _interopRequireWildcard2(isFloat$1);
  var _isDecimal = _interopRequireDefault2(isDecimalExports);
  var _isHexadecimal = _interopRequireDefault2(isHexadecimalExports);
  var _isOctal = _interopRequireDefault2(isOctalExports);
  var _isDivisibleBy = _interopRequireDefault2(isDivisibleByExports);
  var _isHexColor = _interopRequireDefault2(isHexColorExports);
  var _isRgbColor = _interopRequireDefault2(isRgbColorExports);
  var _isHSL = _interopRequireDefault2(isHSLExports);
  var _isISRC = _interopRequireDefault2(isISRCExports);
  var _isIBAN = _interopRequireWildcard2(isIBAN$1);
  var _isBIC = _interopRequireDefault2(isBICExports);
  var _isMD = _interopRequireDefault2(isMD5Exports);
  var _isHash = _interopRequireDefault2(isHashExports);
  var _isJWT = _interopRequireDefault2(isJWTExports);
  var _isJSON = _interopRequireDefault2(isJSONExports);
  var _isEmpty = _interopRequireDefault2(isEmptyExports);
  var _isLength = _interopRequireDefault2(isLengthExports);
  var _isByteLength = _interopRequireDefault2(isByteLengthExports);
  var _isUUID = _interopRequireDefault2(isUUIDExports);
  var _isMongoId = _interopRequireDefault2(isMongoIdExports);
  var _isAfter = _interopRequireDefault2(isAfterExports);
  var _isBefore = _interopRequireDefault2(isBeforeExports);
  var _isIn = _interopRequireDefault2(isInExports);
  var _isLuhnNumber = _interopRequireDefault2(isLuhnNumberExports);
  var _isCreditCard = _interopRequireDefault2(isCreditCardExports);
  var _isIdentityCard = _interopRequireDefault2(isIdentityCardExports);
  var _isEAN = _interopRequireDefault2(isEANExports);
  var _isISIN = _interopRequireDefault2(isISINExports);
  var _isISBN = _interopRequireDefault2(isISBNExports);
  var _isISSN = _interopRequireDefault2(isISSNExports);
  var _isTaxID = _interopRequireDefault2(isTaxIDExports);
  var _isMobilePhone = _interopRequireWildcard2(isMobilePhone$1);
  var _isEthereumAddress = _interopRequireDefault2(isEthereumAddressExports);
  var _isCurrency = _interopRequireDefault2(isCurrencyExports);
  var _isBtcAddress = _interopRequireDefault2(isBtcAddressExports);
  var _isISO = isISO6346$1;
  var _isISO2 = _interopRequireDefault2(isISO6391Exports);
  var _isISO3 = _interopRequireDefault2(isISO8601Exports);
  var _isRFC = _interopRequireDefault2(isRFC3339Exports);
  var _isISO31661Alpha = _interopRequireDefault2(isISO31661Alpha2$1);
  var _isISO31661Alpha2 = _interopRequireDefault2(isISO31661Alpha3Exports);
  var _isISO4 = _interopRequireDefault2(isISO4217$1);
  var _isBase = _interopRequireDefault2(isBase32Exports);
  var _isBase2 = _interopRequireDefault2(isBase58Exports);
  var _isBase3 = _interopRequireDefault2(isBase64Exports);
  var _isDataURI = _interopRequireDefault2(isDataURIExports);
  var _isMagnetURI = _interopRequireDefault2(isMagnetURIExports);
  var _isMailtoURI = _interopRequireDefault2(isMailtoURIExports);
  var _isMimeType = _interopRequireDefault2(isMimeTypeExports);
  var _isLatLong = _interopRequireDefault2(isLatLongExports);
  var _isPostalCode = _interopRequireWildcard2(isPostalCode$1);
  var _ltrim = _interopRequireDefault2(ltrimExports);
  var _rtrim = _interopRequireDefault2(rtrimExports);
  var _trim = _interopRequireDefault2(trimExports);
  var _escape2 = _interopRequireDefault2(_escapeExports);
  var _unescape2 = _interopRequireDefault2(_unescapeExports);
  var _stripLow = _interopRequireDefault2(stripLowExports);
  var _whitelist = _interopRequireDefault2(whitelistExports);
  var _blacklist = _interopRequireDefault2(blacklistExports);
  var _isWhitelisted = _interopRequireDefault2(isWhitelistedExports);
  var _normalizeEmail = _interopRequireDefault2(normalizeEmailExports);
  var _isSlug = _interopRequireDefault2(isSlugExports);
  var _isLicensePlate = _interopRequireDefault2(isLicensePlateExports);
  var _isStrongPassword = _interopRequireDefault2(isStrongPasswordExports);
  var _isVAT = _interopRequireDefault2(isVAT$1);
  function _getRequireWildcardCache2(e2) {
    if ("function" != typeof WeakMap)
      return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(e3) {
      return e3 ? t2 : r2;
    })(e2);
  }
  function _interopRequireWildcard2(e2, r2) {
    if (!r2 && e2 && e2.__esModule)
      return e2;
    if (null === e2 || "object" != _typeof2(e2) && "function" != typeof e2)
      return { default: e2 };
    var t2 = _getRequireWildcardCache2(r2);
    if (t2 && t2.has(e2))
      return t2.get(e2);
    var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u2 in e2)
      if ("default" !== u2 && {}.hasOwnProperty.call(e2, u2)) {
        var i = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
        i && (i.get || i.set) ? Object.defineProperty(n2, u2, i) : n2[u2] = e2[u2];
      }
    return n2.default = e2, t2 && t2.set(e2, n2), n2;
  }
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var version2 = "13.12.0";
  var validator2 = {
    version: version2,
    toDate: _toDate.default,
    toFloat: _toFloat.default,
    toInt: _toInt.default,
    toBoolean: _toBoolean.default,
    equals: _equals.default,
    contains: _contains.default,
    matches: _matches.default,
    isEmail: _isEmail.default,
    isURL: _isURL.default,
    isMACAddress: _isMACAddress.default,
    isIP: _isIP.default,
    isIPRange: _isIPRange.default,
    isFQDN: _isFQDN.default,
    isBoolean: _isBoolean.default,
    isIBAN: _isIBAN.default,
    isBIC: _isBIC.default,
    isAbaRouting: _isAbaRouting.default,
    isAlpha: _isAlpha.default,
    isAlphaLocales: _isAlpha.locales,
    isAlphanumeric: _isAlphanumeric.default,
    isAlphanumericLocales: _isAlphanumeric.locales,
    isNumeric: _isNumeric.default,
    isPassportNumber: _isPassportNumber.default,
    isPort: _isPort.default,
    isLowercase: _isLowercase.default,
    isUppercase: _isUppercase.default,
    isAscii: _isAscii.default,
    isFullWidth: _isFullWidth.default,
    isHalfWidth: _isHalfWidth.default,
    isVariableWidth: _isVariableWidth.default,
    isMultibyte: _isMultibyte.default,
    isSemVer: _isSemVer.default,
    isSurrogatePair: _isSurrogatePair.default,
    isInt: _isInt.default,
    isIMEI: _isIMEI.default,
    isFloat: _isFloat.default,
    isFloatLocales: _isFloat.locales,
    isDecimal: _isDecimal.default,
    isHexadecimal: _isHexadecimal.default,
    isOctal: _isOctal.default,
    isDivisibleBy: _isDivisibleBy.default,
    isHexColor: _isHexColor.default,
    isRgbColor: _isRgbColor.default,
    isHSL: _isHSL.default,
    isISRC: _isISRC.default,
    isMD5: _isMD.default,
    isHash: _isHash.default,
    isJWT: _isJWT.default,
    isJSON: _isJSON.default,
    isEmpty: _isEmpty.default,
    isLength: _isLength.default,
    isLocale: _isLocale.default,
    isByteLength: _isByteLength.default,
    isUUID: _isUUID.default,
    isMongoId: _isMongoId.default,
    isAfter: _isAfter.default,
    isBefore: _isBefore.default,
    isIn: _isIn.default,
    isLuhnNumber: _isLuhnNumber.default,
    isCreditCard: _isCreditCard.default,
    isIdentityCard: _isIdentityCard.default,
    isEAN: _isEAN.default,
    isISIN: _isISIN.default,
    isISBN: _isISBN.default,
    isISSN: _isISSN.default,
    isMobilePhone: _isMobilePhone.default,
    isMobilePhoneLocales: _isMobilePhone.locales,
    isPostalCode: _isPostalCode.default,
    isPostalCodeLocales: _isPostalCode.locales,
    isEthereumAddress: _isEthereumAddress.default,
    isCurrency: _isCurrency.default,
    isBtcAddress: _isBtcAddress.default,
    isISO6346: _isISO.isISO6346,
    isFreightContainerID: _isISO.isFreightContainerID,
    isISO6391: _isISO2.default,
    isISO8601: _isISO3.default,
    isRFC3339: _isRFC.default,
    isISO31661Alpha2: _isISO31661Alpha.default,
    isISO31661Alpha3: _isISO31661Alpha2.default,
    isISO4217: _isISO4.default,
    isBase32: _isBase.default,
    isBase58: _isBase2.default,
    isBase64: _isBase3.default,
    isDataURI: _isDataURI.default,
    isMagnetURI: _isMagnetURI.default,
    isMailtoURI: _isMailtoURI.default,
    isMimeType: _isMimeType.default,
    isLatLong: _isLatLong.default,
    ltrim: _ltrim.default,
    rtrim: _rtrim.default,
    trim: _trim.default,
    escape: _escape2.default,
    unescape: _unescape2.default,
    stripLow: _stripLow.default,
    whitelist: _whitelist.default,
    blacklist: _blacklist.default,
    isWhitelisted: _isWhitelisted.default,
    normalizeEmail: _normalizeEmail.default,
    toString,
    isSlug: _isSlug.default,
    isStrongPassword: _isStrongPassword.default,
    isTaxID: _isTaxID.default,
    isDate: _isDate.default,
    isTime: _isTime.default,
    isLicensePlate: _isLicensePlate.default,
    isVAT: _isVAT.default,
    ibanLocales: _isIBAN.locales
  };
  exports.default = validator2;
  module.exports = exports.default;
  module.exports.default = exports.default;
})(validator$2, validator$2.exports);
var validatorExports = validator$2.exports;
const validator$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(validatorExports);
function isValidURL(url) {
  if (typeof url !== "string")
    return false;
  return validator$1.isURL(url.toString(), {
    protocols: ["http", "https"],
    require_tld: false
  });
}
function isObject$2(obj) {
  return obj === Object(obj) && Object.prototype.toString.call(obj) !== "[object Array]";
}
function isArray$1(array2) {
  return Array.isArray(array2);
}
function isJson(string2) {
  try {
    return !!JSON.parse(string2);
  } catch (ex) {
    return false;
  }
}
function isBoolean$1(bool) {
  return typeof bool === "boolean";
}
function isBigNumber(number2) {
  return !!number2 && (number2 instanceof BigNumber || number2.constructor && number2.constructor.name === "BigNumber");
}
function isString$1(string2) {
  return typeof string2 === "string" || !!string2 && string2.constructor && string2.constructor.name === "String";
}
function isFunction$1(obj) {
  return typeof obj === "function";
}
function isHex(string2) {
  return typeof string2 === "string" && !isNaN(parseInt(string2, 16)) && /^(0x|)[a-fA-F0-9]+$/.test(string2);
}
function isInteger(number2) {
  if (number2 === null)
    return false;
  return Number.isInteger(Number(number2));
}
function hasProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}
function hasProperties(obj, ...properties) {
  return properties.length && !properties.map((property) => {
    return hasProperty(obj, property);
  }).includes(false);
}
function mapEvent(event) {
  const data = {
    block: event.block_number,
    timestamp: event.block_timestamp,
    contract: event.contract_address,
    name: event.event_name,
    transaction: event.transaction_id,
    result: event.result,
    resourceNode: event.resource_Node || (event._unconfirmed ? "fullNode" : "solidityNode")
  };
  if (event._unconfirmed) {
    data.unconfirmed = event._unconfirmed;
  }
  if (event._fingerprint) {
    data.fingerprint = event._fingerprint;
  }
  return data;
}
function parseEvent(event, { inputs: abi2 }) {
  if (!event.result)
    return event;
  if (isObject$2(event.result)) {
    for (let i = 0; i < abi2.length; i++) {
      const obj = abi2[i];
      if (obj.type == "address" && obj.name in event.result)
        event.result[obj.name] = ADDRESS_PREFIX + event.result[obj.name].substr(2).toLowerCase();
    }
  } else if (isArray$1(event.result)) {
    event.result = event.result.reduce((obj, result, index2) => {
      const { name, type: type2 } = abi2[index2];
      if (type2 == "address")
        result = ADDRESS_PREFIX + result.substr(2).toLowerCase();
      obj[name] = result;
      return obj;
    }, {});
  }
  return event;
}
function padLeft(input, padding2, amount) {
  let res = input.toString();
  while (res.length < amount)
    res = padding2 + res;
  return res;
}
function isNotNullOrUndefined(val) {
  return val !== null && typeof val !== "undefined";
}
async function sleep(millis = 1e3) {
  return new Promise((resolve) => setTimeout(resolve, millis));
}
const validations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasProperties,
  hasProperty,
  isArray: isArray$1,
  isBigNumber,
  isBoolean: isBoolean$1,
  isFunction: isFunction$1,
  isHex,
  isInteger,
  isJson,
  isNotNullOrUndefined,
  isObject: isObject$2,
  isString: isString$1,
  isValidURL,
  mapEvent,
  padLeft,
  parseEvent,
  sleep
}, Symbol.toStringTag, { value: "Module" }));
const version$1 = "6.13.4";
function checkType(value, type2, name) {
  const types = type2.split("|").map((t2) => t2.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type2) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type2) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type2}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k2) => Promise.resolve(value[k2])));
  return results.reduce((accum, v2, index2) => {
    accum[keys[index2]] = v2;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type2 = types ? types[key] : null;
    if (type2) {
      checkType(value, type2, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k2) => `${stringify(k2)}: ${stringify(value[k2])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code2) {
  return error && error.code === code2;
}
function makeError(message2, code2, info) {
  let shortMessage = message2;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code2}`);
    details.push(`version=${version$1}`);
    if (details.length) {
      message2 += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code2) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message2);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message2);
      break;
    default:
      error = new Error(message2);
  }
  defineProperties(error, { code: code2 });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message2, code2, info) {
  if (!check) {
    throw makeError(message2, code2, info);
  }
}
function assertArgument(check, message2, name, value) {
  assert(check, message2, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message2) {
  if (message2 == null) {
    message2 = "";
  }
  if (message2) {
    message2 = ": " + message2;
  }
  assert(count >= expectedCount, "missing arguemnt" + message2, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message2, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard2, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard2) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name, copy) {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset2 = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset2, offset2 + 2), 16);
      offset2 += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes2 = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v2 = bytes2[i];
    result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes2 = getBytes(data);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function zeroPad(data, length, left) {
  const bytes2 = getBytes(data);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
const BN_0$7 = BigInt(0);
const BN_1$4 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$7, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1$4) {
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return -((~value & mask2) + BN_1$4);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$4 << width - BN_1$4;
  if (value < BN_0$7) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return (~value & mask2) + BN_1$4;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$4 << bits) - BN_1$4;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e2) {
        assertArgument(false, `invalid BigNumberish string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0$7, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles$1 = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v2 of value) {
      result += Nibbles$1[v2 >> 4];
      result += Nibbles$1[v2 & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e2) {
        assertArgument(false, `invalid numeric string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0$7) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset2 = i * 2;
    result[i] = parseInt(hex.substring(offset2, offset2 + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
const BN_0$6 = BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes2 = getBytes(_value2);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
function errorFunc(reason, offset2, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset2}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset2, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset2 + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset2 - 1;
  }
  return 0;
}
function replaceFunc(reason, offset2, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset2, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c = bytes2[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset2, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset2 + i];
  }
  return result;
}
function _decodeChildren(data, offset2, childOffset, length) {
  const result = [];
  while (childOffset < offset2 + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset2 + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset: offset2
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset2) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset3) => {
    assert(offset3 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset3
    });
  };
  if (data[offset2] >= 248) {
    const lengthLength = data[offset2] - 247;
    checkOffset(offset2 + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    checkOffset(offset2 + 1 + lengthLength + length);
    return _decodeChildren(data, offset2, offset2 + 1 + lengthLength, lengthLength + length);
  } else if (data[offset2] >= 192) {
    const length = data[offset2] - 192;
    checkOffset(offset2 + 1 + length);
    return _decodeChildren(data, offset2, offset2 + 1, length);
  } else if (data[offset2] >= 184) {
    const lengthLength = data[offset2] - 183;
    checkOffset(offset2 + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    checkOffset(offset2 + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset2 + 1 + lengthLength, offset2 + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset2] >= 128) {
    const length = data[offset2] - 128;
    checkOffset(offset2 + 1 + length);
    const result = hexlify(data.slice(offset2 + 1, offset2 + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset2]) };
}
function decodeRlp(_data5) {
  const data = getBytes(_data5, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data5);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object) {
  let result = "0x";
  for (const v2 of _encode(object)) {
    result += nibbles[v2 >> 4];
    result += nibbles[v2 & 15];
  }
  return result;
}
function uuidV4(randomBytes2) {
  const bytes2 = getBytes(randomBytes2, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value = hexlify(bytes2);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties = ["then"];
const _guard$5 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names) {
  resultNames.set(result, names);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names, items, deep) {
  if (names.indexOf(null) >= 0) {
    return items.map((item, index2) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names.reduce((accum, name, index2) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
const _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard2 = args[0];
    let items = args[1];
    let names = (args[2] || []).slice();
    let wrap = true;
    if (guard2 !== _guard$5) {
      items = args;
      names = [];
      wrap = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names, void 0);
    items.forEach((item, index2) => {
      this[index2] = item;
    });
    const nameCounts = names.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index2) => {
      const name = names[index2];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index2 = getNumber(prop, "%index");
            if (index2 < 0 || index2 >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index2];
            if (item instanceof Error) {
              throwError(`index ${index2}`, item);
            }
            return item;
          }
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index2) => {
      if (item instanceof Error) {
        throwError(`index ${index2}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names = getNames(this);
    return names.reduce((accum, name, index2) => {
      assert(name != null, `value at index ${index2} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names.push(_names2[i]);
    }
    return new _Result(_guard$5, result, names);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names.push(_names2[i]);
      }
    }
    return new _Result(_guard$5, result, names);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index2 = getNames(this).indexOf(name);
    if (index2 === -1) {
      return void 0;
    }
    const value = this[index2];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard$5, items, keys);
  }
};
_names = new WeakMap();
let Result = _Result;
function getValue(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
class Coder {
  constructor(name, type2, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties(this, { name, type: type2, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message2, value) {
    assertArgument(false, message2, this.localName, value);
  }
}
class Writer {
  constructor() {
    __privateAdd(this, _writeData);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data, void 0);
    __privateAdd(this, _dataLength, void 0);
    __privateSet(this, _data, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat(__privateGet(this, _data));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _writeData, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _writeData, writeData_fn).call(this, bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _writeData, writeData_fn).call(this, getValue(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset2 = __privateGet(this, _data).length;
    __privateGet(this, _data).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data)[offset2] = getValue(value);
    };
  }
}
_data = new WeakMap();
_dataLength = new WeakMap();
_writeData = new WeakSet();
writeData_fn = function(data) {
  __privateGet(this, _data).push(data);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
  return data.length;
};
const _Reader = class _Reader {
  constructor(data, allowLoose, maxInflation) {
    __privateAdd(this, _incrementBytesRead);
    __privateAdd(this, _peekBytes);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data2, void 0);
    __privateAdd(this, _offset, void 0);
    __privateAdd(this, _bytesRead, void 0);
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _maxInflation, void 0);
    defineProperties(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data2, getBytesCopy(data));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data2));
  }
  get dataLength() {
    return __privateGet(this, _data2).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data2));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset2) {
    const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset2), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader, _parent, this);
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = __privateMethod(this, _peekBytes, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _incrementBytesRead, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes2.length);
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data2 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_incrementBytesRead = new WeakSet();
incrementBytesRead_fn = function(count) {
  var _a3;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a3 = __privateGet(this, _parent), _incrementBytesRead, incrementBytesRead_fn).call(_a3, count);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data2)),
    offset: __privateGet(this, _offset),
    length: count,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
_peekBytes = new WeakSet();
peekBytes_fn = function(offset2, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data2)),
        length: __privateGet(this, _data2).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
let Reader = _Reader;
function number$1(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes$1(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash$1(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(hash2.outputLen);
  number$1(hash2.blockLen);
}
function exists$1(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(out, instance2) {
  bytes$1(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (a) => a instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$1 = (word, shift) => word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb2) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb2(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes$3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$1(data) {
  if (typeof data === "string")
    data = utf8ToBytes$3(data);
  if (!u8a$1(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes$3(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrays.forEach((a) => {
    if (!u8a$1(a))
      throw new Error("Uint8Array expected");
    r2.set(a, pad2);
    pad2 += a.length;
  });
  return r2;
}
let Hash$1 = class Hash3 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
const toStr = {}.toString;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor$1(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$3(bytesLength = 32) {
  if (crypto$4 && typeof crypto$4.getRandomValues === "function") {
    return crypto$4.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
let HMAC$1 = class HMAC2 extends Hash$1 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$1(hash2);
    const key = toBytes$1(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash2.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists$1(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists$1(this);
    bytes$1(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
const hmac$1 = (hash2, key, message2) => new HMAC$1(hash2, key).update(message2).digest();
hmac$1.create = (hash2, key) => new HMAC$1(hash2, key);
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash$1(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number$1(c);
  number$1(dkLen);
  number$1(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes$1(_password);
  const salt = toBytes$1(_salt);
  const DK2 = new Uint8Array(dkLen);
  const PRF = hmac$1.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK: DK2, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK2, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u2.fill(0);
  return DK2;
}
function pbkdf2$1(hash2, password, salt, opts) {
  const { c, dkLen, DK: DK2, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView$1(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
    const Ti2 = DK2.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti2, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti2.set(u2.subarray(0, Ti2.length));
    for (let ui2 = 1; ui2 < c; ui2++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i = 0; i < Ti2.length; i++)
        Ti2[i] ^= u2[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK2, prfW, u2);
}
function setBigUint64$1(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
class SHA2 extends Hash$1 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    exists$1(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$1(this);
    output$1(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished: finished2, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const Chi$1 = (a, b2, c) => a & b2 ^ ~a & c;
const Maj$1 = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
const SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$2 = class SHA2563 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W$1[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$1[i - 15];
      const W2 = SHA256_W$1[i - 2];
      const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i] = s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$1(E2, 6) ^ rotr$1(E2, 11) ^ rotr$1(E2, 25);
      const T12 = H2 + sigma1 + Chi$1(E2, F2, G2) + SHA256_K$1[i] + SHA256_W$1[i] | 0;
      const sigma0 = rotr$1(A2, 2) ^ rotr$1(A2, 13) ^ rotr$1(A2, 22);
      const T22 = sigma0 + Maj$1(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T12 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$2 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$2());
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l: l2 } = fromBig(lst[i], le2);
    [Ah2[i], Al[i]] = [h2, l2];
  }
  return [Ah2, Al];
}
const toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
const shrSH = (h2, _l2, s) => h2 >>> s;
const shrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
const rotrSH = (h2, l2, s) => h2 >>> s | l2 << 32 - s;
const rotrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
const rotrBH = (h2, l2, s) => h2 << 64 - s | l2 >>> s - 32;
const rotrBL = (h2, l2, s) => h2 >>> s - 32 | l2 << 64 - s;
const rotr32H = (_h2, l2) => l2;
const rotr32L = (h2, _l2) => h2;
const rotlSH = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
const rotlSL = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
const rotlBH = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
const rotlBL = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
function add(Ah2, Al, Bh2, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah2 + Bh2 + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
const u64$1 = u64;
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64$1.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA5122 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    return [Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl];
  }
  // prettier-ignore
  set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl) {
    this.Ah = Ah2 | 0;
    this.Al = Al | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh2 | 0;
    this.El = El | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4) {
      SHA512_W_H[i] = view.getUint32(offset2);
      SHA512_W_L[i] = view.getUint32(offset2 += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64$1.rotrSH(W15h, W15l, 1) ^ u64$1.rotrSH(W15h, W15l, 8) ^ u64$1.shrSH(W15h, W15l, 7);
      const s0l = u64$1.rotrSL(W15h, W15l, 1) ^ u64$1.rotrSL(W15h, W15l, 8) ^ u64$1.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64$1.rotrSH(W2h, W2l, 19) ^ u64$1.rotrBH(W2h, W2l, 61) ^ u64$1.shrSH(W2h, W2l, 6);
      const s1l = u64$1.rotrSL(W2h, W2l, 19) ^ u64$1.rotrBL(W2h, W2l, 61) ^ u64$1.shrSL(W2h, W2l, 6);
      const SUMl = u64$1.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64$1.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64$1.rotrSH(Eh2, El, 14) ^ u64$1.rotrSH(Eh2, El, 18) ^ u64$1.rotrBH(Eh2, El, 41);
      const sigma1l = u64$1.rotrSL(Eh2, El, 14) ^ u64$1.rotrSL(Eh2, El, 18) ^ u64$1.rotrBL(Eh2, El, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64$1.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64$1.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64$1.rotrSH(Ah2, Al, 28) ^ u64$1.rotrBH(Ah2, Al, 34) ^ u64$1.rotrBH(Ah2, Al, 39);
      const sigma0l = u64$1.rotrSL(Ah2, Al, 28) ^ u64$1.rotrBL(Ah2, Al, 34) ^ u64$1.rotrBL(Ah2, Al, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh2 = Gh2 | 0;
      Hl = Gl | 0;
      Gh2 = Fh2 | 0;
      Gl = Fl | 0;
      Fh2 = Eh2 | 0;
      Fl = El | 0;
      ({ h: Eh2, l: El } = u64$1.add(Dh2 | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl = Cl | 0;
      Ch2 = Bh2 | 0;
      Cl = Bl | 0;
      Bh2 = Ah2 | 0;
      Bl = Al | 0;
      const All = u64$1.add3L(T1l, sigma0l, MAJl);
      Ah2 = u64$1.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah2, l: Al } = u64$1.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al | 0));
    ({ h: Bh2, l: Bl } = u64$1.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl | 0));
    ({ h: Ch2, l: Cl } = u64$1.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl | 0));
    ({ h: Dh2, l: Dl } = u64$1.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl | 0));
    ({ h: Eh2, l: El } = u64$1.add(this.Eh | 0, this.El | 0, Eh2 | 0, El | 0));
    ({ h: Fh2, l: Fl } = u64$1.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl | 0));
    ({ h: Gh2, l: Gl } = u64$1.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl | 0));
    ({ h: Hh2, l: Hl } = u64$1.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl | 0));
    this.set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor$1(() => new SHA5122());
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
const crypto$3 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256$2.create();
    case "sha512":
      return sha512.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256: sha256$2, sha512 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac$1.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256: sha256$2, sha512 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2$1(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes$2(length) {
  assert(crypto$3 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto$3.getRandomValues(result);
  return result;
}
let locked$4 = false;
const _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
let __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data5) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data5, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked$4 = true;
};
computeHmac.register = function(func) {
  if (locked$4) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$8 = /* @__PURE__ */ BigInt(0);
const _1n$a = /* @__PURE__ */ BigInt(1);
const _2n$6 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R2 = _1n$a, x2 = 1, y2 = 0; round < 24; round++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x2));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t2 = _0n$8;
  for (let j = 0; j < 7; j++) {
    R2 = (R2 << _1n$a ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n$6)
      t2 ^= _1n$a << (_1n$a << /* @__PURE__ */ BigInt(j)) - _1n$a;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
const rotlH = (h2, l2, s) => s > 32 ? rotlBH(h2, l2, s) : rotlSH(h2, l2, s);
const rotlL = (h2, l2, s) => s > 32 ? rotlBL(h2, l2, s) : rotlSL(h2, l2, s);
function keccakP(s, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s[x2 + y2] ^= Th2;
        s[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th2 = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th2;
      s[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B2.fill(0);
}
class Keccak2 extends Hash$1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number$1(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists$1(this);
    const { blockLen, state } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists$1(this, false);
    bytes$1(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number$1(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output$1(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak2(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked$3 = false;
const _keccak256 = function(data) {
  return keccak_256(data);
};
let __keccak256 = _keccak256;
function keccak256(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked$3 = true;
};
keccak256.register = function(func) {
  if (locked$3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k2) => Rho[k2]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
const rotl$1 = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x2, y2, z2) {
  if (group === 0)
    return x2 ^ y2 ^ z2;
  else if (group === 1)
    return x2 & y2 | ~x2 & z2;
  else if (group === 2)
    return (x2 | ~y2) ^ z2;
  else if (group === 3)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      BUF[i] = view.getUint32(offset2, true);
    let al2 = this.h0 | 0, ar = al2, bl2 = this.h1 | 0, br = bl2, cl2 = this.h2 | 0, cr = cl2, dl2 = this.h3 | 0, dr = dl2, el2 = this.h4 | 0, er = el2;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl2 = idxL[group], rr = idxR[group];
      const sl2 = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl2 = rotl$1(al2 + f(group, bl2, cl2, dl2) + BUF[rl2[i]] + hbl, sl2[i]) + el2 | 0;
        al2 = el2, el2 = dl2, dl2 = rotl$1(cl2, 10) | 0, cl2 = bl2, bl2 = tl2;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl2 + dr | 0, this.h2 + dl2 + er | 0, this.h3 + el2 + ar | 0, this.h4 + al2 + br | 0, this.h0 + bl2 + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160$1 = /* @__PURE__ */ wrapConstructor$1(() => new RIPEMD160());
let locked$2 = false;
const _ripemd160 = function(data) {
  return ripemd160$1(data);
};
let __ripemd160 = _ripemd160;
function ripemd160(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__ripemd160(data));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function() {
  locked$2 = true;
};
ripemd160.register = function(func) {
  if (locked$2) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);
let locked$1 = false;
const _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function() {
  locked$1 = true;
};
pbkdf2.register = function(func) {
  if (locked$1) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);
let locked = false;
const _randomBytes = function(length) {
  return new Uint8Array(randomBytes$2(length));
};
let __randomBytes = _randomBytes;
function randomBytes$1(length) {
  return __randomBytes(length);
}
randomBytes$1._ = _randomBytes;
randomBytes$1.lock = function() {
  locked = true;
};
randomBytes$1.register = function(func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes$1);
const rotl = (a, b2) => a << b2 | a >>> 32 - b2;
function XorAndSalsa(prev, pi2, input, ii2, out, oi2) {
  let y00 = prev[pi2++] ^ input[ii2++], y01 = prev[pi2++] ^ input[ii2++];
  let y02 = prev[pi2++] ^ input[ii2++], y03 = prev[pi2++] ^ input[ii2++];
  let y04 = prev[pi2++] ^ input[ii2++], y05 = prev[pi2++] ^ input[ii2++];
  let y06 = prev[pi2++] ^ input[ii2++], y07 = prev[pi2++] ^ input[ii2++];
  let y08 = prev[pi2++] ^ input[ii2++], y09 = prev[pi2++] ^ input[ii2++];
  let y10 = prev[pi2++] ^ input[ii2++], y11 = prev[pi2++] ^ input[ii2++];
  let y12 = prev[pi2++] ^ input[ii2++], y13 = prev[pi2++] ^ input[ii2++];
  let y14 = prev[pi2++] ^ input[ii2++], y15 = prev[pi2++] ^ input[ii2++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi2++] = y00 + x00 | 0;
  out[oi2++] = y01 + x01 | 0;
  out[oi2++] = y02 + x02 | 0;
  out[oi2++] = y03 + x03 | 0;
  out[oi2++] = y04 + x04 | 0;
  out[oi2++] = y05 + x05 | 0;
  out[oi2++] = y06 + x06 | 0;
  out[oi2++] = y07 + x07 | 0;
  out[oi2++] = y08 + x08 | 0;
  out[oi2++] = y09 + x09 | 0;
  out[oi2++] = y10 + x10 | 0;
  out[oi2++] = y11 + x11 | 0;
  out[oi2++] = y12 + x12 | 0;
  out[oi2++] = y13 + x13 | 0;
  out[oi2++] = y14 + x14 | 0;
  out[oi2++] = y15 + x15 | 0;
}
function BlockMix(input, ii2, out, oi2, r2) {
  let head = oi2 + 0;
  let tail = oi2 + 16 * r2;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii2 + (2 * r2 - 1) * 16 + i];
  for (let i = 0; i < r2; i++, head += 16, ii2 += 16) {
    XorAndSalsa(out, tail, input, ii2, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii2 += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r: r2, p: p2, dkLen, asyncTick, maxmem, onProgress } = opts;
  number$1(N2);
  number$1(r2);
  number$1(p2);
  number$1(dkLen);
  number$1(asyncTick);
  number$1(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p2 < 0 || p2 > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p2);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B2 = pbkdf2$1(sha256$2, password, salt, { c: 1, dkLen: blockSize * p2 });
  const B32 = u32(B2);
  const V2 = u32(new Uint8Array(blockSize * N2));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p2;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B2, V2, tmp) {
  const res = pbkdf2$1(sha256$2, password, B2, { c: 1, dkLen });
  B2.fill(0);
  V2.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt$1(password, salt, opts) {
  const { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi2 = 0; pi2 < p2; pi2++) {
    const Pi2 = blockSize32 * pi2;
    for (let i = 0; i < blockSize32; i++)
      V2[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N2 - 1; i++) {
      BlockMix(V2, pos, V2, pos += blockSize32, r2);
      blockMixCb();
    }
    BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    for (let i = 0; i < N2; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k2 = 0; k2 < blockSize32; k2++)
        tmp[k2] = B32[Pi2 + k2] ^ V2[j * blockSize32 + k2];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B2, V2, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi2 = 0; pi2 < p2; pi2++) {
    const Pi2 = blockSize32 * pi2;
    for (let i = 0; i < blockSize32; i++)
      V2[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N2 - 1, asyncTick, () => {
      BlockMix(V2, pos, V2, pos += blockSize32, r2);
      blockMixCb();
    });
    BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    await asyncLoop(N2, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k2 = 0; k2 < blockSize32; k2++)
        tmp[k2] = B32[Pi2 + k2] ^ V2[j * blockSize32 + k2];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B2, V2, tmp);
}
let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function(passwd, salt, N2, r2, p2, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N2, r: r2, p: p2, dkLen, onProgress });
};
const _scryptSync = function(passwd, salt, N2, r2, p2, dkLen) {
  return scrypt$1(passwd, salt, { N: N2, r: r2, p: p2, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
async function scrypt(_passwd, _salt, N2, r2, p2, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N2, r2, p2, dkLen, progress));
}
scrypt._ = _scryptAsync;
scrypt.lock = function() {
  lockedAsync = true;
};
scrypt.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
function scryptSync(_passwd, _salt, N2, r2, p2, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N2, r2, p2, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);
const _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
let __sha256 = _sha256;
let locked256 = false;
function sha256$1(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__sha256(data));
}
sha256$1._ = _sha256;
sha256$1.lock = function() {
  locked256 = true;
};
sha256$1.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256$1);
Object.freeze(sha256$1);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0);
const _1n$9 = BigInt(1);
const _2n$5 = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$1(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes$1[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded$1(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array2 = new Uint8Array(len / 2);
  for (let i = 0; i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte2 = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte2) || byte2 < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte2;
  }
  return array2;
}
function bytesToNumberBE$1(bytes2) {
  return hexToNumber$1(bytesToHex$1(bytes2));
}
function bytesToNumberLE$1(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber$1(bytesToHex$1(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE$1(n2, len) {
  return hexToBytes$1(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE$1(n2, len) {
  return numberToBytesBE$1(n2, len).reverse();
}
function numberToVarBytesBE$1(n2) {
  return hexToBytes$1(numberToHexUnpadded$1(n2));
}
function ensureBytes$1(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes$1(hex);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e2}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes$2(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r2.set(a, pad2);
    pad2 += a.length;
  });
  return r2;
}
function equalBytes$1(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes$2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen$1(n2) {
  let len;
  for (len = 0; n2 > _0n$7; n2 >>= _1n$9, len += 1)
    ;
  return len;
}
function bitGet$1(n2, pos) {
  return n2 >> BigInt(pos) & _1n$9;
}
const bitSet$1 = (n2, pos, value) => {
  return n2 | (value ? _1n$9 : _0n$7) << BigInt(pos);
};
const bitMask$1 = (n2) => (_2n$5 << BigInt(n2 - 1)) - _1n$9;
const u8n$1 = (data) => new Uint8Array(data);
const u8fr$1 = (arr) => Uint8Array.from(arr);
function createHmacDrbg$1(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n$1(hashLen);
  let k2 = u8n$1(hashLen);
  let i = 0;
  const reset = () => {
    v2.fill(1);
    k2.fill(0);
    i = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed = u8n$1()) => {
    k2 = h2(u8fr$1([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr$1([1]), seed);
    v2 = h2();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl2 = v2.slice();
      out.push(sl2);
      len += v2.length;
    }
    return concatBytes$2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns$1 = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject$1(object, validators2, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns$1[type2];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type2}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators2))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object;
}
const ut$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: bitGet$1,
  bitLen: bitLen$1,
  bitMask: bitMask$1,
  bitSet: bitSet$1,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE: bytesToNumberBE$1,
  bytesToNumberLE: bytesToNumberLE$1,
  concatBytes: concatBytes$2,
  createHmacDrbg: createHmacDrbg$1,
  ensureBytes: ensureBytes$1,
  equalBytes: equalBytes$1,
  hexToBytes: hexToBytes$1,
  hexToNumber: hexToNumber$1,
  numberToBytesBE: numberToBytesBE$1,
  numberToBytesLE: numberToBytesLE$1,
  numberToHexUnpadded: numberToHexUnpadded$1,
  numberToVarBytesBE: numberToVarBytesBE$1,
  utf8ToBytes: utf8ToBytes$2,
  validateObject: validateObject$1
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$6 = BigInt(0), _1n$8 = BigInt(1), _2n$4 = BigInt(2), _3n$3 = BigInt(3);
const _4n$1 = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$1(a, b2) {
  const result = a % b2;
  return result >= _0n$6 ? result : b2 + result;
}
function pow$1(num, power, modulo) {
  if (modulo <= _0n$6 || power < _0n$6)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$8)
    return _0n$6;
  let res = _1n$8;
  while (power > _0n$6) {
    if (power & _1n$8)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$8;
  }
  return res;
}
function pow2$1(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$6) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert$1(number2, modulo) {
  if (number2 === _0n$6 || modulo <= _0n$6) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod$1(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$6, u2 = _1n$8;
  while (a !== _0n$6) {
    const q2 = b2 / a;
    const r2 = b2 % a;
    const m2 = x2 - u2 * q2;
    b2 = a, a = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$8)
    throw new Error("invert: does not exist");
  return mod$1(x2, modulo);
}
function tonelliShanks$1(P2) {
  const legendreC = (P2 - _1n$8) / _2n$4;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n$8, S2 = 0; Q2 % _2n$4 === _0n$6; Q2 /= _2n$4, S2++)
    ;
  for (Z2 = _2n$4; Z2 < P2 && pow$1(Z2, legendreC, P2) !== P2 - _1n$8; Z2++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$8) / _4n$1;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n$8) / _2n$4;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q2);
    let x2 = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n$8 << BigInt(r2 - m2 - 1));
      g = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt$1(P2) {
  if (P2 % _4n$1 === _3n$3) {
    const p1div4 = (P2 + _1n$8) / _4n$1;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n$1 === _5n$1) {
    const c1 = (P2 - _5n$1) / _8n$1;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$4);
      const v2 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v2);
      const i = Fp2.mul(Fp2.mul(nv, _2n$4), v2);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks$1(P2);
}
const FIELD_FIELDS$1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$1(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS$1.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject$1(field, opts);
}
function FpPow$1(f2, num, power) {
  if (power < _0n$6)
    throw new Error("Expected power > 0");
  if (power === _0n$6)
    return f2.ONE;
  if (power === _1n$8)
    return num;
  let p2 = f2.ONE;
  let d = num;
  while (power > _0n$6) {
    if (power & _1n$8)
      p2 = f2.mul(p2, d);
    d = f2.sqr(d);
    power >>= _1n$8;
  }
  return p2;
}
function FpInvertBatch$1(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength$1(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field$1(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$6)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength$1(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt$1(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask$1(BITS),
    ZERO: _0n$6,
    ONE: _1n$8,
    create: (num) => mod$1(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$6 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$6,
    isOdd: (num) => (num & _1n$8) === _1n$8,
    neg: (num) => mod$1(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod$1(num * num, ORDER),
    add: (lhs, rhs) => mod$1(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod$1(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod$1(lhs * rhs, ORDER),
    pow: (num, power) => FpPow$1(f2, num, power),
    div: (lhs, rhs) => mod$1(lhs * invert$1(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert$1(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch$1(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE$1(num, BYTES) : numberToBytesBE$1(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE$1(bytes2) : bytesToNumberBE$1(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength$1(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength$1(fieldOrder) {
  const length = getFieldBytesLength$1(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField$1(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength$1(fieldOrder);
  const minLen = getMinHashLength$1(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE$1(key) : bytesToNumberLE$1(key);
  const reduced = mod$1(num, fieldOrder - _1n$8) + _1n$8;
  return isLE2 ? numberToBytesLE$1(reduced, fieldLen) : numberToBytesBE$1(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = BigInt(0);
const _1n$7 = BigInt(1);
function wNAF$1(c, bits) {
  const constTimeNegate2 = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate: constTimeNegate2,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p2 = c.ZERO;
      let d = elm;
      while (n2 > _0n$5) {
        if (n2 & _1n$7)
          p2 = p2.add(d);
        d = d.double();
        n2 >>= _1n$7;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base2 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p2;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p2);
          points.push(base2);
        }
        p2 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = opts(W2);
      let p2 = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$7;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate2(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate2(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n2, transform) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n2);
    }
  };
}
function validateBasic$1(curve) {
  validateField$1(curve.Fp);
  validateObject$1(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength$1(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts$1(curve) {
  const opts = validateBasic$1(curve);
  validateObject$1(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$1;
const DER$1 = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER$1;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n$1(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E2 } = DER$1;
    const data = typeof hex === "string" ? h2b$1(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER$1._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER$1._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h2(sig.s));
    const r2 = slice(h2(sig.r));
    const shl = s.length / 2;
    const rhl = r2.length / 2;
    const sl2 = h2(shl);
    const rl2 = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s}`;
  }
};
const _0n$4 = BigInt(0), _1n$6 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);
function weierstrassPoints$1(opts) {
  const CURVE = validatePointOpts$1(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes$2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n$4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex$1(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE$1(ensureBytes$1("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod$1(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes2 = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes$1("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes2.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y2 } = this.toAffine();
      if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x2);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n$2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n$2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes2, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I2 = Point.ZERO;
      if (n2 === _0n$4)
        return I2;
      assertGE(n2);
      if (n2 === _1n$6)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I2;
      let k2p = I2;
      let d = this;
      while (k1 > _0n$4 || k2 > _0n$4) {
        if (k1 & _1n$6)
          k1p = k1p.add(d);
        if (k2 & _1n$6)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$6;
        k2 >>= _1n$6;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(n2);
        point = p2;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a, b2) {
      const G2 = Point.BASE;
      const mul2 = (P2, a2) => a2 === _0n$4 || a2 === _1n$6 || !P2.equals(G2) ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
      const sum = mul2(this, a).add(mul2(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y2, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x2, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$6)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$6)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex$1(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF$1(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts$1(curve) {
  const opts = validateBasic$1(curve);
  validateObject$1(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass$1(curveDef) {
  const CURVE = validateOpts$1(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n$4 < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod$1(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert$1(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints$1({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a = point.toAffine();
      const x2 = Fp2.toBytes(a.x);
      const cat = concatBytes$2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE$1(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3 = Fp2.sqrt(y2);
        const isYOdd = (y3 & _1n$6) === _1n$6;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex$1(numberToBytesBE$1(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$6;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE$1(b2.slice(from, to));
  class Signature2 {
    constructor(r2, s, recovery) {
      this.r = r2;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes$1("compactSignature", hex, l2 * 2);
      return new Signature2(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r2, s } = DER$1.toSig(ensureBytes$1("DER", hex));
      return new Signature2(r2, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes$1("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER$1.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength$1(CURVE.n);
      return mapHashToField$1(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE$1(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask$1(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n$4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE$1(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes$1("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes$1("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes$1("extraEntropy", e2));
    }
    const seed = concatBytes$2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q2 = Point.BASE.multiply(k2).toAffine();
      const r2 = modN(q2.x);
      if (r2 === _0n$4)
        return;
      const s = modN(ik2 * modN(m2 + r2 * d));
      if (s === _0n$4)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n$6);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg$1(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify2(signature2, msgHash, publicKey2, opts = defaultVerOpts) {
    var _a3;
    const sg2 = signature2;
    msgHash = ensureBytes$1("msgHash", msgHash);
    publicKey2 = ensureBytes$1("publicKey", publicKey2);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || sg2 instanceof Uint8Array) {
        try {
          _sig2 = Signature2.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER$1.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s2 } = sg2;
        _sig2 = new Signature2(r3, s2);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey2);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s } = _sig2;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN(h2 * is2);
    const u2 = modN(r2 * is2);
    const R2 = (_a3 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a3.toAffine();
    if (!R2)
      return false;
    const v2 = modN(R2.x);
    return v2 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify: verify2,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac$1(hash2, key, concatBytes$3(...msgs)),
    randomBytes: randomBytes$3
  };
}
function createCurve$1(curveDef, defHash) {
  const create3 = (hash2) => weierstrass$1({ ...curveDef, ...getHash$1(hash2) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n$5 = BigInt(1);
const _2n$3 = BigInt(2);
const divNearest$1 = (a, b2) => (a + b2 / _2n$3) / b2;
function sqrtMod$1(y2) {
  const P2 = secp256k1P$1;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2$1(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2$1(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2$1(b9, _2n$3, P2) * b2 % P2;
  const b22 = pow2$1(b11, _11n, P2) * b11 % P2;
  const b44 = pow2$1(b22, _22n, P2) * b22 % P2;
  const b88 = pow2$1(b44, _44n, P2) * b44 % P2;
  const b176 = pow2$1(b88, _88n, P2) * b88 % P2;
  const b220 = pow2$1(b176, _44n, P2) * b44 % P2;
  const b223 = pow2$1(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2$1(b223, _23n, P2) * b22 % P2;
  const t2 = pow2$1(t1, _6n, P2) * b2 % P2;
  const root = pow2$1(t2, _2n$3, P2);
  if (!Fp$1.eql(Fp$1.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
const Fp$1 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 });
const secp256k1$1 = createCurve$1({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp$1,
  n: secp256k1N$1,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N$1;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n$5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest$1(b2 * k2, n2);
      const c2 = divNearest$1(-b1 * k2, n2);
      let k1 = mod$1(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod$1(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$2);
BigInt(0);
secp256k1$1.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const MessagePrefix = "Ethereum Signed Message:\n";
const BN_0$5 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_2$1 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$4 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
const _Signature = class _Signature {
  /**
   *  @private
   */
  constructor(guard2, r2, s, v2) {
    __privateAdd(this, _r, void 0);
    __privateAdd(this, _s, void 0);
    __privateAdd(this, _v, void 0);
    __privateAdd(this, _networkV, void 0);
    assertPrivate(guard2, _guard$4, "Signature");
    __privateSet(this, _r, r2);
    __privateSet(this, _s, s);
    __privateSet(this, _v, v2);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return __privateGet(this, _s);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    const value = hexlify(_value2);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    __privateSet(this, _s, value);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v2 = getNumber(value, "value");
    assertArgument(v2 === 27 || v2 === 28, "invalid v", "v", value);
    __privateSet(this, _v, v2);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v2 = this.networkV;
    if (v2 == null) {
      return null;
    }
    return _Signature.getChainId(v2);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone2 = new _Signature(_guard$4, this.r, this.s, this.v);
    if (this.networkV) {
      __privateSet(clone2, _networkV, this.networkV);
    }
    return clone2;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v2) {
    const bv = getBigInt(v2, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$5;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v2);
    return (bv - BN_35$1) / BN_2$1;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v2) {
    return getBigInt(chainId) * BN_2$1 + BigInt(35 + v2 - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v2) {
    const bv = getBigInt(v2);
    if (bv === BN_0$5 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$3 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v2);
    return bv & BN_1$3 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message2) {
      assertArgument(check, message2, "signature", sig);
    }
    if (sig == null) {
      return new _Signature(_guard$4, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r3 = hexlify(bytes2.slice(0, 32));
        const s2 = bytes2.slice(32, 64);
        const v6 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new _Signature(_guard$4, r3, hexlify(s2), v6);
      }
      if (bytes2.length === 65) {
        const r3 = hexlify(bytes2.slice(0, 32));
        const s2 = bytes2.slice(32, 64);
        assertError((s2[0] & 128) === 0, "non-canonical s");
        const v6 = _Signature.getNormalizedV(bytes2[64]);
        return new _Signature(_guard$4, r3, hexlify(s2), v6);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r2 = sig.r;
    assertError(_r2 != null, "missing r");
    const r2 = toUint256(_r2);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
    const { networkV, v: v2 } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v6 = getBigInt(_v2);
        return {
          networkV: v6 >= BN_35$1 ? v6 : void 0,
          v: _Signature.getNormalizedV(v6)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard$4, r2, s, v2);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};
_r = new WeakMap();
_s = new WeakMap();
_v = new WeakMap();
_networkV = new WeakMap();
let Signature = _Signature;
const _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey, void 0);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1$1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1$1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1$1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1$1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature2) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature2);
    let secpSig = secp256k1$1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature2);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1$1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1$1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
let SigningKey = _SigningKey;
const BN_0$4 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress$1(address2) {
  address2 = address2.toLowerCase();
  const chars = address2.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address2) {
  address2 = address2.toUpperCase();
  address2 = address2.substring(4) + address2.substring(0, 2) + "00";
  let expanded = address2.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
const Base36 = function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$4;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress$1(address2) {
  assertArgument(typeof address2 === "string", "invalid address", "address", address2);
  if (address2.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address2.startsWith("0x")) {
      address2 = "0x" + address2;
    }
    const result = getChecksumAddress$1(address2);
    assertArgument(!address2.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address2, "bad address checksum", "address", address2);
    return result;
  }
  if (address2.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address2.substring(2, 4) === ibanChecksum(address2), "bad icap checksum", "address", address2);
    let result = fromBase36(address2.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress$1("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address2);
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress$1(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress$1(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n(value, width) {
  let signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b(value, size2) {
  return new Typed(_gaurd, `bytes${size2 ? size2 : ""}`, value, { size: size2 });
}
const _typedSymbol = Symbol.for("_ethers_typed");
const _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type2, value, options) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options, void 0);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type: type2, value });
    __privateSet(this, _options, options);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v2) => v2.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type2, value) {
    return new _Typed(_gaurd, type2, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v2) {
    return n(v2, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v2) {
    return n(v2, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v2) {
    return n(v2, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v2) {
    return n(v2, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v2) {
    return n(v2, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v2) {
    return n(v2, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v2) {
    return n(v2, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v2) {
    return n(v2, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v2) {
    return n(v2, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v2) {
    return n(v2, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v2) {
    return n(v2, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v2) {
    return n(v2, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v2) {
    return n(v2, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v2) {
    return n(v2, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v2) {
    return n(v2, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v2) {
    return n(v2, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v2) {
    return n(v2, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v2) {
    return n(v2, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v2) {
    return n(v2, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v2) {
    return n(v2, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v2) {
    return n(v2, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v2) {
    return n(v2, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v2) {
    return n(v2, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v2) {
    return n(v2, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v2) {
    return n(v2, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v2) {
    return n(v2, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v2) {
    return n(v2, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v2) {
    return n(v2, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v2) {
    return n(v2, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v2) {
    return n(v2, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v2) {
    return n(v2, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v2) {
    return n(v2, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v2) {
    return n(v2, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v2) {
    return n(v2, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v2) {
    return n(v2, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v2) {
    return n(v2, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v2) {
    return n(v2, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v2) {
    return n(v2, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v2) {
    return n(v2, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v2) {
    return n(v2, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v2) {
    return n(v2, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v2) {
    return n(v2, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v2) {
    return n(v2, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v2) {
    return n(v2, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v2) {
    return n(v2, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v2) {
    return n(v2, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v2) {
    return n(v2, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v2) {
    return n(v2, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v2) {
    return n(v2, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v2) {
    return n(v2, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v2) {
    return n(v2, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v2) {
    return n(v2, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v2) {
    return n(v2, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v2) {
    return n(v2, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v2) {
    return n(v2, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v2) {
    return n(v2, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v2) {
    return n(v2, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v2) {
    return n(v2, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v2) {
    return n(v2, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v2) {
    return n(v2, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v2) {
    return n(v2, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v2) {
    return n(v2, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v2) {
    return n(v2, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v2) {
    return n(v2, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v2) {
    return n(v2, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v2) {
    return n(v2, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v2) {
    return b(v2, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v2) {
    return b(v2, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v2) {
    return b(v2, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v2) {
    return b(v2, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v2) {
    return b(v2, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v2) {
    return b(v2, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v2) {
    return b(v2, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v2) {
    return b(v2, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v2) {
    return b(v2, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v2) {
    return b(v2, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v2) {
    return b(v2, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v2) {
    return b(v2, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v2) {
    return b(v2, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v2) {
    return b(v2, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v2) {
    return b(v2, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v2) {
    return b(v2, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v2) {
    return b(v2, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v2) {
    return b(v2, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v2) {
    return b(v2, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v2) {
    return b(v2, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v2) {
    return b(v2, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v2) {
    return b(v2, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v2) {
    return b(v2, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v2) {
    return b(v2, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v2) {
    return b(v2, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v2) {
    return b(v2, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v2) {
    return b(v2, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v2) {
    return b(v2, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v2) {
    return b(v2, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v2) {
    return b(v2, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v2) {
    return b(v2, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v2) {
    return b(v2, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v2) {
    return new _Typed(_gaurd, "address", v2);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v2) {
    return new _Typed(_gaurd, "bool", !!v2);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v2) {
    return new _Typed(_gaurd, "bytes", v2);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v2) {
    return new _Typed(_gaurd, "string", v2);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v2, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v2, name) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v2) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v2));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type2) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type2) {
        throw new Error(`invalid type: expecetd ${type2}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
let Typed = _Typed;
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress$1(value);
    } catch (error) {
      return this._throwError(error.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress$1(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset2 = reader.readIndex();
      let offsetReader = baseReader.subReader(offset2);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type2 = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type2, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type2, localName) {
    super(type2, type2, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name = "bytes" + String(size2);
    super(name, name, localName, false);
    __publicField(this, "size");
    defineProperties(this, { size: size2 }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$3 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_MAX_UINT256$2 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  constructor(size2, signed, localName) {
    const name = (signed ? "int" : "uint") + size2 * 8;
    super(name, name, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties(this, { size: size2, signed }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$2, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$2)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$3 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type2 = "tuple(" + types.join(",") + ")";
    super("tuple", type2, localName, dynamic);
    __publicField(this, "coders");
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress$1(addr),
    storageKeys: storageKeys.map((storageKey, index2) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index2}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index2) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index2}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
function computeAddress$1(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress$1(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature2) {
  return computeAddress$1(SigningKey.recoverPublicKey(digest, signature2));
}
const BN_0$2 = BigInt(0);
const BN_2 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getVersionedHash(version2, hash2) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256$1(hash2).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress$1(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_0$2;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value2, name) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$2
  };
  if (fields.length === 6) {
    return tx;
  }
  const v2 = handleUint(fields[6], "v");
  const r2 = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r2 === BN_0$2 && s === BN_0$2) {
    tx.chainId = v2;
  } else {
    let chainId = (v2 - BN_35) / BN_2;
    if (chainId < BN_0$2) {
      chainId = BN_0$2;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$2 || (v2 === BN_27 || v2 === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v2
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$2;
  if (tx.chainId != BN_0$2) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$2) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v2 = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$2) {
    v2 = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v2) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v2));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r2 = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature2 = Signature.from({ r: r2, s, yParity });
  tx.signature = signature2;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
let Transaction$1 = (_j = class {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _getSerialized);
    __privateAdd(this, _type, void 0);
    __privateAdd(this, _to, void 0);
    __privateAdd(this, _data3, void 0);
    __privateAdd(this, _nonce, void 0);
    __privateAdd(this, _gasLimit, void 0);
    __privateAdd(this, _gasPrice, void 0);
    __privateAdd(this, _maxPriorityFeePerGas, void 0);
    __privateAdd(this, _maxFeePerGas, void 0);
    __privateAdd(this, _value, void 0);
    __privateAdd(this, _chainId, void 0);
    __privateAdd(this, _sig, void 0);
    __privateAdd(this, _accessList, void 0);
    __privateAdd(this, _maxFeePerBlobGas, void 0);
    __privateAdd(this, _blobVersionedHashes, void 0);
    __privateAdd(this, _kzg, void 0);
    __privateAdd(this, _blobs, void 0);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_0$2);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data3, "0x");
    __privateSet(this, _value, BN_0$2);
    __privateSet(this, _chainId, BN_0$2);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _kzg, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress$1(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$2;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$2;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$2;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data3);
  }
  set data(value) {
    __privateSet(this, _data3, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(value) {
    __privateSet(this, _chainId, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature.from(value));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_0$2;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs2.length; i++) {
      const blob2 = _blobs2[i];
      if (isBytesLike(blob2)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob2);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob2);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob2.commitment);
        blobs.push({
          data: hexlify(blob2.data),
          commitment: commit,
          proof: hexlify(blob2.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    __privateSet(this, _kzg, kzg);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(__privateMethod(this, _getSerialized, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _getSerialized, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _getSerialized, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _j.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v2) => {
      if (v2 == null) {
        return null;
      }
      return v2.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _j();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _j.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _j.from(_parseEip2930(payload));
        case 2:
          return _j.from(_parseEip1559(payload));
        case 3:
          return _j.from(_parseEip4844(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _j();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
}, _type = new WeakMap(), _to = new WeakMap(), _data3 = new WeakMap(), _nonce = new WeakMap(), _gasLimit = new WeakMap(), _gasPrice = new WeakMap(), _maxPriorityFeePerGas = new WeakMap(), _maxFeePerGas = new WeakMap(), _value = new WeakMap(), _chainId = new WeakMap(), _sig = new WeakMap(), _accessList = new WeakMap(), _maxFeePerBlobGas = new WeakMap(), _blobVersionedHashes = new WeakMap(), _kzg = new WeakMap(), _blobs = new WeakMap(), _getSerialized = new WeakSet(), getSerialized_fn = function(signed, sidecar) {
  assert(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
}, _j);
function hashMessage$1(message2) {
  if (typeof message2 === "string") {
    message2 = toUtf8Bytes(message2);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message2.length)),
    message2
  ]));
}
const padding$1 = new Uint8Array(32);
padding$1.fill(0);
const BN__1$1 = BigInt(-1);
const BN_0$1 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight$1(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding$1.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue$1 = toBeHex(BN_1$1, 32);
const hexFalse$1 = toBeHex(BN_0$1, 32);
const domainFieldTypes$1 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames$1 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString$1(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks$1 = {
  name: checkString$1("name"),
  version: checkString$1("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress$1(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder$1(type2) {
  {
    const match = type2.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type2);
      const boundsUpper = mask(BN_MAX_UINT256$1, signed ? width - 1 : width);
      const boundsLower = signed ? (boundsUpper + BN_1$1) * BN__1$1 : BN_0$1;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type2}`, "value", value);
        return toBeHex(signed ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type2.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type2);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type2}`, "value", value);
        return hexPadRight$1(value);
      };
    }
  }
  switch (type2) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress$1(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse$1 : hexTrue$1;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType$1(name, fields) {
  return `${name}(${fields.map(({ name: name2, type: type2 }) => type2 + " " + name2).join(",")})`;
}
function splitArray(type2) {
  const match = type2.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type2 };
}
let TypedDataEncoder$1 = (_k = class {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types3) {
    __privateAdd(this, _getEncoder);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types, void 0);
    __privateAdd(this, _fullTypes, void 0);
    __privateAdd(this, _encoderCache, void 0);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types3).forEach((type2) => {
      types[type2] = _types3[type2].map(({ name, type: type3 }) => {
        let { base: base2, index: index2 } = splitArray(type3);
        if (base2 === "int" && !_types3["int"]) {
          base2 = "int256";
        }
        if (base2 === "uint" && !_types3["uint"]) {
          base2 = "uint256";
        }
        return { name, type: base2 + (index2 || "") };
      });
      links.set(type2, /* @__PURE__ */ new Set());
      parents.set(type2, []);
      subtypes.set(type2, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types));
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types3);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types3);
        const encoder2 = getBaseEncoder$1(baseType);
        if (encoder2) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types3);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types3);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", _types3);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type2, found) {
      assertArgument(!found.has(type2), `circular type reference to ${JSON.stringify(type2)}`, "types", _types3);
      found.add(type2);
      for (const child of links.get(type2)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type2);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      __privateGet(this, _fullTypes).set(name, encodeType$1(name, types[name]) + st.map((t2) => encodeType$1(t2, types[t2])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type2) {
    let encoder2 = __privateGet(this, _encoderCache).get(type2);
    if (!encoder2) {
      encoder2 = __privateMethod(this, _getEncoder, getEncoder_fn).call(this, type2);
      __privateGet(this, _encoderCache).set(type2, encoder2);
    }
    return encoder2;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type2, value) {
    return this.getEncoder(type2)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type2, value, callback) {
    {
      const encoder2 = getBaseEncoder$1(type2);
      if (encoder2) {
        return callback(type2, value);
      }
    }
    const array2 = splitArray(type2).array;
    if (array2) {
      assertArgument(array2.count === -1 || array2.count === value.length, `array length mismatch; expected length ${array2.count}`, "value", value);
      return value.map((v2) => this._visit(array2.prefix, v2, callback));
    }
    const fields = this.types[type2];
    if (fields) {
      return fields.reduce((accum, { name, type: type3 }) => {
        accum[name] = this._visit(type3, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type2}`, "type", type2);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _k(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _k.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _k.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type2 = domainFieldTypes$1[name];
      assertArgument(type2, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type: type2 });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames$1.indexOf(a.name) - domainFieldNames$1.indexOf(b2.name);
    });
    return _k.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      _k.hashDomain(domain),
      _k.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_k.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder2 = _k.from(types);
    encoder2.visit(value, (type2, value2) => {
      if (type2 === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder2.visit(value, (type2, value2) => {
      if (type2 === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _k.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames$1.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks$1[name](value2);
      domainTypes.push({ name, type: domainFieldTypes$1[name] });
    });
    const encoder2 = _k.from(types);
    types = encoder2.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder2.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder2.primaryType,
      message: encoder2.visit(value, (type2, value2) => {
        if (type2.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type2.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type2) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type2);
      })
    };
  }
}, _types = new WeakMap(), _fullTypes = new WeakMap(), _encoderCache = new WeakMap(), _getEncoder = new WeakSet(), getEncoder_fn = function(type2) {
  {
    const encoder2 = getBaseEncoder$1(type2);
    if (encoder2) {
      return encoder2;
    }
  }
  const array2 = splitArray(type2).array;
  if (array2) {
    const subtype = array2.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array2.count === -1 || array2.count === value.length, `array length mismatch; expected length ${array2.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type2];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes).get(type2));
    return (value) => {
      const values = fields.map(({ name, type: type3 }) => {
        const result = this.getEncoder(type3)(value[name]);
        if (__privateGet(this, _fullTypes).has(type3)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type2}`, "type", type2);
}, _k);
function setify$1(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k2) => result.add(k2));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
setify$1(_kwVisibDeploy.split(" "));
const _kwVisib$1 = "constant external internal payable private public pure view override";
setify$1(_kwVisib$1.split(" "));
const _kwTypes$1 = "constructor error event fallback function receive struct";
setify$1(_kwTypes$1.split(" "));
const _kwModifiers$1 = "calldata memory storage payable indexed";
const KwModifiers$1 = setify$1(_kwModifiers$1.split(" "));
const _kwOther$1 = "tuple returns";
const _keywords$1 = [_kwTypes$1, _kwModifiers$1, _kwOther$1, _kwVisib$1].join(" ");
const Keywords$1 = setify$1(_keywords$1.split(" "));
const SimpleTokens$1 = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix$1 = new RegExp("^(\\s*)");
const regexNumberPrefix$1 = new RegExp("^([0-9]+)");
const regexIdPrefix$1 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId$1 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType$1 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
let TokenString$1 = (_l = class {
  constructor(tokens) {
    __privateAdd(this, _subTokenString);
    __privateAdd(this, _offset2, void 0);
    __privateAdd(this, _tokens, void 0);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _l(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type2) {
    if (this.peek().type !== type2) {
      const top = this.peek();
      throw new Error(`expected ${type2}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _subTokenString, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _subTokenString, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type2) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type2 ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
      const token = __privateGet(this, _tokens)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
}, _offset2 = new WeakMap(), _tokens = new WeakMap(), _subTokenString = new WeakSet(), subTokenString_fn = function(from = 0, to = 0) {
  return new _l(__privateGet(this, _tokens).slice(from, to).map((t2) => {
    return Object.freeze(Object.assign({}, t2, {
      match: t2.match - from,
      linkBack: t2.linkBack - from,
      linkNext: t2.linkNext - from
    }));
  }));
}, _l);
function lex$1(text) {
  const tokens = [];
  const throwError2 = (message2) => {
    const token = offset2 < text.length ? JSON.stringify(text[offset2]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset2}: ${message2}`);
  };
  let brackets = [];
  let commas = [];
  let offset2 = 0;
  while (offset2 < text.length) {
    let cur = text.substring(offset2);
    let match = cur.match(regexWhitespacePrefix$1);
    if (match) {
      offset2 += match[1].length;
      cur = text.substring(offset2);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: offset2, value: -1 };
    tokens.push(token);
    let type2 = SimpleTokens$1[cur[0]] || "";
    if (type2) {
      token.type = type2;
      token.text = cur[0];
      offset2++;
      if (type2 === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type2 == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type2 === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type2 === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type2 === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix$1);
    if (match) {
      token.text = match[1];
      offset2 += token.text.length;
      if (Keywords$1.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType$1)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix$1);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset2 += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset2}`);
  }
  return new TokenString$1(tokens.map((t2) => Object.freeze(t2)));
}
function consumeKeywords$1(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
const regexArrayType$1 = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType$1(type2) {
  const match = type2.match(regexType$1);
  assertArgument(match, "invalid type", "type", type2);
  if (type2 === "uint") {
    return "uint256";
  }
  if (type2 === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type2);
  } else if (match[3]) {
    const size2 = parseInt(match[3]);
    assertArgument(size2 !== 0 && size2 <= 256 && size2 % 8 === 0, "invalid numeric width", "type", type2);
  }
  return type2;
}
const _guard$3 = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal$1 = "_ParamTypeInternal";
let ParamType$1 = (_m = class {
  /**
   *  @private
   */
  constructor(guard2, name, type2, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _walkAsync);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard2, _guard$3, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal$1 });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type: type2,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2) => _this.arrayChildren.walk(v2, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2, i) => _this.components[i].walk(v2, process2));
    }
    return process2(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _walkAsync, walkAsync_fn).call(this, promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_m.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _m.from(lex$1(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString$1) {
      let type3 = "", baseType = "";
      let comps = null;
      if (consumeKeywords$1(obj, setify$1(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t2) => _m.from(t2));
        type3 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type3 = verifyBasicType$1(obj.popType("TYPE"));
        baseType = type3;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _m(_guard$3, "", type3, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type3 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords$1(obj, KwModifiers$1);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _m(_guard$3, name2, type3, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId$1), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type2 = obj.type;
    let arrayMatch = type2.match(regexArrayType$1);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _m.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _m(_guard$3, name || "", type2, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type2 === "tuple" || type2.startsWith(
      "tuple("
      /* fix: ) */
    ) || type2.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => _m.from(c)) : null;
      const tuple2 = new _m(_guard$3, name || "", type2, "tuple", indexed, comps, null, null);
      return tuple2;
    }
    type2 = verifyBasicType$1(obj.type);
    return new _m(_guard$3, name || "", type2, type2, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal$1;
  }
}, _walkAsync = new WeakSet(), walkAsync_fn = function(promises, value, process2, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index2) => {
      var _a3;
      __privateMethod(_a3 = childType, _walkAsync, walkAsync_fn).call(_a3, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index2) => {
      var _a3;
      __privateMethod(_a3 = components[index2], _walkAsync, walkAsync_fn).call(_a3, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process2(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
}, _m);
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder2) {
  let message2 = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message2 = "execution reverted";
    const bytes2 = getBytes(data);
    data = hexlify(data);
    if (bytes2.length === 0) {
      message2 += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message2 += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder2.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message2 += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message2 += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code2 = Number(abiCoder2.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code2]
        };
        reason = `Panic due to ${PanicReasons$1.get(code2) || "UNKNOWN"}(${code2})`;
        message2 += `: ${reason}`;
      } catch (error) {
        message2 += " (could not decode panic code)";
      }
    } else {
      message2 += " (unknown custom error)";
    }
  }
  const transaction2 = {
    to: tx.to ? getAddress$1(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction2.from = getAddress$1(tx.from);
  }
  return makeError(message2, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction: transaction2,
    invocation,
    revert
  });
}
const _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _getCoder);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type2) => __privateMethod(this, _getCoder, getCoder_fn).call(this, ParamType$1.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type2) => __privateMethod(this, _getCoder, getCoder_fn).call(this, ParamType$1.from(type2)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type2) => __privateMethod(this, _getCoder, getCoder_fn).call(this, ParamType$1.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};
_getCoder = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _getCoder, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c) => __privateMethod(this, _getCoder, getCoder_fn).call(this, c)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size2 = parseInt(match[2] || "256");
    assertArgument(size2 !== 0 && size2 <= 256 && size2 % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size2 / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size2 = parseInt(match[1]);
    assertArgument(size2 !== 0 && size2 <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size2, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
let AbiCoder = _AbiCoder;
BigInt(0);
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address2, from2]) => {
      assertArgument(address2.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address2;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction$1.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
}
const _VoidSigner = class _VoidSigner extends AbstractSigner {
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address2, provider) {
    super(provider);
    __privateAdd(this, _throwUnsupported);
    /**
     *  The signer address.
     */
    __publicField(this, "address");
    defineProperties(this, { address: address2 });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _VoidSigner(this.address, provider);
  }
  async signTransaction(tx) {
    __privateMethod(this, _throwUnsupported, throwUnsupported_fn).call(this, "transactions", "signTransaction");
  }
  async signMessage(message2) {
    __privateMethod(this, _throwUnsupported, throwUnsupported_fn).call(this, "messages", "signMessage");
  }
  async signTypedData(domain, types, value) {
    __privateMethod(this, _throwUnsupported, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
  }
};
_throwUnsupported = new WeakSet();
throwUnsupported_fn = function(suffix, operation) {
  assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
};
let VoidSigner = _VoidSigner;
const _BaseWallet = class _BaseWallet extends AbstractSigner {
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    /**
     *  The wallet address.
     */
    __publicField(this, "address");
    __privateAdd(this, _signingKey, void 0);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    __privateSet(this, _signingKey, privateKey);
    const address2 = computeAddress$1(this.signingKey.publicKey);
    defineProperties(this, { address: address2 });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return __privateGet(this, _signingKey);
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _BaseWallet(__privateGet(this, _signingKey), provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this.provider) : void 0,
      from: tx.from ? resolveAddress(tx.from, this.provider) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress$1(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction$1.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message2) {
    return this.signMessageSync(message2);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message2) {
    return this.signingKey.sign(hashMessage$1(message2)).serialized;
  }
  async signTypedData(domain, types, value) {
    const populated = await TypedDataEncoder$1.resolveNames(domain, types, value, async (name) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address2 = await this.provider.resolveName(name);
      assert(address2 != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address2;
    });
    return this.signingKey.sign(TypedDataEncoder$1.hash(populated.domain, types, populated.value)).serialized;
  }
};
_signingKey = new WeakMap();
let BaseWallet = _BaseWallet;
const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words2, sep) {
  let initial = 97;
  return words2.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode2(data, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all2, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode2(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}
class Wordlist {
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    __publicField(this, "locale");
    defineProperties(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words2) {
    return words2.join(" ");
  }
}
class WordlistOwl extends Wordlist {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum2) {
    super(locale);
    __privateAdd(this, _loadWords);
    __privateAdd(this, _data4, void 0);
    __privateAdd(this, _checksum, void 0);
    __privateAdd(this, _words, void 0);
    __privateSet(this, _data4, data);
    __privateSet(this, _checksum, checksum2);
    __privateSet(this, _words, null);
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return __privateGet(this, _data4);
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(__privateGet(this, _data4));
  }
  getWord(index2) {
    const words2 = __privateMethod(this, _loadWords, loadWords_fn).call(this);
    assertArgument(index2 >= 0 && index2 < words2.length, `invalid word index: ${index2}`, "index", index2);
    return words2[index2];
  }
  getWordIndex(word) {
    return __privateMethod(this, _loadWords, loadWords_fn).call(this).indexOf(word);
  }
}
_data4 = new WeakMap();
_checksum = new WeakMap();
_words = new WeakMap();
_loadWords = new WeakSet();
loadWords_fn = function() {
  if (__privateGet(this, _words) == null) {
    const words2 = this._decodeWords();
    const checksum2 = id(words2.join("\n") + "\n");
    if (checksum2 !== __privateGet(this, _checksum)) {
      throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
    }
    __privateSet(this, _words, words2);
  }
  return __privateGet(this, _words);
};
const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist = null;
class LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new LangEn();
    }
    return wordlist;
  }
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset2 = 0;
  for (let i = 0; i < words2.length; i++) {
    let index2 = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index2 >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset2 >> 3] |= 1 << 7 - offset2 % 8;
      }
      offset2++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha256$1(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha256$1(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
}
const _guard$2 = {};
class Mnemonic {
  /**
   *  @private
   */
  constructor(guard2, entropy, phrase, password, wordlist2) {
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    __publicField(this, "phrase");
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    __publicField(this, "password");
    /**
     *  The wordlist for this mnemonic.
     */
    __publicField(this, "wordlist");
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    __publicField(this, "entropy");
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard2, _guard$2, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new Mnemonic(_guard$2, entropy, phrase, password, wordlist2);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new Mnemonic(_guard$2, hexlify(entropy), phrase, password, wordlist2);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error) {
    }
    return false;
  }
}
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$1 = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
const rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
const S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
const Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
const T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
const T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
const T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
const T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
const T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
const T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
const T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
const T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
const U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
const U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
const U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
const U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0; i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}
class AES {
  get key() {
    return __classPrivateFieldGet$1(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet$1(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet$1(this, _AES_Ke, [], "f");
    __classPrivateFieldSet$1(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet$1(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet$1(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk2 = convertToInt32(this.key);
    let index2;
    for (let i = 0; i < KC; i++) {
      index2 = i >> 2;
      __classPrivateFieldGet$1(this, _AES_Ke, "f")[index2][i % 4] = tk2[i];
      __classPrivateFieldGet$1(this, _AES_Kd, "f")[rounds - index2][i % 4] = tk2[i];
    }
    let rconpointer = 0;
    let t2 = KC, tt;
    while (t2 < roundKeyCount) {
      tt = tk2[KC - 1];
      tk2[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk2[i2] ^= tk2[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk2[i2] ^= tk2[i2 - 1];
        }
        tt = tk2[KC / 2 - 1];
        tk2[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk2[i2] ^= tk2[i2 - 1];
        }
      }
      let i = 0, r2, c;
      while (i < KC && t2 < roundKeyCount) {
        r2 = t2 >> 2;
        c = t2 % 4;
        __classPrivateFieldGet$1(this, _AES_Ke, "f")[r2][c] = tk2[i];
        __classPrivateFieldGet$1(this, _AES_Kd, "f")[rounds - r2][c] = tk2[i++];
        t2++;
      }
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let c = 0; c < 4; c++) {
        tt = __classPrivateFieldGet$1(this, _AES_Kd, "f")[r2][c];
        __classPrivateFieldGet$1(this, _AES_Kd, "f")[r2][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$1(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t2 = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t2[i] ^= __classPrivateFieldGet$1(this, _AES_Ke, "f")[0][i];
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T1[t2[i] >> 24 & 255] ^ T2[t2[(i + 1) % 4] >> 16 & 255] ^ T3[t2[(i + 2) % 4] >> 8 & 255] ^ T4[t2[(i + 3) % 4] & 255] ^ __classPrivateFieldGet$1(this, _AES_Ke, "f")[r2][i];
      }
      t2 = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$1(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t2[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t2[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$1(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t2 = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t2[i] ^= __classPrivateFieldGet$1(this, _AES_Kd, "f")[0][i];
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T5[t2[i] >> 24 & 255] ^ T6[t2[(i + 3) % 4] >> 16 & 255] ^ T7[t2[(i + 2) % 4] >> 8 & 255] ^ T8[t2[(i + 1) % 4] & 255] ^ __classPrivateFieldGet$1(this, _AES_Kd, "f")[r2][i];
      }
      t2 = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$1(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t2[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t2[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
class ModeOfOperation {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
}
var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index2 = 15; index2 >= 0; --index2) {
      __classPrivateFieldGet(this, _CTR_counter, "f")[index2] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a3, _b2;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b2 = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a3 = _b2++, _b2), "f"), _a3];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
function zpad$1(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
const defaultPath$1 = "m/44'/60'/0'/0/0";
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes$1(32);
  let N2 = 1 << 17, r2 = 8, p2 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p2 = options.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r2 === "number" && r2 > 0 && Number.isSafeInteger(r2), "invalid scrypt r parameter", "options.r", r2);
  assertArgument(typeof p2 === "number" && p2 > 0 && Number.isSafeInteger(p2), "invalid scrypt p parameter", "options.p", p2);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r: r2, p: p2 };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes$1(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes$1(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client2 = options.client != null ? options.client : `ethers/${version$1}`;
    const path = account.mnemonic.path || defaultPath$1;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes$1(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad$1(now.getUTCMonth() + 1, 2) + "-" + zpad$1(now.getUTCDate(), 2) + "T" + zpad$1(now.getUTCHours(), 2) + "-" + zpad$1(now.getUTCMinutes(), 2) + "-" + zpad$1(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client: client2,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
const defaultPath = "m/44'/60'/0'/0/0";
const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
const HardenedBit = 2147483648;
const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const Nibbles = "0123456789abcdef";
function zpad(value, length) {
  let result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value2) {
  const value = getBytes(_value2);
  const check = dataSlice(sha256$1(sha256$1(value)), 0, 4);
  const bytes2 = concat([value, check]);
  return encodeBase58(bytes2);
}
const _guard$1 = {};
function ser_I(index2, chainCode, publicKey2, privateKey) {
  const data = new Uint8Array(37);
  if (index2 & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey2));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index2 >> 24 - i & 255;
  }
  const I2 = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I2.slice(0, 32), IR: I2.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index2 = parseInt(component.substring(0, component.length - 1));
      assertArgument(index2 < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index2);
    } else if (component.match(/^[0-9]+$/)) {
      const index2 = parseInt(component);
      assertArgument(index2 < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index2);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
const _HDNodeWallet = class _HDNodeWallet extends BaseWallet {
  /**
   *  @private
   */
  constructor(guard2, signingKey, parentFingerprint, chainCode, path, index2, depth, mnemonic, provider) {
    super(signingKey, provider);
    __privateAdd(this, _account);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    __publicField(this, "mnemonic");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provide full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  encode it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard2, _guard$1, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd160(sha256$1(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index: index2,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new _HDNodeWallet(_guard$1, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(__privateMethod(this, _account, account_fn).call(this), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(__privateMethod(this, _account, account_fn).call(this), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard$1, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
      if (index2 & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL: IL2 } = ser_I(index2, this.chainCode, this.publicKey, this.privateKey);
    const ki2 = new SigningKey(toBeHex((toBigInt(IL2) + BigInt(this.privateKey)) % N, 32));
    return new _HDNodeWallet(_guard$1, ki2, this.fingerprint, hexlify(IR), path, index2, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index2 = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey2 = hexlify(key);
        return new HDNodeVoidWallet(_guard$1, computeAddress$1(publicKey2), publicKey2, parentFingerprint, chainCode, null, index2, depth, null);
      }
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard$1, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index2, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path, wordlist2) {
    var _a3;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes$1(16), password, wordlist2);
    return __privateMethod(_a3 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a3, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path) {
    var _a3;
    if (!path) {
      path = defaultPath;
    }
    return __privateMethod(_a3 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a3, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path, wordlist2) {
    var _a3;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return __privateMethod(_a3 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a3, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    var _a3;
    return __privateMethod(_a3 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a3, seed, null);
  }
};
_account = new WeakSet();
account_fn = function() {
  const account = { address: this.address, privateKey: this.privateKey };
  const m2 = this.mnemonic;
  if (this.path && m2 && m2.wordlist.locale === "en" && m2.password === "") {
    account.mnemonic = {
      path: this.path,
      locale: "en",
      entropy: m2.entropy
    };
  }
  return account;
};
_fromSeed = new WeakSet();
fromSeed_fn = function(_seed, mnemonic) {
  assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
  const seed = getBytes(_seed, "seed");
  assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
  const I2 = getBytes(computeHmac("sha512", MasterSecret, seed));
  const signingKey = new SigningKey(hexlify(I2.slice(0, 32)));
  return new _HDNodeWallet(_guard$1, signingKey, "0x00000000", hexlify(I2.slice(32)), "m", 0, 0, mnemonic, null);
};
__privateAdd(_HDNodeWallet, _fromSeed);
let HDNodeWallet = _HDNodeWallet;
class HDNodeVoidWallet extends VoidSigner {
  /**
   *  @private
   */
  constructor(guard2, address2, publicKey2, parentFingerprint, chainCode, path, index2, depth, provider) {
    super(address2, provider);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent node fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard2, _guard$1, "HDNodeVoidWallet");
    defineProperties(this, { publicKey: publicKey2 });
    const fingerprint = dataSlice(ripemd160(sha256$1(publicKey2)), 0, 4);
    defineProperties(this, {
      publicKey: publicKey2,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index: index2,
      depth
    });
  }
  connect(provider) {
    return new HDNodeVoidWallet(_guard$1, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
      if (index2 & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL: IL2 } = ser_I(index2, this.chainCode, this.publicKey, null);
    const Ki2 = SigningKey.addPoints(IL2, this.publicKey, true);
    const address2 = computeAddress$1(Ki2);
    return new HDNodeVoidWallet(_guard$1, address2, Ki2, this.fingerprint, hexlify(IR), path, index2, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
}
const wordlists = {
  en: LangEn.wordlist()
};
var _a;
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k2) => result.add(k2));
  return Object.freeze(result);
}
const _kwVisib = "constant external internal payable private public pure view";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(trcToken|address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
  constructor(tokens) {
    __privateAdd(this, _subTokenString2);
    __privateAdd(this, _offset3, void 0);
    __privateAdd(this, _tokens2, void 0);
    __privateSet(this, _offset3, 0);
    __privateSet(this, _tokens2, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset3);
  }
  get length() {
    return __privateGet(this, _tokens2).length - __privateGet(this, _offset3);
  }
  clone() {
    return new _a(__privateGet(this, _tokens2));
  }
  reset() {
    __privateSet(this, _offset3, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type2) {
    if (this.peek().type !== type2) {
      throw new Error(`expected ${type2}; got ${JSON.stringify(this.peek())}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _subTokenString2, subTokenString_fn2).call(this, __privateGet(this, _offset3) + 1, top.match + 1);
    __privateSet(this, _offset3, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset3) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _subTokenString2, subTokenString_fn2).call(this, __privateGet(this, _offset3) + 1, link));
      __privateSet(this, _offset3, link);
    }
    __privateSet(this, _offset3, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset3) >= __privateGet(this, _tokens2).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens2)[__privateGet(this, _offset3)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type2) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type2 ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset3)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset3); i < __privateGet(this, _tokens2).length; i++) {
      const token = __privateGet(this, _tokens2)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
}
_offset3 = new WeakMap();
_tokens2 = new WeakMap();
_subTokenString2 = new WeakSet();
subTokenString_fn2 = function(from = 0, to = 0) {
  return new _a(__privateGet(this, _tokens2).slice(from, to).map((t2) => {
    return Object.freeze(Object.assign({}, t2, {
      match: t2.match - from,
      linkBack: t2.linkBack - from,
      linkNext: t2.linkNext - from
    }));
  }));
};
_a = TokenString;
function lex(text) {
  const tokens = [];
  const throwError2 = (message2) => {
    const token = offset2 < text.length ? JSON.stringify(text[offset2]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset2}: ${message2}`);
  };
  const brackets = [];
  const commas = [];
  let offset2 = 0;
  while (offset2 < text.length) {
    let cur = text.substring(offset2);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset2 += match[1].length;
      cur = text.substring(offset2);
    }
    const token = {
      depth: brackets.length,
      linkBack: -1,
      linkNext: -1,
      match: -1,
      type: "",
      text: "",
      offset: offset2,
      value: -1
    };
    tokens.push(token);
    const type2 = SimpleTokens[cur[0]] || "";
    if (type2) {
      token.type = type2;
      token.text = cur[0];
      offset2++;
      if (type2 === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type2 == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type2 === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type2 === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type2 === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset2 += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset2 += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset2}`);
  }
  return new TokenString(tokens.map((t2) => Object.freeze(t2)));
}
function allowSingle(set, allowed) {
  const included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type2, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type2) {
      throw new Error(`expected ${type2}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  const modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t2) => ParamType.from(t2, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type2) {
  const match = type2.match(regexType);
  assertArgument(match, "invalid type", "type", type2);
  if (type2 === "uint") {
    return "uint256";
  }
  if (type2 === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type2);
  } else if (match[3]) {
    const size2 = parseInt(match[3]);
    assertArgument(size2 !== 0 && size2 <= 256 && size2 % 8 === 0, "invalid numeric width", "type", type2);
  }
  return type2;
}
const _guard = {};
const internal = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
const _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard2, name, type2, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _walkAsync2);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard2, _guard, "ParamType");
    Object.defineProperty(this, internal, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type: type2,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        if (format !== "sighash") {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      return value.map((v2) => {
        var _a3;
        return (_a3 = this.arrayChildren) == null ? void 0 : _a3.walk(v2, process2);
      });
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      return value.map((v2, i) => {
        var _a3;
        return (_a3 = this.components) == null ? void 0 : _a3[i].walk(v2, process2);
      });
    }
    return process2(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS naes by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _walkAsync2, walkAsync_fn2).call(this, promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ParamType.from(lex(obj), allowIndexed);
    } else if (obj instanceof TokenString) {
      let type3 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t2) => _ParamType.from(t2));
        type3 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type3 = verifyBasicType(obj.popType("TYPE"));
        baseType = type3;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard, "", type3, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type3 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard, name2, type3, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type2 = obj.type;
    const arrayMatch = type2.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard, name || "", type2, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type2 === "tuple" || type2.startsWith(
      "tuple("
      /* fix: ) */
    ) || type2.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => _ParamType.from(c)) : null;
      const tuple2 = new _ParamType(_guard, name || "", type2, "tuple", indexed, comps, null, null);
      return tuple2;
    }
    type2 = verifyBasicType(obj.type);
    return new _ParamType(_guard, name || "", type2, type2, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal] === ParamTypeInternal;
  }
};
_walkAsync2 = new WeakSet();
walkAsync_fn2 = function(promises, value, process2, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index2) => {
      var _a3;
      __privateMethod(_a3 = childType, _walkAsync2, walkAsync_fn2).call(_a3, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index2) => {
      var _a3;
      __privateMethod(_a3 = components[index2], _walkAsync2, walkAsync_fn2).call(_a3, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process2(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
let ParamType = _ParamType;
class Fragment {
  /**
   *  @private
   */
  constructor(guard2, type2, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard2, _guard, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type: type2, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e2) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type2 = obj.peekKeyword(KwTypes);
      switch (type2) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard2, type2, name, inputs) {
    super(guard2, type2, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format, params) {
  return "(" + params.map((p2) => p2.format(format)).join(format === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name, inputs) {
    super(guard2, "error", name, inputs);
    Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard, name, inputs);
    }
    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name, inputs, anonymous) {
    super(guard2, "event", name, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new EventFragment(_guard, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return EventFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard, name, inputs, anonymous);
    }
    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p2) => ParamType.from(p2, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard2, type2, inputs, payable, gas) {
    super(guard2, type2, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal, {
      value: ConstructorFragmentInternal
    });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
      operation: "format(sighash)"
    });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    result.push(this.payable ? "payable" : "nonpayable");
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ConstructorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, setify(["payable"])).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  constructor(guard2, inputs, payable) {
    super(guard2, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type2 = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: type2, stateMutability });
    }
    return `${type2}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return FallbackFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type2 = obj.popKeyword(setify(["fallback", "receive"]));
      if (type2 === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name, stateMutability, inputs, outputs, gas) {
    super(guard2, "function", name, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, {
      constant,
      gas,
      outputs,
      payable,
      stateMutability
    });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return FunctionFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name, inputs) {
    super(guard2, "struct", name, inputs);
    Object.defineProperty(this, internal, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      return StructFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard, name, inputs);
    }
    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === StructFragmentInternal;
  }
}
class LogDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature: signature2,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector
    });
  }
}
class Indexed {
  /**
   *  @_ignore:
   */
  constructor(hash2) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties(this, { hash: hash2, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message2) => {
      return `reverted with reason string ${JSON.stringify(message2)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code2) => {
      let reason = "unknown panic code";
      if (code2 >= 0 && code2 <= 255 && PanicReasons[code2.toString()]) {
        reason = PanicReasons[code2.toString()];
      }
      return `reverted with panic code 0x${code2.toString(16)} (${reason})`;
    }
  }
};
const _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    // Find a function definition by any means necessary (unless it is ambiguous)
    __privateAdd(this, _getFunction);
    // Find an event definition by any means necessary (unless it is ambiguous)
    __privateAdd(this, _getEvent);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors, void 0);
    __privateAdd(this, _events, void 0);
    __privateAdd(this, _functions, void 0);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder, void 0);
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a of abi2) {
      try {
        frags.push(Fragment.from(a));
      } catch (error) {
        console.log("EE", error);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index2) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, {
            deploy: fragment
          });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index2}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature2 = fragment.format();
      if (bucket.has(signature2)) {
        return;
      }
      bucket.set(signature2, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi2 = this.fragments.map((f2) => f2.format(format));
    return abi2;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi2 = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi2.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = __privateMethod(this, _getFunction, getFunction_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!__privateMethod(this, _getFunction, getFunction_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return __privateMethod(this, _getFunction, getFunction_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names = Array.from(__privateGet(this, _functions).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _functions).get(name), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = __privateMethod(this, _getEvent, getEvent_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!__privateMethod(this, _getEvent, getEvent_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return __privateMethod(this, _getEvent, getEvent_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names = Array.from(__privateGet(this, _events).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _events).get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of __privateGet(this, _errors)) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names = Array.from(__privateGet(this, _errors).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _errors).get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
      getSelector(fragment: ErrorFragment | FunctionFragment): string {
          if (typeof(fragment) === "string") {
              const matches: Array<Fragment> = [ ];
  
              try { matches.push(this.getFunction(fragment)); } catch (error) { }
              try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
              if (matches.length === 0) {
                  logger.throwArgumentError("unknown fragment", "key", fragment);
              } else if (matches.length > 1) {
                  logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
              }
  
              fragment = matches[0];
          }
  
          return dataSlice(id(fragment.format()), 0, 4);
      }
          */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return __privateGet(this, _abiCoder).decode(params, data);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message2 = "invalid length for result data";
    const bytes2 = getBytesCopy(data);
    if (bytes2.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes2);
      } catch (error) {
        message2 = "could not decode result data";
      }
    }
    assert(false, message2, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data5, tx) {
    const data = getBytes(_data5, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef2 = this.getError(selector);
      if (ef2) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef2.inputs, data.slice(4));
          error.revert = {
            name: ef2.name,
            signature: ef2.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e2) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", {
      count: values.length,
      expectedCount: fragment.inputs.length
    });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      }
      if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      const param = fragment.inputs[index2];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index2) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index2]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log2) {
    const fragment = this.getEvent(log2.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log2.data, log2.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_getFunction = new WeakSet();
getFunction_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const selector = key.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _functions)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (j >= inputs.length) {
            if (values[j].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
_getEvent = new WeakSet();
getEvent_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const eventTopic = key.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _events)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
let Interface = _Interface;
const splitSignature = (sigBytes) => Signature.from(sigBytes);
const joinSignature = (splitSig) => Signature.from(splitSig).serialized;
const arrayify = (value) => getBytes(value);
const FormatTypes = {
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
};
const isValidMnemonic = Mnemonic.isValidMnemonic;
computeHmac.register((algorithm, key, data) => {
  return computeHmac._(algorithm, Buffer.from(key), Buffer.from(data));
});
const ethersUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder,
  FormatTypes,
  Interface,
  Mnemonic,
  Signature,
  SigningKey,
  Wordlist,
  arrayify,
  concat,
  ethersHDNodeWallet: HDNodeWallet,
  id,
  isValidMnemonic,
  joinSignature,
  keccak256,
  recoverAddress,
  sha256: sha256$1,
  splitSignature,
  toUtf8Bytes,
  toUtf8String,
  wordlists
}, Symbol.toStringTag, { value: "Module" }));
const ADDRESS_SIZE = 34;
const ADDRESS_PREFIX = "41";
const ADDRESS_PREFIX_BYTE = 65;
const ADDRESS_PREFIX_REGEX = /^(41)/;
const TRON_BIP39_PATH_PREFIX = "m/44'/195'";
const TRON_BIP39_PATH_INDEX_0 = TRON_BIP39_PATH_PREFIX + "/0'/0/0";
function fromHex(address2) {
  if (!isHex(address2))
    return address2;
  return getBase58CheckAddress(hexStr2byteArray(address2.replace(/^0x/, ADDRESS_PREFIX)));
}
function toHex$1(address2) {
  if (isHex(address2))
    return address2.toLowerCase().replace(/^0x/, ADDRESS_PREFIX);
  return byteArray2hexStr(decodeBase58Address(address2)).toLowerCase();
}
function getChecksumAddress(address2) {
  address2 = address2.toLowerCase();
  const chars = address2.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = hexStr2byteArray(keccak256(expanded).slice(2));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return ADDRESS_PREFIX + chars.join("");
}
function toChecksumAddress(address2) {
  if (!isAddress(address2))
    throw new Error(`'${address2}' is not a valid address string`);
  return getChecksumAddress(toHex$1(address2));
}
function isChecksumAddress(address2) {
  if (!isHex(address2) || address2.length !== 42)
    return false;
  try {
    return toChecksumAddress(address2) === address2;
  } catch {
    return false;
  }
}
function fromPrivateKey(privateKey, strict = false) {
  try {
    return pkToAddress(privateKey, strict);
  } catch {
    return false;
  }
}
function isAddress(address2) {
  if (!address2 || !isString$1(address2))
    return false;
  if (address2.length === 42) {
    try {
      return isAddress(getBase58CheckAddress(hexStr2byteArray(address2)));
    } catch (err) {
      return false;
    }
  }
  try {
    return isAddressValid(address2);
  } catch (err) {
    return false;
  }
}
const address = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ADDRESS_PREFIX,
  ADDRESS_PREFIX_BYTE,
  ADDRESS_PREFIX_REGEX,
  ADDRESS_SIZE,
  TRON_BIP39_PATH_INDEX_0,
  TRON_BIP39_PATH_PREFIX,
  fromHex,
  fromPrivateKey,
  isAddress,
  isChecksumAddress,
  toChecksumAddress,
  toHex: toHex$1
}, Symbol.toStringTag, { value: "Module" }));
const ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const ALPHABET_MAP = {};
for (let i = 0; i < ALPHABET$1.length; i++)
  ALPHABET_MAP[ALPHABET$1.charAt(i)] = i;
const BASE = 58;
function encode58(buffer2) {
  if (buffer2.length === 0)
    return "";
  let i;
  let j;
  const digits = [0];
  for (i = 0; i < buffer2.length; i++) {
    for (j = 0; j < digits.length; j++)
      digits[j] <<= 8;
    digits[0] += buffer2[i];
    let carry = 0;
    for (j = 0; j < digits.length; ++j) {
      digits[j] += carry;
      carry = digits[j] / BASE | 0;
      digits[j] %= BASE;
    }
    while (carry) {
      digits.push(carry % BASE);
      carry = carry / BASE | 0;
    }
  }
  for (i = 0; buffer2[i] === 0 && i < buffer2.length - 1; i++)
    digits.push(0);
  return digits.reverse().map((digit) => ALPHABET$1[digit]).join("");
}
function decode58(string2) {
  if (string2.length === 0)
    return [];
  let i;
  let j;
  const bytes2 = [0];
  for (i = 0; i < string2.length; i++) {
    const c = string2[i];
    if (!(c in ALPHABET_MAP))
      throw new Error("Non-base58 character");
    for (j = 0; j < bytes2.length; j++)
      bytes2[j] *= BASE;
    bytes2[0] += ALPHABET_MAP[c];
    let carry = 0;
    for (j = 0; j < bytes2.length; ++j) {
      bytes2[j] += carry;
      carry = bytes2[j] >> 8;
      bytes2[j] &= 255;
    }
    while (carry) {
      bytes2.push(carry & 255);
      carry >>= 8;
    }
  }
  for (i = 0; string2[i] === "1" && i < string2.length - 1; i++)
    bytes2.push(0);
  return bytes2.reverse();
}
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode58,
  encode58
}, Symbol.toStringTag, { value: "Module" }));
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$1 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString$1.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb2) => {
      callbacks.push(cb2);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb2) => setTimeout(cb2);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$3 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(message2, code2, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$3.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$3.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$3.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code2, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$3.isPlainObject(thing) || utils$3.isArray(thing);
}
function removeBrackets(key) {
  return utils$3.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$3.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$3.toFlatObject(utils$3, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$3.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$3.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$3.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$3.isSpecCompliantForm(formData);
  if (!utils$3.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$3.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$3.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$3.isArrayBuffer(value) || utils$3.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$3.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$3.isArray(value) && isFlatArray(value) || (utils$3.isFileList(value) || utils$3.endsWith(key, "[]")) && (arr = utils$3.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index2) {
          !(utils$3.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$3.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$3.forEach(value, function each(el2, key) {
      const result = !(utils$3.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$3.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$3.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder2) {
  const _encode2 = encoder2 ? function(value) {
    return encoder2.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode2(pair[0]) + "=" + _encode2(pair[1]);
  }, "").join("&");
};
function encode3(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode2 = options && options.encode || encode3;
  if (utils$3.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$3.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode2);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$3.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils$2,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$3.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$3.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$3.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$3.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$3.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils$3.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$3.isFormData(formData) && utils$3.isFunction(formData.entries)) {
    const obj = {};
    utils$3.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder2) {
  if (utils$3.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$3.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$3.isObject(data);
    if (isObjectPayload && utils$3.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$3.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$3.isArrayBuffer(data) || utils$3.isBuffer(data) || utils$3.isStream(data) || utils$3.isFile(data) || utils$3.isBlob(data) || utils$3.isReadableStream(data)) {
      return data;
    }
    if (utils$3.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$3.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$3.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$3.isResponse(data) || utils$3.isReadableStream(data)) {
      return data;
    }
    if (data && utils$3.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$3.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$3.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$3.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$3.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$3.isString(value))
    return;
  if (utils$3.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$3.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$3.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value2, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$3.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value2);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$3.forEach(headers, (_value2, _header) => setHeader(_value2, _header, _rewrite));
    if (utils$3.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$3.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$3.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$3.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$3.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$3.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$3.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$3.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$3.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$3.forEach(this, (value, header) => {
      const key = utils$3.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$3.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$3.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$3.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$3.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$3.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$3.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message2, config2, request) {
  AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils$3.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes2[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer2;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer2) {
        timer2 = setTimeout(() => {
          timer2 = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange2 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$3.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$3.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$3.isString(path) && cookie.push("path=" + path);
      utils$3.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source)) {
      return utils$3.merge.call({ caseless }, target, source);
    } else if (utils$3.isPlainObject(source)) {
      return utils$3.merge({}, source);
    } else if (utils$3.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b2, prop, caseless) {
    if (!utils$3.isUndefined(b2)) {
      return getMergedValue(a, b2, prop, caseless);
    } else if (!utils$3.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b2) {
    if (!utils$3.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a, b2) {
    if (!utils$3.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$3.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b2, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b2), prop, true)
  };
  utils$3.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$3.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$3.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$3.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$3.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$3.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer2 = timeout && setTimeout(() => {
      timer2 = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer2 && clearTimeout(timer2);
        timer2 = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$3.asap(unsubscribe);
    return signal;
  }
};
const composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$3.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils$3.isFunction(res[type2]) ? (res2) => res2[type2]() : (_, config2) => {
      throw new AxiosError(`Response type '${type2}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$3.isBlob(body)) {
    return body.size;
  }
  if (utils$3.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$3.isArrayBufferView(body) || utils$3.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$3.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$3.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$3.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$3.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$3.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$3.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$3.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config2, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$3.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$3.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$3.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.9";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$3.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    validator.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$3.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$3.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils$3.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$3.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message2, config2, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$3.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance2 = bind(Axios$1.prototype.request, context);
  utils$3.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
  utils$3.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create3(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$3.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
class HttpProvider {
  constructor(host, timeout = 3e4, user = "", password = "", headers = {}, statusPage = "/") {
    __publicField(this, "host");
    __publicField(this, "timeout");
    __publicField(this, "user");
    __publicField(this, "password");
    __publicField(this, "headers");
    __publicField(this, "statusPage");
    __publicField(this, "instance");
    if (!isValidURL(host))
      throw new Error("Invalid URL provided to HttpProvider");
    if (isNaN(timeout) || timeout < 0)
      throw new Error("Invalid timeout duration provided");
    if (!isObject$2(headers))
      throw new Error("Invalid headers object provided");
    host = host.replace(/\/+$/, "");
    this.host = host;
    this.timeout = timeout;
    this.user = user;
    this.password = password;
    this.headers = headers;
    this.statusPage = statusPage;
    this.instance = axios$1.create({
      baseURL: host,
      timeout,
      headers,
      auth: user ? {
        username: user,
        password
      } : void 0
    });
  }
  setStatusPage(statusPage = "/") {
    this.statusPage = statusPage;
  }
  async isConnected(statusPage = this.statusPage) {
    return this.request(statusPage).then((data) => {
      return hasProperties(data, "blockID", "block_header");
    }).catch(() => false);
  }
  request(url, payload = {}, method = "get") {
    method = method.toLowerCase();
    return this.instance.request({
      data: method == "post" && Object.keys(payload).length ? payload : null,
      params: method == "get" && payload,
      url,
      method
    }).then(({ data }) => data);
  }
}
const providers = { HttpProvider };
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE2(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE2(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners2.length; i < length; i++) {
        if (listeners2[i].fn !== fn || once && !listeners2[i].once || context && listeners2[i].context !== context) {
          events.push(listeners2[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports);
var semver$1 = { exports: {} };
(function(module, exports) {
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re2 = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src2 = exports.src = [];
  var R2 = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  function makeSafeRe(value) {
    for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
      var token = safeRegexReplacements[i2][0];
      var max = safeRegexReplacements[i2][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  var NUMERICIDENTIFIER = R2++;
  src2[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R2++;
  src2[NUMERICIDENTIFIERLOOSE] = "\\d+";
  var NONNUMERICIDENTIFIER = R2++;
  src2[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  var MAINVERSION = R2++;
  src2[MAINVERSION] = "(" + src2[NUMERICIDENTIFIER] + ")\\.(" + src2[NUMERICIDENTIFIER] + ")\\.(" + src2[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R2++;
  src2[MAINVERSIONLOOSE] = "(" + src2[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src2[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src2[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R2++;
  src2[PRERELEASEIDENTIFIER] = "(?:" + src2[NUMERICIDENTIFIER] + "|" + src2[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R2++;
  src2[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src2[NUMERICIDENTIFIERLOOSE] + "|" + src2[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R2++;
  src2[PRERELEASE] = "(?:-(" + src2[PRERELEASEIDENTIFIER] + "(?:\\." + src2[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R2++;
  src2[PRERELEASELOOSE] = "(?:-?(" + src2[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src2[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R2++;
  src2[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  var BUILD = R2++;
  src2[BUILD] = "(?:\\+(" + src2[BUILDIDENTIFIER] + "(?:\\." + src2[BUILDIDENTIFIER] + ")*))";
  var FULL = R2++;
  var FULLPLAIN = "v?" + src2[MAINVERSION] + src2[PRERELEASE] + "?" + src2[BUILD] + "?";
  src2[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src2[MAINVERSIONLOOSE] + src2[PRERELEASELOOSE] + "?" + src2[BUILD] + "?";
  var LOOSE = R2++;
  src2[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R2++;
  src2[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R2++;
  src2[XRANGEIDENTIFIERLOOSE] = src2[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R2++;
  src2[XRANGEIDENTIFIER] = src2[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R2++;
  src2[XRANGEPLAIN] = "[v=\\s]*(" + src2[XRANGEIDENTIFIER] + ")(?:\\.(" + src2[XRANGEIDENTIFIER] + ")(?:\\.(" + src2[XRANGEIDENTIFIER] + ")(?:" + src2[PRERELEASE] + ")?" + src2[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R2++;
  src2[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src2[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src2[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src2[XRANGEIDENTIFIERLOOSE] + ")(?:" + src2[PRERELEASELOOSE] + ")?" + src2[BUILD] + "?)?)?";
  var XRANGE = R2++;
  src2[XRANGE] = "^" + src2[GTLT] + "\\s*" + src2[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R2++;
  src2[XRANGELOOSE] = "^" + src2[GTLT] + "\\s*" + src2[XRANGEPLAINLOOSE] + "$";
  var COERCE = R2++;
  src2[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R2++;
  src2[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R2++;
  src2[TILDETRIM] = "(\\s*)" + src2[LONETILDE] + "\\s+";
  re2[TILDETRIM] = new RegExp(src2[TILDETRIM], "g");
  safeRe[TILDETRIM] = new RegExp(makeSafeRe(src2[TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R2++;
  src2[TILDE] = "^" + src2[LONETILDE] + src2[XRANGEPLAIN] + "$";
  var TILDELOOSE = R2++;
  src2[TILDELOOSE] = "^" + src2[LONETILDE] + src2[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R2++;
  src2[LONECARET] = "(?:\\^)";
  var CARETTRIM = R2++;
  src2[CARETTRIM] = "(\\s*)" + src2[LONECARET] + "\\s+";
  re2[CARETTRIM] = new RegExp(src2[CARETTRIM], "g");
  safeRe[CARETTRIM] = new RegExp(makeSafeRe(src2[CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  var CARET = R2++;
  src2[CARET] = "^" + src2[LONECARET] + src2[XRANGEPLAIN] + "$";
  var CARETLOOSE = R2++;
  src2[CARETLOOSE] = "^" + src2[LONECARET] + src2[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R2++;
  src2[COMPARATORLOOSE] = "^" + src2[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R2++;
  src2[COMPARATOR] = "^" + src2[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R2++;
  src2[COMPARATORTRIM] = "(\\s*)" + src2[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src2[XRANGEPLAIN] + ")";
  re2[COMPARATORTRIM] = new RegExp(src2[COMPARATORTRIM], "g");
  safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src2[COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R2++;
  src2[HYPHENRANGE] = "^\\s*(" + src2[XRANGEPLAIN] + ")\\s+-\\s+(" + src2[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R2++;
  src2[HYPHENRANGELOOSE] = "^\\s*(" + src2[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src2[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R2++;
  src2[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R2; i++) {
    debug(i, src2[i]);
    if (!re2[i]) {
      re2[i] = new RegExp(src2[i]);
      safeRe[i] = new RegExp(makeSafeRe(src2[i]));
    }
  }
  exports.parse = parse2;
  function parse2(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    var r2 = options.loose ? safeRe[LOOSE] : safeRe[FULL];
    if (!r2.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  }
  exports.valid = valid;
  function valid(version2, options) {
    var v2 = parse2(version2, options);
    return v2 ? v2.version : null;
  }
  exports.clean = clean;
  function clean(version2, options) {
    var s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports.SemVer = SemVer;
  function SemVer(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      if (version2.loose === options.loose) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError("Invalid Version: " + version2);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version2, options);
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    var m2 = version2.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
    if (!m2) {
      throw new TypeError("Invalid Version: " + version2);
    }
    this.raw = version2;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map(function(id2) {
        if (/^[0-9]+$/.test(id2)) {
          var num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER2) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b2 = other.prerelease[i2];
      debug("prerelease compare", i2, a, b2);
      if (a === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b2) {
        continue;
      } else {
        return compareIdentifiers(a, b2);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  function inc(version2, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version2, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v12 = parse2(version1);
      var v2 = parse2(version2);
      var prefix = "";
      if (v12.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v12) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v12[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports.compareIdentifiers = compareIdentifiers;
  var numeric2 = /^[0-9]+$/;
  function compareIdentifiers(a, b2) {
    var anum = numeric2.test(a);
    var bnum = numeric2.test(b2);
    if (anum && bnum) {
      a = +a;
      b2 = +b2;
    }
    return a === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b2 ? -1 : 1;
  }
  exports.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b2) {
    return compareIdentifiers(b2, a);
  }
  exports.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports.compare = compare2;
  function compare2(a, b2, loose) {
    return new SemVer(a, loose).compare(new SemVer(b2, loose));
  }
  exports.compareLoose = compareLoose;
  function compareLoose(a, b2) {
    return compare2(a, b2, true);
  }
  exports.rcompare = rcompare;
  function rcompare(a, b2, loose) {
    return compare2(b2, a, loose);
  }
  exports.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b2) {
      return exports.compare(a, b2, loose);
    });
  }
  exports.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b2) {
      return exports.rcompare(a, b2, loose);
    });
  }
  exports.gt = gt;
  function gt(a, b2, loose) {
    return compare2(a, b2, loose) > 0;
  }
  exports.lt = lt;
  function lt(a, b2, loose) {
    return compare2(a, b2, loose) < 0;
  }
  exports.eq = eq;
  function eq(a, b2, loose) {
    return compare2(a, b2, loose) === 0;
  }
  exports.neq = neq;
  function neq(a, b2, loose) {
    return compare2(a, b2, loose) !== 0;
  }
  exports.gte = gte;
  function gte(a, b2, loose) {
    return compare2(a, b2, loose) >= 0;
  }
  exports.lte = lte;
  function lte(a, b2, loose) {
    return compare2(a, b2, loose) <= 0;
  }
  exports.cmp = cmp;
  function cmp(a, op, b2, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b2 === "object")
          b2 = b2.version;
        return a === b2;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b2 === "object")
          b2 = b2.version;
        return a !== b2;
      case "":
      case "=":
      case "==":
        return eq(a, b2, loose);
      case "!=":
        return neq(a, b2, loose);
      case ">":
        return gt(a, b2, loose);
      case ">=":
        return gte(a, b2, loose);
      case "<":
        return lt(a, b2, loose);
      case "<=":
        return lte(a, b2, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r2 = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
    var m2 = comp.match(r2);
    if (!m2) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m2[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m2[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version2) {
    debug("Comparator.test", version2, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version2 === "string") {
      version2 = new SemVer(version2, this.options);
    }
    return cmp(version2, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[COMPARATORTRIM]);
    range = range.replace(safeRe[TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[CARETTRIM], caretTrimReplace);
    var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id2) {
    return !id2 || id2.toLowerCase() === "x" || id2 === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r2 = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
    return comp.replace(r2, function(_, M2, m2, p2, pr) {
      debug("tilde", comp, _, M2, m2, p2, pr);
      var ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M2 + ".0.0 <" + (+M2 + 1) + ".0.0";
      } else if (isX(p2)) {
        ret = ">=" + M2 + "." + m2 + ".0 <" + M2 + "." + (+m2 + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + M2 + "." + (+m2 + 1) + ".0";
      } else {
        ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + M2 + "." + (+m2 + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r2 = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
    return comp.replace(r2, function(_, M2, m2, p2, pr) {
      debug("caret", comp, _, M2, m2, p2, pr);
      var ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M2 + ".0.0 <" + (+M2 + 1) + ".0.0";
      } else if (isX(p2)) {
        if (M2 === "0") {
          ret = ">=" + M2 + "." + m2 + ".0 <" + M2 + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M2 + "." + m2 + ".0 <" + (+M2 + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + M2 + "." + m2 + "." + (+p2 + 1);
          } else {
            ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + M2 + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + (+M2 + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + M2 + "." + m2 + "." + (+p2 + 1);
          } else {
            ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + M2 + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + (+M2 + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r2 = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
    return comp.replace(r2, function(ret, gtlt, M2, m2, p2, pr) {
      debug("xRange", comp, ret, gtlt, M2, m2, p2, pr);
      var xM = isX(M2);
      var xm = xM || isX(m2);
      var xp = xm || isX(p2);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p2 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p2 = 0;
          } else {
            m2 = +m2 + 1;
            p2 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        ret = gtlt + M2 + "." + m2 + "." + p2;
      } else if (xm) {
        ret = ">=" + M2 + ".0.0 <" + (+M2 + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M2 + "." + m2 + ".0 <" + M2 + "." + (+m2 + 1) + ".0";
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(safeRe[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb2, to, tM, tm, tp, tpr, tb2) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version2) {
    if (!version2) {
      return false;
    }
    if (typeof version2 === "string") {
      version2 = new SemVer(version2, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version2, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version2, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports.satisfies = satisfies;
  function satisfies(version2, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  }
  exports.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v2) {
      if (rangeObj.test(v2)) {
        if (!max || maxSV.compare(v2) === -1) {
          max = v2;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v2) {
      if (rangeObj.test(v2)) {
        if (!min || minSV.compare(v2) === 1) {
          min = v2;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports.ltr = ltr;
  function ltr(version2, range, options) {
    return outside(version2, range, "<", options);
  }
  exports.gtr = gtr;
  function gtr(version2, range, options) {
    return outside(version2, range, ">", options);
  }
  exports.outside = outside;
  function outside(version2, range, hilo, options) {
    version2 = new SemVer(version2, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports.prerelease = prerelease;
  function prerelease(version2, options) {
    var parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports.coerce = coerce2;
  function coerce2(version2) {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    var match = version2.match(safeRe[COERCE]);
    if (match == null) {
      return null;
    }
    return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
})(semver$1, semver$1.exports);
var semverExports = semver$1.exports;
const semver = /* @__PURE__ */ getDefaultExportFromCjs$1(semverExports);
const abiCoder = new AbiCoder();
function _addressToHex(value) {
  return TronWeb.address.toHex(value).replace(ADDRESS_PREFIX_REGEX, "0x");
}
function decodeParams(names, types, output2, ignoreMethodHash = false) {
  if (ignoreMethodHash && output2.replace(/^0x/, "").length % 64 === 8)
    output2 = "0x" + output2.replace(/^0x/, "").substring(8);
  if (output2.replace(/^0x/, "").length % 64) {
    throw new Error("The encoded string is not valid. Its length must be a multiple of 64.");
  }
  types = types.map((type2) => {
    if (/trcToken/.test(type2)) {
      type2 = type2.replace(/trcToken/, "uint256");
    }
    return type2;
  });
  return abiCoder.decode(types, output2).reduce((obj, arg, index2) => {
    if (types[index2] == "address") {
      arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();
    }
    if (names.length) {
      obj[names[index2]] = arg;
    } else {
      obj.push(arg);
    }
    return obj;
  }, names.length ? {} : []);
}
function encodeParams(types, values) {
  for (let i = 0; i < types.length; i++) {
    if (types[i] === "address") {
      values[i] = TronWeb.address.toHex(values[i]).replace(ADDRESS_PREFIX_REGEX, "0x");
    }
  }
  return abiCoder.encode(types, values);
}
function extractSize(type2) {
  const size2 = type2.match(/([a-zA-Z0-9])(\[.*\])/);
  return size2 ? size2[2] : "";
}
function extractArrayDim(type2) {
  const size2 = extractSize(type2);
  return (size2.match(/\]\[/g) || []).length + 1;
}
function encodeParamsV2ByABI(funABI, args) {
  const types = [];
  const buildFullTypeDefinition = (typeDef) => {
    if (typeDef && typeDef.type.indexOf("tuple") === 0 && typeDef.components) {
      const innerTypes = typeDef.components.map((innerType) => {
        return buildFullTypeDefinition(innerType);
      });
      return `tuple(${innerTypes.join(",")})${extractSize(typeDef.type)}`;
    }
    if (/trcToken/.test(typeDef.type))
      return typeDef.type.replace(/trcToken/, "uint256");
    return typeDef.type;
  };
  const convertTypes = (types2) => {
    for (let i = 0; i < types2.length; i++) {
      const type2 = types2[i];
      if (/trcToken/.test(type2))
        types2[i] = type2.replace(/trcToken/, "uint256");
    }
  };
  const convertAddresses = (addrArr) => {
    if (Array.isArray(addrArr)) {
      addrArr.forEach((addrs, i) => {
        addrArr[i] = convertAddresses(addrs);
      });
      return addrArr;
    } else {
      return _addressToHex(addrArr);
    }
  };
  const mapTuple = (components, args2, dimension) => {
    if (dimension > 1) {
      if (args2.length) {
        args2.forEach((arg) => {
          mapTuple(components, arg, dimension - 1);
        });
      }
    } else {
      if (args2.length && dimension) {
        args2.forEach((arg) => {
          encodeArgs(components, arg);
        });
      }
    }
  };
  const encodeArgs = (inputs = [], args2) => {
    if (inputs.length)
      inputs.forEach((input, i) => {
        const type2 = input.type;
        if (args2[i]) {
          if (type2 === "address")
            args2[i] = _addressToHex(args2[i]);
          else if (type2.match(/^([^\x5b]*)(\x5b|$)/)[0] === "address[")
            convertAddresses(args2[i]);
          else if (type2.indexOf("tuple") === 0)
            if (extractSize(type2)) {
              const dimension = extractArrayDim(type2);
              mapTuple(input.components, args2[i], dimension);
            } else
              encodeArgs(input.components, args2[i]);
        }
      });
  };
  if (funABI.inputs && funABI.inputs.length) {
    for (let i = 0; i < funABI.inputs.length; i++) {
      const type2 = funABI.inputs[i].type;
      if (type2 === "bool" && args[i] === "false") {
        args[i] = false;
      }
      types.push(type2.indexOf("tuple") === 0 ? buildFullTypeDefinition(funABI.inputs[i]) : type2);
      if (args.length < types.length) {
        args.push("");
      }
    }
  }
  encodeArgs(funABI.inputs, args);
  convertTypes(types);
  return abiCoder.encode(types, args);
}
function decodeParamsV2ByABI(funABI, data) {
  const convertTypeNames = (types) => {
    for (let i = 0; i < types.length; i++) {
      const type2 = types[i];
      if (/^trcToken/.test(type2))
        types[i] = type2.replace(/^trcToken/, "uint256");
    }
  };
  const convertAddresses = (addrArr) => {
    if (Array.isArray(addrArr)) {
      addrArr.forEach((addrs, i) => {
        addrArr[i] = convertAddresses(addrs);
      });
      return addrArr;
    } else {
      return TronWeb.address.toHex(addrArr);
    }
  };
  const mapTuple = (components, args, dimension) => {
    if (dimension > 1) {
      if (args.length) {
        args.forEach((arg) => {
          mapTuple(components, arg, dimension - 1);
        });
      }
    } else {
      if (args.length && dimension) {
        args.forEach((arg) => {
          decodeResult(components, arg);
        });
      }
    }
  };
  const buildFullTypeNameDefinition = (typeDef) => {
    const name = typeDef.name ? ` ${typeDef.name}` : "";
    if (typeDef && typeDef.type.indexOf("tuple") === 0 && typeDef.components) {
      const innerTypes = typeDef.components.map((innerType) => {
        return buildFullTypeNameDefinition(innerType);
      });
      return `tuple(${innerTypes.join(",")})${extractSize(typeDef.type)}${name}`;
    }
    if (/trcToken/.test(typeDef.type))
      return typeDef.type.replace(/trcToken/, "uint256") + name;
    return typeDef.type + name;
  };
  const decodeResult = (outputs, result) => {
    if (outputs.length)
      outputs.forEach((output2, i) => {
        const { type: type2, name } = output2;
        if (result[i]) {
          if (type2 === "address") {
            result[i] = TronWeb.address.toHex(result[i]);
            if (name)
              result[name] = TronWeb.address.toHex(result[i]);
          } else if (type2.match(/^([^\x5b]*)(\x5b|$)/)[0] === "address[") {
            convertAddresses(result[i]);
            if (name)
              result[name] = convertAddresses(result[i]);
          } else if (type2.indexOf("tuple") === 0) {
            if (extractSize(type2)) {
              const dimension = extractArrayDim(type2);
              mapTuple(output2.components, result[i], dimension);
            } else
              decodeResult(output2.components, result[i]);
            if (name)
              result[name] = result[i];
          } else {
            if (name)
              result[name] = result[i];
          }
        } else {
          if (name)
            result[name] = result[i];
        }
      });
  };
  if ("outputs" in funABI && funABI.outputs && funABI.outputs.length > 0) {
    const outputTypes = [];
    for (let i = 0; i < funABI.outputs.length; i++) {
      const type2 = funABI.outputs[i].type;
      const name = funABI.outputs[i].name ? ` ${funABI.outputs[i].name}` : "";
      outputTypes.push(type2.indexOf("tuple") === 0 ? buildFullTypeNameDefinition(funABI.outputs[i]) : type2 + name);
    }
    convertTypeNames(outputTypes);
    if (!data || !data.length)
      data = new Uint8Array(32 * funABI.outputs.length);
    const decodeRes = abiCoder.decode(outputTypes, data);
    const decodeResCopy = decodeRes.toArray(true);
    decodeResult(funABI.outputs, decodeResCopy);
    return decodeResCopy;
  }
  return [];
}
const abi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decodeParams,
  decodeParamsV2ByABI,
  encodeParams,
  encodeParamsV2ByABI
}, Symbol.toStringTag, { value: "Module" }));
class Validator {
  invalid(param) {
    return param.msg || `Invalid ${param.name}${param.type === "address" ? " address" : ""} provided`;
  }
  notPositive(param) {
    return `${param.name} must be a positive integer`;
  }
  notEqual(param) {
    var _a3, _b2;
    return param.msg || `${(_a3 = param.names) == null ? void 0 : _a3[0]} can not be equal to ${(_b2 = param.names) == null ? void 0 : _b2[1]}`;
  }
  notValid(params) {
    const normalized = {};
    let no = false;
    for (const param of params) {
      const { name, names, value, type: type2, gt, lt, gte, lte, optional: optional2 } = param;
      if (optional2 && (!isNotNullOrUndefined(value) || type2 !== "boolean" && value === false))
        continue;
      normalized[name] = param.value;
      switch (type2) {
        case "address":
          if (!isAddress(value)) {
            no = true;
          } else {
            normalized[name] = toHex$1(value);
          }
          break;
        case "integer":
          if (!isInteger(value) || typeof gt === "number" && value <= gt || typeof lt === "number" && value >= lt || typeof gte === "number" && value < gte || typeof lte === "number" && value > lte) {
            no = true;
          }
          break;
        case "positive-integer":
          if (!isInteger(value) || value <= 0) {
            throw new Error(this.notPositive(param));
          }
          break;
        case "tokenId":
          if (!isString$1(value) || !value.length) {
            no = true;
          }
          break;
        case "notEmptyObject":
          if (!isObject$2(value) || !Object.keys(value).length) {
            no = true;
          }
          break;
        case "notEqual":
          if (names && normalized[names[0]] === normalized[names[1]]) {
            throw new Error(this.notEqual(param));
          }
          break;
        case "resource":
          if (!["BANDWIDTH", "ENERGY"].includes(value)) {
            no = true;
          }
          break;
        case "url":
          if (!isValidURL(value)) {
            no = true;
          }
          break;
        case "hex":
          if (!isHex(value)) {
            no = true;
          }
          break;
        case "array":
          if (!Array.isArray(value)) {
            no = true;
          }
          break;
        case "not-empty-string":
          if (!isString$1(value) || !value.length) {
            no = true;
          }
          break;
        case "boolean":
          if (!isBoolean$1(value)) {
            no = true;
          }
          break;
        case "string":
          if (!isString$1(value) || typeof gt === "number" && value.length <= gt || typeof lt === "number" && value.length >= lt || typeof gte === "number" && value.length < gte || typeof lte === "number" && value.length > lte) {
            no = true;
          }
          break;
      }
      if (no) {
        throw new Error(this.invalid(param));
      }
    }
    return false;
  }
}
var ContractType;
(function(ContractType2) {
  ContractType2["AccountCreateContract"] = "AccountCreateContract";
  ContractType2["TransferContract"] = "TransferContract";
  ContractType2["TransferAssetContract"] = "TransferAssetContract";
  ContractType2["VoteAssetContract"] = "VoteAssetContract";
  ContractType2["VoteWitnessContract"] = "VoteWitnessContract";
  ContractType2["WitnessCreateContract"] = "WitnessCreateContract";
  ContractType2["AssetIssueContract"] = "AssetIssueContract";
  ContractType2["WitnessUpdateContract"] = "WitnessUpdateContract";
  ContractType2["ParticipateAssetIssueContract"] = "ParticipateAssetIssueContract";
  ContractType2["AccountUpdateContract"] = "AccountUpdateContract";
  ContractType2["FreezeBalanceContract"] = "FreezeBalanceContract";
  ContractType2["UnfreezeBalanceContract"] = "UnfreezeBalanceContract";
  ContractType2["CancelAllUnfreezeV2Contract"] = "CancelAllUnfreezeV2Contract";
  ContractType2["WithdrawBalanceContract"] = "WithdrawBalanceContract";
  ContractType2["UnfreezeAssetContract"] = "UnfreezeAssetContract";
  ContractType2["UpdateAssetContract"] = "UpdateAssetContract";
  ContractType2["ProposalCreateContract"] = "ProposalCreateContract";
  ContractType2["ProposalApproveContract"] = "ProposalApproveContract";
  ContractType2["ProposalDeleteContract"] = "ProposalDeleteContract";
  ContractType2["SetAccountIdContract"] = "SetAccountIdContract";
  ContractType2["CustomContract"] = "CustomContract";
  ContractType2["CreateSmartContract"] = "CreateSmartContract";
  ContractType2["TriggerSmartContract"] = "TriggerSmartContract";
  ContractType2["GetContract"] = "GetContract";
  ContractType2["UpdateSettingContract"] = "UpdateSettingContract";
  ContractType2["ExchangeCreateContract"] = "ExchangeCreateContract";
  ContractType2["ExchangeInjectContract"] = "ExchangeInjectContract";
  ContractType2["ExchangeWithdrawContract"] = "ExchangeWithdrawContract";
  ContractType2["ExchangeTransactionContract"] = "ExchangeTransactionContract";
  ContractType2["UpdateEnergyLimitContract"] = "UpdateEnergyLimitContract";
  ContractType2["AccountPermissionUpdateContract"] = "AccountPermissionUpdateContract";
  ContractType2["ClearABIContract"] = "ClearABIContract";
  ContractType2["UpdateBrokerageContract"] = "UpdateBrokerageContract";
  ContractType2["ShieldedTransferContract"] = "ShieldedTransferContract";
  ContractType2["MarketSellAssetContract"] = "MarketSellAssetContract";
  ContractType2["MarketCancelOrderContract"] = "MarketCancelOrderContract";
  ContractType2["FreezeBalanceV2Contract"] = "FreezeBalanceV2Contract";
  ContractType2["UnfreezeBalanceV2Contract"] = "UnfreezeBalanceV2Contract";
  ContractType2["WithdrawExpireUnfreezeContract"] = "WithdrawExpireUnfreezeContract";
  ContractType2["DelegateResourceContract"] = "DelegateResourceContract";
  ContractType2["UnDelegateResourceContract"] = "UnDelegateResourceContract";
  ContractType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ContractType || (ContractType = {}));
var Permission_PermissionType;
(function(Permission_PermissionType2) {
  Permission_PermissionType2[Permission_PermissionType2["Owner"] = 0] = "Owner";
  Permission_PermissionType2[Permission_PermissionType2["Witness"] = 1] = "Witness";
  Permission_PermissionType2[Permission_PermissionType2["Active"] = 2] = "Active";
  Permission_PermissionType2[Permission_PermissionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Permission_PermissionType || (Permission_PermissionType = {}));
var AccountType;
(function(AccountType2) {
  AccountType2[AccountType2["Normal"] = 0] = "Normal";
  AccountType2[AccountType2["AssetIssue"] = 1] = "AssetIssue";
  AccountType2[AccountType2["Contract"] = 2] = "Contract";
  AccountType2[AccountType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AccountType || (AccountType = {}));
var any_pb = {};
var googleProtobuf = {};
(function(exports) {
  var aa2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b2, c) {
    a != Array.prototype && a != Object.prototype && (a[b2] = c.value);
  }, e2 = "undefined" != typeof window && window === commonjsGlobal ? commonjsGlobal : "undefined" != typeof commonjsGlobal && null != commonjsGlobal ? commonjsGlobal : commonjsGlobal;
  function ba(a, b2) {
    if (b2) {
      var c = e2;
      a = a.split(".");
      for (var d = 0; d < a.length - 1; d++) {
        var f2 = a[d];
        f2 in c || (c[f2] = {});
        c = c[f2];
      }
      a = a[a.length - 1];
      d = c[a];
      b2 = b2(d);
      b2 != d && null != b2 && aa2(c, a, { configurable: true, writable: true, value: b2 });
    }
  }
  function ca2(a) {
    var b2 = 0;
    return function() {
      return b2 < a.length ? { done: false, value: a[b2++] } : { done: true };
    };
  }
  function da2() {
    da2 = function() {
    };
    e2.Symbol || (e2.Symbol = ea2);
  }
  function fa2(a, b2) {
    this.a = a;
    aa2(this, "description", { configurable: true, writable: true, value: b2 });
  }
  fa2.prototype.toString = function() {
    return this.a;
  };
  var ea2 = function() {
    function a(c) {
      if (this instanceof a)
        throw new TypeError("Symbol is not a constructor");
      return new fa2("jscomp_symbol_" + (c || "") + "_" + b2++, c);
    }
    var b2 = 0;
    return a;
  }();
  function ha2() {
    da2();
    var a = e2.Symbol.iterator;
    a || (a = e2.Symbol.iterator = e2.Symbol("Symbol.iterator"));
    "function" != typeof Array.prototype[a] && aa2(Array.prototype, a, { configurable: true, writable: true, value: function() {
      return ia2(ca2(this));
    } });
    ha2 = function() {
    };
  }
  function ia2(a) {
    ha2();
    a = { next: a };
    a[e2.Symbol.iterator] = function() {
      return this;
    };
    return a;
  }
  function ja2(a, b2) {
    ha2();
    a instanceof String && (a += "");
    var c = 0, d = { next: function() {
      if (c < a.length) {
        var f2 = c++;
        return { value: b2(f2, a[f2]), done: false };
      }
      d.next = function() {
        return { done: true, value: void 0 };
      };
      return d.next();
    } };
    d[Symbol.iterator] = function() {
      return d;
    };
    return d;
  }
  ba("Array.prototype.entries", function(a) {
    return a ? a : function() {
      return ja2(this, function(b2, c) {
        return [b2, c];
      });
    };
  });
  var ka2 = commonjsGlobal || self;
  function g(a, b2, c) {
    a = a.split(".");
    c = c || ka2;
    a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
    for (var d; a.length && (d = a.shift()); )
      a.length || void 0 === b2 ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b2;
  }
  function k2(a) {
    var b2 = typeof a;
    if ("object" == b2)
      if (a) {
        if (a instanceof Array)
          return "array";
        if (a instanceof Object)
          return b2;
        var c = Object.prototype.toString.call(a);
        if ("[object Window]" == c)
          return "object";
        if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice"))
          return "array";
        if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call"))
          return "function";
      } else
        return "null";
    else if ("function" == b2 && "undefined" == typeof a.call)
      return "object";
    return b2;
  }
  function la2(a) {
    var b2 = typeof a;
    return "object" == b2 && null != a || "function" == b2;
  }
  function ma2(a, b2, c) {
    g(a, b2, c);
  }
  function na(a, b2) {
    function c() {
    }
    c.prototype = b2.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
  }
  var oa2 = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function pa2(a, b2) {
    for (var c, d, f2 = 1; f2 < arguments.length; f2++) {
      d = arguments[f2];
      for (c in d)
        a[c] = d[c];
      for (var h2 = 0; h2 < oa2.length; h2++)
        c = oa2[h2], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
    }
  }
  var qa2 = Array.prototype.forEach ? function(a, b2) {
    Array.prototype.forEach.call(a, b2, void 0);
  } : function(a, b2) {
    for (var c = a.length, d = "string" === typeof a ? a.split("") : a, f2 = 0; f2 < c; f2++)
      f2 in d && b2.call(void 0, d[f2], f2, a);
  }, l2 = Array.prototype.map ? function(a, b2) {
    return Array.prototype.map.call(a, b2, void 0);
  } : function(a, b2) {
    for (var c = a.length, d = Array(c), f2 = "string" === typeof a ? a.split("") : a, h2 = 0; h2 < c; h2++)
      h2 in f2 && (d[h2] = b2.call(void 0, f2[h2], h2, a));
    return d;
  };
  function ra2(a, b2, c) {
    return 2 >= arguments.length ? Array.prototype.slice.call(a, b2) : Array.prototype.slice.call(a, b2, c);
  }
  function sa2(a, b2, c, d) {
    var f2 = "Assertion failed";
    if (c) {
      f2 += ": " + c;
      var h2 = d;
    } else
      a && (f2 += ": " + a, h2 = b2);
    throw Error(f2, h2 || []);
  }
  function n2(a, b2, c) {
    for (var d = [], f2 = 2; f2 < arguments.length; ++f2)
      d[f2 - 2] = arguments[f2];
    a || sa2("", null, b2, d);
    return a;
  }
  function ta2(a, b2, c) {
    for (var d = [], f2 = 2; f2 < arguments.length; ++f2)
      d[f2 - 2] = arguments[f2];
    "string" !== typeof a && sa2("Expected string but got %s: %s.", [k2(a), a], b2, d);
  }
  function ua2(a, b2, c) {
    for (var d = [], f2 = 2; f2 < arguments.length; ++f2)
      d[f2 - 2] = arguments[f2];
    Array.isArray(a) || sa2("Expected array but got %s: %s.", [k2(a), a], b2, d);
  }
  function p2(a, b2) {
    for (var c = [], d = 1; d < arguments.length; ++d)
      c[d - 1] = arguments[d];
    throw Error("Failure" + (a ? ": " + a : ""), c);
  }
  function q2(a, b2, c, d) {
    for (var f2 = [], h2 = 3; h2 < arguments.length; ++h2)
      f2[h2 - 3] = arguments[h2];
    a instanceof b2 || sa2("Expected instanceof %s but got %s.", [va2(b2), va2(a)], c, f2);
  }
  function va2(a) {
    return a instanceof Function ? a.displayName || a.name || "unknown type name" : a instanceof Object ? a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a) : null === a ? "null" : typeof a;
  }
  function r2(a, b2) {
    this.c = a;
    this.b = b2;
    this.a = {};
    this.arrClean = true;
    if (0 < this.c.length) {
      for (a = 0; a < this.c.length; a++) {
        b2 = this.c[a];
        var c = b2[0];
        this.a[c.toString()] = new wa2(c, b2[1]);
      }
      this.arrClean = true;
    }
  }
  g("jspb.Map", r2, void 0);
  r2.prototype.g = function() {
    if (this.arrClean) {
      if (this.b) {
        var a = this.a, b2;
        for (b2 in a)
          if (Object.prototype.hasOwnProperty.call(a, b2)) {
            var c = a[b2].a;
            c && c.g();
          }
      }
    } else {
      this.c.length = 0;
      a = u2(this);
      a.sort();
      for (b2 = 0; b2 < a.length; b2++) {
        var d = this.a[a[b2]];
        (c = d.a) && c.g();
        this.c.push([d.key, d.value]);
      }
      this.arrClean = true;
    }
    return this.c;
  };
  r2.prototype.toArray = r2.prototype.g;
  r2.prototype.Mc = function(a, b2) {
    for (var c = this.g(), d = [], f2 = 0; f2 < c.length; f2++) {
      var h2 = this.a[c[f2][0].toString()];
      v2(this, h2);
      var m2 = h2.a;
      m2 ? (n2(b2), d.push([h2.key, b2(a, m2)])) : d.push([h2.key, h2.value]);
    }
    return d;
  };
  r2.prototype.toObject = r2.prototype.Mc;
  r2.fromObject = function(a, b2, c) {
    b2 = new r2([], b2);
    for (var d = 0; d < a.length; d++) {
      var f2 = a[d][0], h2 = c(a[d][1]);
      b2.set(f2, h2);
    }
    return b2;
  };
  function w2(a) {
    this.a = 0;
    this.b = a;
  }
  w2.prototype.next = function() {
    return this.a < this.b.length ? { done: false, value: this.b[this.a++] } : { done: true, value: void 0 };
  };
  "undefined" != typeof Symbol && (w2.prototype[Symbol.iterator] = function() {
    return this;
  });
  r2.prototype.Jb = function() {
    return u2(this).length;
  };
  r2.prototype.getLength = r2.prototype.Jb;
  r2.prototype.clear = function() {
    this.a = {};
    this.arrClean = false;
  };
  r2.prototype.clear = r2.prototype.clear;
  r2.prototype.Cb = function(a) {
    a = a.toString();
    var b2 = this.a.hasOwnProperty(a);
    delete this.a[a];
    this.arrClean = false;
    return b2;
  };
  r2.prototype.del = r2.prototype.Cb;
  r2.prototype.Eb = function() {
    var a = [], b2 = u2(this);
    b2.sort();
    for (var c = 0; c < b2.length; c++) {
      var d = this.a[b2[c]];
      a.push([d.key, d.value]);
    }
    return a;
  };
  r2.prototype.getEntryList = r2.prototype.Eb;
  r2.prototype.entries = function() {
    var a = [], b2 = u2(this);
    b2.sort();
    for (var c = 0; c < b2.length; c++) {
      var d = this.a[b2[c]];
      a.push([d.key, v2(this, d)]);
    }
    return new w2(a);
  };
  r2.prototype.entries = r2.prototype.entries;
  r2.prototype.keys = function() {
    var a = [], b2 = u2(this);
    b2.sort();
    for (var c = 0; c < b2.length; c++)
      a.push(this.a[b2[c]].key);
    return new w2(a);
  };
  r2.prototype.keys = r2.prototype.keys;
  r2.prototype.values = function() {
    var a = [], b2 = u2(this);
    b2.sort();
    for (var c = 0; c < b2.length; c++)
      a.push(v2(this, this.a[b2[c]]));
    return new w2(a);
  };
  r2.prototype.values = r2.prototype.values;
  r2.prototype.forEach = function(a, b2) {
    var c = u2(this);
    c.sort();
    for (var d = 0; d < c.length; d++) {
      var f2 = this.a[c[d]];
      a.call(b2, v2(this, f2), f2.key, this);
    }
  };
  r2.prototype.forEach = r2.prototype.forEach;
  r2.prototype.set = function(a, b2) {
    var c = new wa2(a);
    this.b ? (c.a = b2, c.value = b2.g()) : c.value = b2;
    this.a[a.toString()] = c;
    this.arrClean = false;
    return this;
  };
  r2.prototype.set = r2.prototype.set;
  function v2(a, b2) {
    return a.b ? (b2.a || (b2.a = new a.b(b2.value)), b2.a) : b2.value;
  }
  r2.prototype.get = function(a) {
    if (a = this.a[a.toString()])
      return v2(this, a);
  };
  r2.prototype.get = r2.prototype.get;
  r2.prototype.has = function(a) {
    return a.toString() in this.a;
  };
  r2.prototype.has = r2.prototype.has;
  r2.prototype.Jc = function(a, b2, c, d, f2) {
    var h2 = u2(this);
    h2.sort();
    for (var m2 = 0; m2 < h2.length; m2++) {
      var t2 = this.a[h2[m2]];
      b2.Va(a);
      c.call(b2, 1, t2.key);
      this.b ? d.call(b2, 2, v2(this, t2), f2) : d.call(b2, 2, t2.value);
      b2.Ya();
    }
  };
  r2.prototype.serializeBinary = r2.prototype.Jc;
  r2.deserializeBinary = function(a, b2, c, d, f2, h2, m2) {
    for (; b2.oa() && !b2.bb(); ) {
      var t2 = b2.c;
      1 == t2 ? h2 = c.call(b2) : 2 == t2 && (a.b ? (n2(f2), m2 || (m2 = new a.b()), d.call(b2, m2, f2)) : m2 = d.call(b2));
    }
    n2(void 0 != h2);
    n2(void 0 != m2);
    a.set(h2, m2);
  };
  function u2(a) {
    a = a.a;
    var b2 = [], c;
    for (c in a)
      Object.prototype.hasOwnProperty.call(a, c) && b2.push(c);
    return b2;
  }
  function wa2(a, b2) {
    this.key = a;
    this.value = b2;
    this.a = void 0;
  }
  function xa(a) {
    if (8192 >= a.length)
      return String.fromCharCode.apply(null, a);
    for (var b2 = "", c = 0; c < a.length; c += 8192)
      b2 += String.fromCharCode.apply(null, ra2(a, c, c + 8192));
    return b2;
  }
  var ya2 = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" }, za2 = { "'": "\\'" };
  var Aa2 = {}, x2 = null;
  function Ba2(a, b2) {
    void 0 === b2 && (b2 = 0);
    Ca2();
    b2 = Aa2[b2];
    for (var c = [], d = 0; d < a.length; d += 3) {
      var f2 = a[d], h2 = d + 1 < a.length, m2 = h2 ? a[d + 1] : 0, t2 = d + 2 < a.length, B2 = t2 ? a[d + 2] : 0, M2 = f2 >> 2;
      f2 = (f2 & 3) << 4 | m2 >> 4;
      m2 = (m2 & 15) << 2 | B2 >> 6;
      B2 &= 63;
      t2 || (B2 = 64, h2 || (m2 = 64));
      c.push(b2[M2], b2[f2], b2[m2] || "", b2[B2] || "");
    }
    return c.join("");
  }
  function Da2(a) {
    var b2 = a.length, c = 3 * b2 / 4;
    c % 3 ? c = Math.floor(c) : -1 != "=.".indexOf(a[b2 - 1]) && (c = -1 != "=.".indexOf(a[b2 - 2]) ? c - 2 : c - 1);
    var d = new Uint8Array(c), f2 = 0;
    Ea2(a, function(h2) {
      d[f2++] = h2;
    });
    return d.subarray(0, f2);
  }
  function Ea2(a, b2) {
    function c(B2) {
      for (; d < a.length; ) {
        var M2 = a.charAt(d++), La2 = x2[M2];
        if (null != La2)
          return La2;
        if (!/^[\s\xa0]*$/.test(M2))
          throw Error("Unknown base64 encoding at char: " + M2);
      }
      return B2;
    }
    Ca2();
    for (var d = 0; ; ) {
      var f2 = c(-1), h2 = c(0), m2 = c(64), t2 = c(64);
      if (64 === t2 && -1 === f2)
        break;
      b2(f2 << 2 | h2 >> 4);
      64 != m2 && (b2(h2 << 4 & 240 | m2 >> 2), 64 != t2 && b2(m2 << 6 & 192 | t2));
    }
  }
  function Ca2() {
    if (!x2) {
      x2 = {};
      for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b2 = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++) {
        var d = a.concat(b2[c].split(""));
        Aa2[c] = d;
        for (var f2 = 0; f2 < d.length; f2++) {
          var h2 = d[f2];
          void 0 === x2[h2] && (x2[h2] = f2);
        }
      }
    }
  }
  g("jspb.ConstBinaryMessage", function() {
  }, void 0);
  g("jspb.BinaryMessage", function() {
  }, void 0);
  g("jspb.BinaryConstants.FieldType", { yb: -1, ee: 1, FLOAT: 2, ke: 3, te: 4, je: 5, xb: 6, wb: 7, BOOL: 8, re: 9, ie: 10, le: 11, ce: 12, se: 13, ge: 14, me: 15, ne: 16, oe: 17, pe: 18, he: 30, ve: 31 }, void 0);
  g("jspb.BinaryConstants.WireType", { yb: -1, ue: 0, xb: 1, de: 2, qe: 3, fe: 4, wb: 5 }, void 0);
  g("jspb.BinaryConstants.FieldTypeToWireType", function(a) {
    switch (a) {
      case 5:
      case 3:
      case 13:
      case 4:
      case 17:
      case 18:
      case 8:
      case 14:
      case 31:
        return 0;
      case 1:
      case 6:
      case 16:
      case 30:
        return 1;
      case 9:
      case 11:
      case 12:
        return 2;
      case 2:
      case 7:
      case 15:
        return 5;
      default:
        return -1;
    }
  }, void 0);
  g("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0);
  g("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0);
  g("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0);
  g("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0);
  g("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0);
  g("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0);
  g("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0);
  g("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0);
  g("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0);
  g("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0);
  g("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0);
  g("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0);
  g("jspb.BinaryConstants.TWO_TO_63", 9223372036854776e3, void 0);
  g("jspb.BinaryConstants.TWO_TO_64", 18446744073709552e3, void 0);
  g("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
  var y2 = 0, z2 = 0;
  g("jspb.utils.getSplit64Low", function() {
    return y2;
  }, void 0);
  g("jspb.utils.getSplit64High", function() {
    return z2;
  }, void 0);
  function Fa2(a) {
    var b2 = a >>> 0;
    a = Math.floor((a - b2) / 4294967296) >>> 0;
    y2 = b2;
    z2 = a;
  }
  g("jspb.utils.splitUint64", Fa2, void 0);
  function A2(a) {
    var b2 = 0 > a;
    a = Math.abs(a);
    var c = a >>> 0;
    a = Math.floor((a - c) / 4294967296);
    a >>>= 0;
    b2 && (a = ~a >>> 0, c = (~c >>> 0) + 1, 4294967295 < c && (c = 0, a++, 4294967295 < a && (a = 0)));
    y2 = c;
    z2 = a;
  }
  g("jspb.utils.splitInt64", A2, void 0);
  function Ga2(a) {
    var b2 = 0 > a;
    a = 2 * Math.abs(a);
    Fa2(a);
    a = y2;
    var c = z2;
    b2 && (0 == a ? 0 == c ? c = a = 4294967295 : (c--, a = 4294967295) : a--);
    y2 = a;
    z2 = c;
  }
  g("jspb.utils.splitZigzag64", Ga2, void 0);
  function Ha2(a) {
    var b2 = 0 > a ? 1 : 0;
    a = b2 ? -a : a;
    if (0 === a)
      0 < 1 / a ? y2 = z2 = 0 : (z2 = 0, y2 = 2147483648);
    else if (isNaN(a))
      z2 = 0, y2 = 2147483647;
    else if (34028234663852886e22 < a)
      z2 = 0, y2 = (b2 << 31 | 2139095040) >>> 0;
    else if (11754943508222875e-54 > a)
      a = Math.round(a / Math.pow(2, -149)), z2 = 0, y2 = (b2 << 31 | a) >>> 0;
    else {
      var c = Math.floor(Math.log(a) / Math.LN2);
      a *= Math.pow(2, -c);
      a = Math.round(8388608 * a);
      16777216 <= a && ++c;
      z2 = 0;
      y2 = (b2 << 31 | c + 127 << 23 | a & 8388607) >>> 0;
    }
  }
  g("jspb.utils.splitFloat32", Ha2, void 0);
  function Ia2(a) {
    var b2 = 0 > a ? 1 : 0;
    a = b2 ? -a : a;
    if (0 === a)
      z2 = 0 < 1 / a ? 0 : 2147483648, y2 = 0;
    else if (isNaN(a))
      z2 = 2147483647, y2 = 4294967295;
    else if (17976931348623157e292 < a)
      z2 = (b2 << 31 | 2146435072) >>> 0, y2 = 0;
    else if (22250738585072014e-324 > a)
      a /= Math.pow(2, -1074), z2 = (b2 << 31 | a / 4294967296) >>> 0, y2 = a >>> 0;
    else {
      var c = a, d = 0;
      if (2 <= c)
        for (; 2 <= c && 1023 > d; )
          d++, c /= 2;
      else
        for (; 1 > c && -1022 < d; )
          c *= 2, d--;
      a *= Math.pow(2, -d);
      z2 = (b2 << 31 | d + 1023 << 20 | 1048576 * a & 1048575) >>> 0;
      y2 = 4503599627370496 * a >>> 0;
    }
  }
  g("jspb.utils.splitFloat64", Ia2, void 0);
  function C2(a) {
    var b2 = a.charCodeAt(4), c = a.charCodeAt(5), d = a.charCodeAt(6), f2 = a.charCodeAt(7);
    y2 = a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24) >>> 0;
    z2 = b2 + (c << 8) + (d << 16) + (f2 << 24) >>> 0;
  }
  g("jspb.utils.splitHash64", C2, void 0);
  function D2(a, b2) {
    return 4294967296 * b2 + (a >>> 0);
  }
  g("jspb.utils.joinUint64", D2, void 0);
  function E2(a, b2) {
    var c = b2 & 2147483648;
    c && (a = ~a + 1 >>> 0, b2 = ~b2 >>> 0, 0 == a && (b2 = b2 + 1 >>> 0));
    a = D2(a, b2);
    return c ? -a : a;
  }
  g("jspb.utils.joinInt64", E2, void 0);
  function Ja2(a, b2, c) {
    var d = b2 >> 31;
    return c(a << 1 ^ d, (b2 << 1 | a >>> 31) ^ d);
  }
  g("jspb.utils.toZigzag64", Ja2, void 0);
  function Ka2(a, b2) {
    return Ma2(a, b2, E2);
  }
  g("jspb.utils.joinZigzag64", Ka2, void 0);
  function Ma2(a, b2, c) {
    var d = -(a & 1);
    return c((a >>> 1 | b2 << 31) ^ d, b2 >>> 1 ^ d);
  }
  g("jspb.utils.fromZigzag64", Ma2, void 0);
  function Na2(a) {
    var b2 = 2 * (a >> 31) + 1, c = a >>> 23 & 255;
    a &= 8388607;
    return 255 == c ? a ? NaN : Infinity * b2 : 0 == c ? b2 * Math.pow(2, -149) * a : b2 * Math.pow(2, c - 150) * (a + Math.pow(2, 23));
  }
  g("jspb.utils.joinFloat32", Na2, void 0);
  function Oa2(a, b2) {
    var c = 2 * (b2 >> 31) + 1, d = b2 >>> 20 & 2047;
    a = 4294967296 * (b2 & 1048575) + a;
    return 2047 == d ? a ? NaN : Infinity * c : 0 == d ? c * Math.pow(2, -1074) * a : c * Math.pow(2, d - 1075) * (a + 4503599627370496);
  }
  g("jspb.utils.joinFloat64", Oa2, void 0);
  function Pa2(a, b2) {
    return String.fromCharCode(a >>> 0 & 255, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255, b2 >>> 0 & 255, b2 >>> 8 & 255, b2 >>> 16 & 255, b2 >>> 24 & 255);
  }
  g("jspb.utils.joinHash64", Pa2, void 0);
  g("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0);
  function F2(a, b2) {
    function c(f2, h2) {
      f2 = f2 ? String(f2) : "";
      return h2 ? "0000000".slice(f2.length) + f2 : f2;
    }
    if (2097151 >= b2)
      return "" + D2(a, b2);
    var d = (a >>> 24 | b2 << 8) >>> 0 & 16777215;
    b2 = b2 >> 16 & 65535;
    a = (a & 16777215) + 6777216 * d + 6710656 * b2;
    d += 8147497 * b2;
    b2 *= 2;
    1e7 <= a && (d += Math.floor(a / 1e7), a %= 1e7);
    1e7 <= d && (b2 += Math.floor(d / 1e7), d %= 1e7);
    return c(b2, 0) + c(d, b2) + c(a, 1);
  }
  g("jspb.utils.joinUnsignedDecimalString", F2, void 0);
  function G2(a, b2) {
    var c = b2 & 2147483648;
    c && (a = ~a + 1 >>> 0, b2 = ~b2 + (0 == a ? 1 : 0) >>> 0);
    a = F2(a, b2);
    return c ? "-" + a : a;
  }
  g("jspb.utils.joinSignedDecimalString", G2, void 0);
  function Qa2(a, b2) {
    C2(a);
    a = y2;
    var c = z2;
    return b2 ? G2(a, c) : F2(a, c);
  }
  g("jspb.utils.hash64ToDecimalString", Qa2, void 0);
  g("jspb.utils.hash64ArrayToDecimalStrings", function(a, b2) {
    for (var c = Array(a.length), d = 0; d < a.length; d++)
      c[d] = Qa2(a[d], b2);
    return c;
  }, void 0);
  function H2(a) {
    function b2(m2, t2) {
      for (var B2 = 0; 8 > B2 && (1 !== m2 || 0 < t2); B2++)
        t2 = m2 * f2[B2] + t2, f2[B2] = t2 & 255, t2 >>>= 8;
    }
    function c() {
      for (var m2 = 0; 8 > m2; m2++)
        f2[m2] = ~f2[m2] & 255;
    }
    n2(0 < a.length);
    var d = false;
    "-" === a[0] && (d = true, a = a.slice(1));
    for (var f2 = [0, 0, 0, 0, 0, 0, 0, 0], h2 = 0; h2 < a.length; h2++)
      b2(10, a.charCodeAt(h2) - 48);
    d && (c(), b2(1, 1));
    return xa(f2);
  }
  g("jspb.utils.decimalStringToHash64", H2, void 0);
  g("jspb.utils.splitDecimalString", function(a) {
    C2(H2(a));
  }, void 0);
  function Ra2(a) {
    return String.fromCharCode(10 > a ? 48 + a : 87 + a);
  }
  function Sa2(a) {
    return 97 <= a ? a - 97 + 10 : a - 48;
  }
  g("jspb.utils.hash64ToHexString", function(a) {
    var b2 = Array(18);
    b2[0] = "0";
    b2[1] = "x";
    for (var c = 0; 8 > c; c++) {
      var d = a.charCodeAt(7 - c);
      b2[2 * c + 2] = Ra2(d >> 4);
      b2[2 * c + 3] = Ra2(d & 15);
    }
    return b2.join("");
  }, void 0);
  g("jspb.utils.hexStringToHash64", function(a) {
    a = a.toLowerCase();
    n2(18 == a.length);
    n2("0" == a[0]);
    n2("x" == a[1]);
    for (var b2 = "", c = 0; 8 > c; c++)
      b2 = String.fromCharCode(16 * Sa2(a.charCodeAt(2 * c + 2)) + Sa2(a.charCodeAt(2 * c + 3))) + b2;
    return b2;
  }, void 0);
  g("jspb.utils.hash64ToNumber", function(a, b2) {
    C2(a);
    a = y2;
    var c = z2;
    return b2 ? E2(a, c) : D2(a, c);
  }, void 0);
  g("jspb.utils.numberToHash64", function(a) {
    A2(a);
    return Pa2(y2, z2);
  }, void 0);
  g("jspb.utils.countVarints", function(a, b2, c) {
    for (var d = 0, f2 = b2; f2 < c; f2++)
      d += a[f2] >> 7;
    return c - b2 - d;
  }, void 0);
  g("jspb.utils.countVarintFields", function(a, b2, c, d) {
    var f2 = 0;
    d *= 8;
    if (128 > d)
      for (; b2 < c && a[b2++] == d; )
        for (f2++; ; ) {
          var h2 = a[b2++];
          if (0 == (h2 & 128))
            break;
        }
    else
      for (; b2 < c; ) {
        for (h2 = d; 128 < h2; ) {
          if (a[b2] != (h2 & 127 | 128))
            return f2;
          b2++;
          h2 >>= 7;
        }
        if (a[b2++] != h2)
          break;
        for (f2++; h2 = a[b2++], 0 != (h2 & 128); )
          ;
      }
    return f2;
  }, void 0);
  function Ta2(a, b2, c, d, f2) {
    var h2 = 0;
    if (128 > d)
      for (; b2 < c && a[b2++] == d; )
        h2++, b2 += f2;
    else
      for (; b2 < c; ) {
        for (var m2 = d; 128 < m2; ) {
          if (a[b2++] != (m2 & 127 | 128))
            return h2;
          m2 >>= 7;
        }
        if (a[b2++] != m2)
          break;
        h2++;
        b2 += f2;
      }
    return h2;
  }
  g("jspb.utils.countFixed32Fields", function(a, b2, c, d) {
    return Ta2(a, b2, c, 8 * d + 5, 4);
  }, void 0);
  g("jspb.utils.countFixed64Fields", function(a, b2, c, d) {
    return Ta2(a, b2, c, 8 * d + 1, 8);
  }, void 0);
  g("jspb.utils.countDelimitedFields", function(a, b2, c, d) {
    var f2 = 0;
    for (d = 8 * d + 2; b2 < c; ) {
      for (var h2 = d; 128 < h2; ) {
        if (a[b2++] != (h2 & 127 | 128))
          return f2;
        h2 >>= 7;
      }
      if (a[b2++] != h2)
        break;
      f2++;
      for (var m2 = 0, t2 = 1; h2 = a[b2++], m2 += (h2 & 127) * t2, t2 *= 128, 0 != (h2 & 128); )
        ;
      b2 += m2;
    }
    return f2;
  }, void 0);
  g("jspb.utils.debugBytesToTextFormat", function(a) {
    var b2 = '"';
    if (a) {
      a = Ua2(a);
      for (var c = 0; c < a.length; c++)
        b2 += "\\x", 16 > a[c] && (b2 += "0"), b2 += a[c].toString(16);
    }
    return b2 + '"';
  }, void 0);
  g("jspb.utils.debugScalarToTextFormat", function(a) {
    if ("string" === typeof a) {
      a = String(a);
      for (var b2 = ['"'], c = 0; c < a.length; c++) {
        var d = a.charAt(c), f2 = d.charCodeAt(0), h2 = c + 1, m2;
        if (!(m2 = ya2[d])) {
          if (!(31 < f2 && 127 > f2))
            if (f2 = d, f2 in za2)
              d = za2[f2];
            else if (f2 in ya2)
              d = za2[f2] = ya2[f2];
            else {
              m2 = f2.charCodeAt(0);
              if (31 < m2 && 127 > m2)
                d = f2;
              else {
                if (256 > m2) {
                  if (d = "\\x", 16 > m2 || 256 < m2)
                    d += "0";
                } else
                  d = "\\u", 4096 > m2 && (d += "0");
                d += m2.toString(16).toUpperCase();
              }
              d = za2[f2] = d;
            }
          m2 = d;
        }
        b2[h2] = m2;
      }
      b2.push('"');
      a = b2.join("");
    } else
      a = a.toString();
    return a;
  }, void 0);
  g("jspb.utils.stringToByteArray", function(a) {
    for (var b2 = new Uint8Array(a.length), c = 0; c < a.length; c++) {
      var d = a.charCodeAt(c);
      if (255 < d)
        throw Error("Conversion error: string contains codepoint outside of byte range");
      b2[c] = d;
    }
    return b2;
  }, void 0);
  function Ua2(a) {
    if (a.constructor === Uint8Array)
      return a;
    if (a.constructor === ArrayBuffer)
      return new Uint8Array(a);
    if (a.constructor === Array)
      return new Uint8Array(a);
    if (a.constructor === String)
      return Da2(a);
    if (a instanceof Uint8Array)
      return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    p2("Type not convertible to Uint8Array.");
    return new Uint8Array(0);
  }
  g("jspb.utils.byteSourceToUint8Array", Ua2, void 0);
  function I2(a, b2, c) {
    this.b = null;
    this.a = this.c = this.h = 0;
    this.v = false;
    a && this.H(a, b2, c);
  }
  g("jspb.BinaryDecoder", I2, void 0);
  var Va2 = [];
  I2.getInstanceCacheLength = function() {
    return Va2.length;
  };
  function Wa2(a, b2, c) {
    if (Va2.length) {
      var d = Va2.pop();
      a && d.H(a, b2, c);
      return d;
    }
    return new I2(a, b2, c);
  }
  I2.alloc = Wa2;
  I2.prototype.Ca = function() {
    this.clear();
    100 > Va2.length && Va2.push(this);
  };
  I2.prototype.free = I2.prototype.Ca;
  I2.prototype.clone = function() {
    return Wa2(this.b, this.h, this.c - this.h);
  };
  I2.prototype.clone = I2.prototype.clone;
  I2.prototype.clear = function() {
    this.b = null;
    this.a = this.c = this.h = 0;
    this.v = false;
  };
  I2.prototype.clear = I2.prototype.clear;
  I2.prototype.Y = function() {
    return this.b;
  };
  I2.prototype.getBuffer = I2.prototype.Y;
  I2.prototype.H = function(a, b2, c) {
    this.b = Ua2(a);
    this.h = void 0 !== b2 ? b2 : 0;
    this.c = void 0 !== c ? this.h + c : this.b.length;
    this.a = this.h;
  };
  I2.prototype.setBlock = I2.prototype.H;
  I2.prototype.Db = function() {
    return this.c;
  };
  I2.prototype.getEnd = I2.prototype.Db;
  I2.prototype.setEnd = function(a) {
    this.c = a;
  };
  I2.prototype.setEnd = I2.prototype.setEnd;
  I2.prototype.reset = function() {
    this.a = this.h;
  };
  I2.prototype.reset = I2.prototype.reset;
  I2.prototype.B = function() {
    return this.a;
  };
  I2.prototype.getCursor = I2.prototype.B;
  I2.prototype.Ma = function(a) {
    this.a = a;
  };
  I2.prototype.setCursor = I2.prototype.Ma;
  I2.prototype.advance = function(a) {
    this.a += a;
    n2(this.a <= this.c);
  };
  I2.prototype.advance = I2.prototype.advance;
  I2.prototype.ya = function() {
    return this.a == this.c;
  };
  I2.prototype.atEnd = I2.prototype.ya;
  I2.prototype.Qb = function() {
    return this.a > this.c;
  };
  I2.prototype.pastEnd = I2.prototype.Qb;
  I2.prototype.getError = function() {
    return this.v || 0 > this.a || this.a > this.c;
  };
  I2.prototype.getError = I2.prototype.getError;
  I2.prototype.w = function(a) {
    for (var b2 = 128, c = 0, d = 0, f2 = 0; 4 > f2 && 128 <= b2; f2++)
      b2 = this.b[this.a++], c |= (b2 & 127) << 7 * f2;
    128 <= b2 && (b2 = this.b[this.a++], c |= (b2 & 127) << 28, d |= (b2 & 127) >> 4);
    if (128 <= b2)
      for (f2 = 0; 5 > f2 && 128 <= b2; f2++)
        b2 = this.b[this.a++], d |= (b2 & 127) << 7 * f2 + 3;
    if (128 > b2)
      return a(c >>> 0, d >>> 0);
    p2("Failed to read varint, encoding is invalid.");
    this.v = true;
  };
  I2.prototype.readSplitVarint64 = I2.prototype.w;
  I2.prototype.ea = function(a) {
    return this.w(function(b2, c) {
      return Ma2(b2, c, a);
    });
  };
  I2.prototype.readSplitZigzagVarint64 = I2.prototype.ea;
  I2.prototype.ta = function(a) {
    var b2 = this.b, c = this.a;
    this.a += 8;
    for (var d = 0, f2 = 0, h2 = c + 7; h2 >= c; h2--)
      d = d << 8 | b2[h2], f2 = f2 << 8 | b2[h2 + 4];
    return a(d, f2);
  };
  I2.prototype.readSplitFixed64 = I2.prototype.ta;
  I2.prototype.kb = function() {
    for (; this.b[this.a] & 128; )
      this.a++;
    this.a++;
  };
  I2.prototype.skipVarint = I2.prototype.kb;
  I2.prototype.mb = function(a) {
    for (; 128 < a; )
      this.a--, a >>>= 7;
    this.a--;
  };
  I2.prototype.unskipVarint = I2.prototype.mb;
  I2.prototype.o = function() {
    var a = this.b;
    var b2 = a[this.a];
    var c = b2 & 127;
    if (128 > b2)
      return this.a += 1, n2(this.a <= this.c), c;
    b2 = a[this.a + 1];
    c |= (b2 & 127) << 7;
    if (128 > b2)
      return this.a += 2, n2(this.a <= this.c), c;
    b2 = a[this.a + 2];
    c |= (b2 & 127) << 14;
    if (128 > b2)
      return this.a += 3, n2(this.a <= this.c), c;
    b2 = a[this.a + 3];
    c |= (b2 & 127) << 21;
    if (128 > b2)
      return this.a += 4, n2(this.a <= this.c), c;
    b2 = a[this.a + 4];
    c |= (b2 & 15) << 28;
    if (128 > b2)
      return this.a += 5, n2(this.a <= this.c), c >>> 0;
    this.a += 5;
    128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && n2(false);
    n2(this.a <= this.c);
    return c;
  };
  I2.prototype.readUnsignedVarint32 = I2.prototype.o;
  I2.prototype.da = function() {
    return ~~this.o();
  };
  I2.prototype.readSignedVarint32 = I2.prototype.da;
  I2.prototype.O = function() {
    return this.o().toString();
  };
  I2.prototype.Ea = function() {
    return this.da().toString();
  };
  I2.prototype.readSignedVarint32String = I2.prototype.Ea;
  I2.prototype.Ia = function() {
    var a = this.o();
    return a >>> 1 ^ -(a & 1);
  };
  I2.prototype.readZigzagVarint32 = I2.prototype.Ia;
  I2.prototype.Ga = function() {
    return this.w(D2);
  };
  I2.prototype.readUnsignedVarint64 = I2.prototype.Ga;
  I2.prototype.Ha = function() {
    return this.w(F2);
  };
  I2.prototype.readUnsignedVarint64String = I2.prototype.Ha;
  I2.prototype.sa = function() {
    return this.w(E2);
  };
  I2.prototype.readSignedVarint64 = I2.prototype.sa;
  I2.prototype.Fa = function() {
    return this.w(G2);
  };
  I2.prototype.readSignedVarint64String = I2.prototype.Fa;
  I2.prototype.Ja = function() {
    return this.w(Ka2);
  };
  I2.prototype.readZigzagVarint64 = I2.prototype.Ja;
  I2.prototype.fb = function() {
    return this.ea(Pa2);
  };
  I2.prototype.readZigzagVarintHash64 = I2.prototype.fb;
  I2.prototype.Ka = function() {
    return this.ea(G2);
  };
  I2.prototype.readZigzagVarint64String = I2.prototype.Ka;
  I2.prototype.Gc = function() {
    var a = this.b[this.a];
    this.a += 1;
    n2(this.a <= this.c);
    return a;
  };
  I2.prototype.readUint8 = I2.prototype.Gc;
  I2.prototype.Ec = function() {
    var a = this.b[this.a], b2 = this.b[this.a + 1];
    this.a += 2;
    n2(this.a <= this.c);
    return a << 0 | b2 << 8;
  };
  I2.prototype.readUint16 = I2.prototype.Ec;
  I2.prototype.m = function() {
    var a = this.b[this.a], b2 = this.b[this.a + 1], c = this.b[this.a + 2], d = this.b[this.a + 3];
    this.a += 4;
    n2(this.a <= this.c);
    return (a << 0 | b2 << 8 | c << 16 | d << 24) >>> 0;
  };
  I2.prototype.readUint32 = I2.prototype.m;
  I2.prototype.ga = function() {
    var a = this.m(), b2 = this.m();
    return D2(a, b2);
  };
  I2.prototype.readUint64 = I2.prototype.ga;
  I2.prototype.ha = function() {
    var a = this.m(), b2 = this.m();
    return F2(a, b2);
  };
  I2.prototype.readUint64String = I2.prototype.ha;
  I2.prototype.Xb = function() {
    var a = this.b[this.a];
    this.a += 1;
    n2(this.a <= this.c);
    return a << 24 >> 24;
  };
  I2.prototype.readInt8 = I2.prototype.Xb;
  I2.prototype.Vb = function() {
    var a = this.b[this.a], b2 = this.b[this.a + 1];
    this.a += 2;
    n2(this.a <= this.c);
    return (a << 0 | b2 << 8) << 16 >> 16;
  };
  I2.prototype.readInt16 = I2.prototype.Vb;
  I2.prototype.P = function() {
    var a = this.b[this.a], b2 = this.b[this.a + 1], c = this.b[this.a + 2], d = this.b[this.a + 3];
    this.a += 4;
    n2(this.a <= this.c);
    return a << 0 | b2 << 8 | c << 16 | d << 24;
  };
  I2.prototype.readInt32 = I2.prototype.P;
  I2.prototype.ba = function() {
    var a = this.m(), b2 = this.m();
    return E2(a, b2);
  };
  I2.prototype.readInt64 = I2.prototype.ba;
  I2.prototype.ca = function() {
    var a = this.m(), b2 = this.m();
    return G2(a, b2);
  };
  I2.prototype.readInt64String = I2.prototype.ca;
  I2.prototype.aa = function() {
    var a = this.m();
    return Na2(a);
  };
  I2.prototype.readFloat = I2.prototype.aa;
  I2.prototype.Z = function() {
    var a = this.m(), b2 = this.m();
    return Oa2(a, b2);
  };
  I2.prototype.readDouble = I2.prototype.Z;
  I2.prototype.pa = function() {
    return !!this.b[this.a++];
  };
  I2.prototype.readBool = I2.prototype.pa;
  I2.prototype.ra = function() {
    return this.da();
  };
  I2.prototype.readEnum = I2.prototype.ra;
  I2.prototype.fa = function(a) {
    var b2 = this.b, c = this.a;
    a = c + a;
    for (var d = [], f2 = ""; c < a; ) {
      var h2 = b2[c++];
      if (128 > h2)
        d.push(h2);
      else if (192 > h2)
        continue;
      else if (224 > h2) {
        var m2 = b2[c++];
        d.push((h2 & 31) << 6 | m2 & 63);
      } else if (240 > h2) {
        m2 = b2[c++];
        var t2 = b2[c++];
        d.push((h2 & 15) << 12 | (m2 & 63) << 6 | t2 & 63);
      } else if (248 > h2) {
        m2 = b2[c++];
        t2 = b2[c++];
        var B2 = b2[c++];
        h2 = (h2 & 7) << 18 | (m2 & 63) << 12 | (t2 & 63) << 6 | B2 & 63;
        h2 -= 65536;
        d.push((h2 >> 10 & 1023) + 55296, (h2 & 1023) + 56320);
      }
      8192 <= d.length && (f2 += String.fromCharCode.apply(null, d), d.length = 0);
    }
    f2 += xa(d);
    this.a = c;
    return f2;
  };
  I2.prototype.readString = I2.prototype.fa;
  I2.prototype.Dc = function() {
    var a = this.o();
    return this.fa(a);
  };
  I2.prototype.readStringWithLength = I2.prototype.Dc;
  I2.prototype.qa = function(a) {
    if (0 > a || this.a + a > this.b.length)
      return this.v = true, p2("Invalid byte length!"), new Uint8Array(0);
    var b2 = this.b.subarray(this.a, this.a + a);
    this.a += a;
    n2(this.a <= this.c);
    return b2;
  };
  I2.prototype.readBytes = I2.prototype.qa;
  I2.prototype.ia = function() {
    return this.w(Pa2);
  };
  I2.prototype.readVarintHash64 = I2.prototype.ia;
  I2.prototype.$ = function() {
    var a = this.b, b2 = this.a, c = a[b2], d = a[b2 + 1], f2 = a[b2 + 2], h2 = a[b2 + 3], m2 = a[b2 + 4], t2 = a[b2 + 5], B2 = a[b2 + 6];
    a = a[b2 + 7];
    this.a += 8;
    return String.fromCharCode(c, d, f2, h2, m2, t2, B2, a);
  };
  I2.prototype.readFixedHash64 = I2.prototype.$;
  function J2(a, b2, c) {
    this.a = Wa2(a, b2, c);
    this.O = this.a.B();
    this.b = this.c = -1;
    this.h = false;
    this.v = null;
  }
  g("jspb.BinaryReader", J2, void 0);
  var K2 = [];
  J2.clearInstanceCache = function() {
    K2 = [];
  };
  J2.getInstanceCacheLength = function() {
    return K2.length;
  };
  function Xa2(a, b2, c) {
    if (K2.length) {
      var d = K2.pop();
      a && d.a.H(a, b2, c);
      return d;
    }
    return new J2(a, b2, c);
  }
  J2.alloc = Xa2;
  J2.prototype.zb = Xa2;
  J2.prototype.alloc = J2.prototype.zb;
  J2.prototype.Ca = function() {
    this.a.clear();
    this.b = this.c = -1;
    this.h = false;
    this.v = null;
    100 > K2.length && K2.push(this);
  };
  J2.prototype.free = J2.prototype.Ca;
  J2.prototype.Fb = function() {
    return this.O;
  };
  J2.prototype.getFieldCursor = J2.prototype.Fb;
  J2.prototype.B = function() {
    return this.a.B();
  };
  J2.prototype.getCursor = J2.prototype.B;
  J2.prototype.Y = function() {
    return this.a.Y();
  };
  J2.prototype.getBuffer = J2.prototype.Y;
  J2.prototype.Hb = function() {
    return this.c;
  };
  J2.prototype.getFieldNumber = J2.prototype.Hb;
  J2.prototype.Lb = function() {
    return this.b;
  };
  J2.prototype.getWireType = J2.prototype.Lb;
  J2.prototype.Mb = function() {
    return 2 == this.b;
  };
  J2.prototype.isDelimited = J2.prototype.Mb;
  J2.prototype.bb = function() {
    return 4 == this.b;
  };
  J2.prototype.isEndGroup = J2.prototype.bb;
  J2.prototype.getError = function() {
    return this.h || this.a.getError();
  };
  J2.prototype.getError = J2.prototype.getError;
  J2.prototype.H = function(a, b2, c) {
    this.a.H(a, b2, c);
    this.b = this.c = -1;
  };
  J2.prototype.setBlock = J2.prototype.H;
  J2.prototype.reset = function() {
    this.a.reset();
    this.b = this.c = -1;
  };
  J2.prototype.reset = J2.prototype.reset;
  J2.prototype.advance = function(a) {
    this.a.advance(a);
  };
  J2.prototype.advance = J2.prototype.advance;
  J2.prototype.oa = function() {
    if (this.a.ya())
      return false;
    if (this.getError())
      return p2("Decoder hit an error"), false;
    this.O = this.a.B();
    var a = this.a.o(), b2 = a >>> 3;
    a &= 7;
    if (0 != a && 5 != a && 1 != a && 2 != a && 3 != a && 4 != a)
      return p2("Invalid wire type: %s (at position %s)", a, this.O), this.h = true, false;
    this.c = b2;
    this.b = a;
    return true;
  };
  J2.prototype.nextField = J2.prototype.oa;
  J2.prototype.Oa = function() {
    this.a.mb(this.c << 3 | this.b);
  };
  J2.prototype.unskipHeader = J2.prototype.Oa;
  J2.prototype.Lc = function() {
    var a = this.c;
    for (this.Oa(); this.oa() && this.c == a; )
      this.C();
    this.a.ya() || this.Oa();
  };
  J2.prototype.skipMatchingFields = J2.prototype.Lc;
  J2.prototype.lb = function() {
    0 != this.b ? (p2("Invalid wire type for skipVarintField"), this.C()) : this.a.kb();
  };
  J2.prototype.skipVarintField = J2.prototype.lb;
  J2.prototype.gb = function() {
    if (2 != this.b)
      p2("Invalid wire type for skipDelimitedField"), this.C();
    else {
      var a = this.a.o();
      this.a.advance(a);
    }
  };
  J2.prototype.skipDelimitedField = J2.prototype.gb;
  J2.prototype.hb = function() {
    5 != this.b ? (p2("Invalid wire type for skipFixed32Field"), this.C()) : this.a.advance(4);
  };
  J2.prototype.skipFixed32Field = J2.prototype.hb;
  J2.prototype.ib = function() {
    1 != this.b ? (p2("Invalid wire type for skipFixed64Field"), this.C()) : this.a.advance(8);
  };
  J2.prototype.skipFixed64Field = J2.prototype.ib;
  J2.prototype.jb = function() {
    var a = this.c;
    do {
      if (!this.oa()) {
        p2("Unmatched start-group tag: stream EOF");
        this.h = true;
        break;
      }
      if (4 == this.b) {
        this.c != a && (p2("Unmatched end-group tag"), this.h = true);
        break;
      }
      this.C();
    } while (1);
  };
  J2.prototype.skipGroup = J2.prototype.jb;
  J2.prototype.C = function() {
    switch (this.b) {
      case 0:
        this.lb();
        break;
      case 1:
        this.ib();
        break;
      case 2:
        this.gb();
        break;
      case 5:
        this.hb();
        break;
      case 3:
        this.jb();
        break;
      default:
        p2("Invalid wire encoding for field.");
    }
  };
  J2.prototype.skipField = J2.prototype.C;
  J2.prototype.Hc = function(a, b2) {
    null === this.v && (this.v = {});
    n2(!this.v[a]);
    this.v[a] = b2;
  };
  J2.prototype.registerReadCallback = J2.prototype.Hc;
  J2.prototype.Ic = function(a) {
    n2(null !== this.v);
    a = this.v[a];
    n2(a);
    return a(this);
  };
  J2.prototype.runReadCallback = J2.prototype.Ic;
  J2.prototype.Yb = function(a, b2) {
    n2(2 == this.b);
    var c = this.a.c, d = this.a.o();
    d = this.a.B() + d;
    this.a.setEnd(d);
    b2(a, this);
    this.a.Ma(d);
    this.a.setEnd(c);
  };
  J2.prototype.readMessage = J2.prototype.Yb;
  J2.prototype.Ub = function(a, b2, c) {
    n2(3 == this.b);
    n2(this.c == a);
    c(b2, this);
    this.h || 4 == this.b || (p2("Group submessage did not end with an END_GROUP tag"), this.h = true);
  };
  J2.prototype.readGroup = J2.prototype.Ub;
  J2.prototype.Gb = function() {
    n2(2 == this.b);
    var a = this.a.o(), b2 = this.a.B(), c = b2 + a;
    a = Wa2(this.a.Y(), b2, a);
    this.a.Ma(c);
    return a;
  };
  J2.prototype.getFieldDecoder = J2.prototype.Gb;
  J2.prototype.P = function() {
    n2(0 == this.b);
    return this.a.da();
  };
  J2.prototype.readInt32 = J2.prototype.P;
  J2.prototype.Wb = function() {
    n2(0 == this.b);
    return this.a.Ea();
  };
  J2.prototype.readInt32String = J2.prototype.Wb;
  J2.prototype.ba = function() {
    n2(0 == this.b);
    return this.a.sa();
  };
  J2.prototype.readInt64 = J2.prototype.ba;
  J2.prototype.ca = function() {
    n2(0 == this.b);
    return this.a.Fa();
  };
  J2.prototype.readInt64String = J2.prototype.ca;
  J2.prototype.m = function() {
    n2(0 == this.b);
    return this.a.o();
  };
  J2.prototype.readUint32 = J2.prototype.m;
  J2.prototype.Fc = function() {
    n2(0 == this.b);
    return this.a.O();
  };
  J2.prototype.readUint32String = J2.prototype.Fc;
  J2.prototype.ga = function() {
    n2(0 == this.b);
    return this.a.Ga();
  };
  J2.prototype.readUint64 = J2.prototype.ga;
  J2.prototype.ha = function() {
    n2(0 == this.b);
    return this.a.Ha();
  };
  J2.prototype.readUint64String = J2.prototype.ha;
  J2.prototype.zc = function() {
    n2(0 == this.b);
    return this.a.Ia();
  };
  J2.prototype.readSint32 = J2.prototype.zc;
  J2.prototype.Ac = function() {
    n2(0 == this.b);
    return this.a.Ja();
  };
  J2.prototype.readSint64 = J2.prototype.Ac;
  J2.prototype.Bc = function() {
    n2(0 == this.b);
    return this.a.Ka();
  };
  J2.prototype.readSint64String = J2.prototype.Bc;
  J2.prototype.Rb = function() {
    n2(5 == this.b);
    return this.a.m();
  };
  J2.prototype.readFixed32 = J2.prototype.Rb;
  J2.prototype.Sb = function() {
    n2(1 == this.b);
    return this.a.ga();
  };
  J2.prototype.readFixed64 = J2.prototype.Sb;
  J2.prototype.Tb = function() {
    n2(1 == this.b);
    return this.a.ha();
  };
  J2.prototype.readFixed64String = J2.prototype.Tb;
  J2.prototype.vc = function() {
    n2(5 == this.b);
    return this.a.P();
  };
  J2.prototype.readSfixed32 = J2.prototype.vc;
  J2.prototype.wc = function() {
    n2(5 == this.b);
    return this.a.P().toString();
  };
  J2.prototype.readSfixed32String = J2.prototype.wc;
  J2.prototype.xc = function() {
    n2(1 == this.b);
    return this.a.ba();
  };
  J2.prototype.readSfixed64 = J2.prototype.xc;
  J2.prototype.yc = function() {
    n2(1 == this.b);
    return this.a.ca();
  };
  J2.prototype.readSfixed64String = J2.prototype.yc;
  J2.prototype.aa = function() {
    n2(5 == this.b);
    return this.a.aa();
  };
  J2.prototype.readFloat = J2.prototype.aa;
  J2.prototype.Z = function() {
    n2(1 == this.b);
    return this.a.Z();
  };
  J2.prototype.readDouble = J2.prototype.Z;
  J2.prototype.pa = function() {
    n2(0 == this.b);
    return !!this.a.o();
  };
  J2.prototype.readBool = J2.prototype.pa;
  J2.prototype.ra = function() {
    n2(0 == this.b);
    return this.a.sa();
  };
  J2.prototype.readEnum = J2.prototype.ra;
  J2.prototype.fa = function() {
    n2(2 == this.b);
    var a = this.a.o();
    return this.a.fa(a);
  };
  J2.prototype.readString = J2.prototype.fa;
  J2.prototype.qa = function() {
    n2(2 == this.b);
    var a = this.a.o();
    return this.a.qa(a);
  };
  J2.prototype.readBytes = J2.prototype.qa;
  J2.prototype.ia = function() {
    n2(0 == this.b);
    return this.a.ia();
  };
  J2.prototype.readVarintHash64 = J2.prototype.ia;
  J2.prototype.Cc = function() {
    n2(0 == this.b);
    return this.a.fb();
  };
  J2.prototype.readSintHash64 = J2.prototype.Cc;
  J2.prototype.w = function(a) {
    n2(0 == this.b);
    return this.a.w(a);
  };
  J2.prototype.readSplitVarint64 = J2.prototype.w;
  J2.prototype.ea = function(a) {
    n2(0 == this.b);
    return this.a.w(function(b2, c) {
      return Ma2(b2, c, a);
    });
  };
  J2.prototype.readSplitZigzagVarint64 = J2.prototype.ea;
  J2.prototype.$ = function() {
    n2(1 == this.b);
    return this.a.$();
  };
  J2.prototype.readFixedHash64 = J2.prototype.$;
  J2.prototype.ta = function(a) {
    n2(1 == this.b);
    return this.a.ta(a);
  };
  J2.prototype.readSplitFixed64 = J2.prototype.ta;
  function L2(a, b2) {
    n2(2 == a.b);
    var c = a.a.o();
    c = a.a.B() + c;
    for (var d = []; a.a.B() < c; )
      d.push(b2.call(a.a));
    return d;
  }
  J2.prototype.gc = function() {
    return L2(this, this.a.da);
  };
  J2.prototype.readPackedInt32 = J2.prototype.gc;
  J2.prototype.hc = function() {
    return L2(this, this.a.Ea);
  };
  J2.prototype.readPackedInt32String = J2.prototype.hc;
  J2.prototype.ic = function() {
    return L2(this, this.a.sa);
  };
  J2.prototype.readPackedInt64 = J2.prototype.ic;
  J2.prototype.jc = function() {
    return L2(this, this.a.Fa);
  };
  J2.prototype.readPackedInt64String = J2.prototype.jc;
  J2.prototype.qc = function() {
    return L2(this, this.a.o);
  };
  J2.prototype.readPackedUint32 = J2.prototype.qc;
  J2.prototype.rc = function() {
    return L2(this, this.a.O);
  };
  J2.prototype.readPackedUint32String = J2.prototype.rc;
  J2.prototype.sc = function() {
    return L2(this, this.a.Ga);
  };
  J2.prototype.readPackedUint64 = J2.prototype.sc;
  J2.prototype.tc = function() {
    return L2(this, this.a.Ha);
  };
  J2.prototype.readPackedUint64String = J2.prototype.tc;
  J2.prototype.nc = function() {
    return L2(this, this.a.Ia);
  };
  J2.prototype.readPackedSint32 = J2.prototype.nc;
  J2.prototype.oc = function() {
    return L2(this, this.a.Ja);
  };
  J2.prototype.readPackedSint64 = J2.prototype.oc;
  J2.prototype.pc = function() {
    return L2(this, this.a.Ka);
  };
  J2.prototype.readPackedSint64String = J2.prototype.pc;
  J2.prototype.bc = function() {
    return L2(this, this.a.m);
  };
  J2.prototype.readPackedFixed32 = J2.prototype.bc;
  J2.prototype.cc = function() {
    return L2(this, this.a.ga);
  };
  J2.prototype.readPackedFixed64 = J2.prototype.cc;
  J2.prototype.dc = function() {
    return L2(this, this.a.ha);
  };
  J2.prototype.readPackedFixed64String = J2.prototype.dc;
  J2.prototype.kc = function() {
    return L2(this, this.a.P);
  };
  J2.prototype.readPackedSfixed32 = J2.prototype.kc;
  J2.prototype.lc = function() {
    return L2(this, this.a.ba);
  };
  J2.prototype.readPackedSfixed64 = J2.prototype.lc;
  J2.prototype.mc = function() {
    return L2(this, this.a.ca);
  };
  J2.prototype.readPackedSfixed64String = J2.prototype.mc;
  J2.prototype.fc = function() {
    return L2(this, this.a.aa);
  };
  J2.prototype.readPackedFloat = J2.prototype.fc;
  J2.prototype.$b = function() {
    return L2(this, this.a.Z);
  };
  J2.prototype.readPackedDouble = J2.prototype.$b;
  J2.prototype.Zb = function() {
    return L2(this, this.a.pa);
  };
  J2.prototype.readPackedBool = J2.prototype.Zb;
  J2.prototype.ac = function() {
    return L2(this, this.a.ra);
  };
  J2.prototype.readPackedEnum = J2.prototype.ac;
  J2.prototype.uc = function() {
    return L2(this, this.a.ia);
  };
  J2.prototype.readPackedVarintHash64 = J2.prototype.uc;
  J2.prototype.ec = function() {
    return L2(this, this.a.$);
  };
  J2.prototype.readPackedFixedHash64 = J2.prototype.ec;
  function Ya2(a, b2, c, d, f2) {
    this.ma = a;
    this.Ba = b2;
    this.la = c;
    this.Na = d;
    this.na = f2;
  }
  g("jspb.ExtensionFieldInfo", Ya2, void 0);
  function Za2(a, b2, c, d, f2, h2) {
    this.Za = a;
    this.za = b2;
    this.Aa = c;
    this.Wa = d;
    this.Ab = f2;
    this.Nb = h2;
  }
  g("jspb.ExtensionFieldBinaryInfo", Za2, void 0);
  Ya2.prototype.F = function() {
    return !!this.la;
  };
  Ya2.prototype.isMessageType = Ya2.prototype.F;
  function N2() {
  }
  g("jspb.Message", N2, void 0);
  N2.GENERATE_TO_OBJECT = true;
  N2.GENERATE_FROM_OBJECT = true;
  var $a = "function" == typeof Uint8Array;
  N2.prototype.Ib = function() {
    return this.b;
  };
  N2.prototype.getJsPbMessageId = N2.prototype.Ib;
  N2.initialize = function(a, b2, c, d, f2, h2) {
    a.f = null;
    b2 || (b2 = c ? [c] : []);
    a.b = c ? String(c) : void 0;
    a.D = 0 === c ? -1 : 0;
    a.u = b2;
    a: {
      c = a.u.length;
      b2 = -1;
      if (c && (b2 = c - 1, c = a.u[b2], !(null === c || "object" != typeof c || Array.isArray(c) || $a && c instanceof Uint8Array))) {
        a.G = b2 - a.D;
        a.i = c;
        break a;
      }
      -1 < d ? (a.G = Math.max(d, b2 + 1 - a.D), a.i = null) : a.G = Number.MAX_VALUE;
    }
    a.a = {};
    if (f2)
      for (d = 0; d < f2.length; d++)
        b2 = f2[d], b2 < a.G ? (b2 += a.D, a.u[b2] = a.u[b2] || ab2) : (bb2(a), a.i[b2] = a.i[b2] || ab2);
    if (h2 && h2.length)
      for (d = 0; d < h2.length; d++)
        cb2(a, h2[d]);
  };
  var ab2 = Object.freeze ? Object.freeze([]) : [];
  function bb2(a) {
    var b2 = a.G + a.D;
    a.u[b2] || (a.i = a.u[b2] = {});
  }
  function db2(a, b2, c) {
    for (var d = [], f2 = 0; f2 < a.length; f2++)
      d[f2] = b2.call(a[f2], c, a[f2]);
    return d;
  }
  N2.toObjectList = db2;
  N2.toObjectExtension = function(a, b2, c, d, f2) {
    for (var h2 in c) {
      var m2 = c[h2], t2 = d.call(a, m2);
      if (null != t2) {
        for (var B2 in m2.Ba)
          if (m2.Ba.hasOwnProperty(B2))
            break;
        b2[B2] = m2.Na ? m2.na ? db2(t2, m2.Na, f2) : m2.Na(f2, t2) : t2;
      }
    }
  };
  N2.serializeBinaryExtensions = function(a, b2, c, d) {
    for (var f2 in c) {
      var h2 = c[f2], m2 = h2.Za;
      if (!h2.Aa)
        throw Error("Message extension present that was generated without binary serialization support");
      var t2 = d.call(a, m2);
      if (null != t2)
        if (m2.F())
          if (h2.Wa)
            h2.Aa.call(b2, m2.ma, t2, h2.Wa);
          else
            throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
        else
          h2.Aa.call(b2, m2.ma, t2);
    }
  };
  N2.readBinaryExtension = function(a, b2, c, d, f2) {
    var h2 = c[b2.c];
    if (h2) {
      c = h2.Za;
      if (!h2.za)
        throw Error("Deserializing extension whose generated code does not support binary format");
      if (c.F()) {
        var m2 = new c.la();
        h2.za.call(b2, m2, h2.Ab);
      } else
        m2 = h2.za.call(b2);
      c.na && !h2.Nb ? (b2 = d.call(a, c)) ? b2.push(m2) : f2.call(a, c, [m2]) : f2.call(a, c, m2);
    } else
      b2.C();
  };
  function O2(a, b2) {
    if (b2 < a.G) {
      b2 += a.D;
      var c = a.u[b2];
      return c === ab2 ? a.u[b2] = [] : c;
    }
    if (a.i)
      return c = a.i[b2], c === ab2 ? a.i[b2] = [] : c;
  }
  N2.getField = O2;
  N2.getRepeatedField = function(a, b2) {
    return O2(a, b2);
  };
  function eb2(a, b2) {
    a = O2(a, b2);
    return null == a ? a : +a;
  }
  N2.getOptionalFloatingPointField = eb2;
  function fb2(a, b2) {
    a = O2(a, b2);
    return null == a ? a : !!a;
  }
  N2.getBooleanField = fb2;
  N2.getRepeatedFloatingPointField = function(a, b2) {
    var c = O2(a, b2);
    a.a || (a.a = {});
    if (!a.a[b2]) {
      for (var d = 0; d < c.length; d++)
        c[d] = +c[d];
      a.a[b2] = true;
    }
    return c;
  };
  N2.getRepeatedBooleanField = function(a, b2) {
    var c = O2(a, b2);
    a.a || (a.a = {});
    if (!a.a[b2]) {
      for (var d = 0; d < c.length; d++)
        c[d] = !!c[d];
      a.a[b2] = true;
    }
    return c;
  };
  function gb2(a) {
    if (null == a || "string" === typeof a)
      return a;
    if ($a && a instanceof Uint8Array)
      return Ba2(a);
    p2("Cannot coerce to b64 string: " + k2(a));
    return null;
  }
  N2.bytesAsB64 = gb2;
  function hb2(a) {
    if (null == a || a instanceof Uint8Array)
      return a;
    if ("string" === typeof a)
      return Da2(a);
    p2("Cannot coerce to Uint8Array: " + k2(a));
    return null;
  }
  N2.bytesAsU8 = hb2;
  N2.bytesListAsB64 = function(a) {
    ib2(a);
    return a.length && "string" !== typeof a[0] ? l2(a, gb2) : a;
  };
  N2.bytesListAsU8 = function(a) {
    ib2(a);
    return !a.length || a[0] instanceof Uint8Array ? a : l2(a, hb2);
  };
  function ib2(a) {
    if (a && 1 < a.length) {
      var b2 = k2(a[0]);
      qa2(a, function(c) {
        k2(c) != b2 && p2("Inconsistent type in JSPB repeated field array. Got " + k2(c) + " expected " + b2);
      });
    }
  }
  function jb2(a, b2, c) {
    a = O2(a, b2);
    return null == a ? c : a;
  }
  N2.getFieldWithDefault = jb2;
  N2.getBooleanFieldWithDefault = function(a, b2, c) {
    a = fb2(a, b2);
    return null == a ? c : a;
  };
  N2.getFloatingPointFieldWithDefault = function(a, b2, c) {
    a = eb2(a, b2);
    return null == a ? c : a;
  };
  N2.getFieldProto3 = jb2;
  N2.getMapField = function(a, b2, c, d) {
    a.f || (a.f = {});
    if (b2 in a.f)
      return a.f[b2];
    var f2 = O2(a, b2);
    if (!f2) {
      if (c)
        return;
      f2 = [];
      P2(a, b2, f2);
    }
    return a.f[b2] = new r2(f2, d);
  };
  function P2(a, b2, c) {
    q2(a, N2);
    b2 < a.G ? a.u[b2 + a.D] = c : (bb2(a), a.i[b2] = c);
    return a;
  }
  N2.setField = P2;
  N2.setProto3IntField = function(a, b2, c) {
    return Q2(a, b2, c, 0);
  };
  N2.setProto3FloatField = function(a, b2, c) {
    return Q2(a, b2, c, 0);
  };
  N2.setProto3BooleanField = function(a, b2, c) {
    return Q2(a, b2, c, false);
  };
  N2.setProto3StringField = function(a, b2, c) {
    return Q2(a, b2, c, "");
  };
  N2.setProto3BytesField = function(a, b2, c) {
    return Q2(a, b2, c, "");
  };
  N2.setProto3EnumField = function(a, b2, c) {
    return Q2(a, b2, c, 0);
  };
  N2.setProto3StringIntField = function(a, b2, c) {
    return Q2(a, b2, c, "0");
  };
  function Q2(a, b2, c, d) {
    q2(a, N2);
    c !== d ? P2(a, b2, c) : b2 < a.G ? a.u[b2 + a.D] = null : (bb2(a), delete a.i[b2]);
    return a;
  }
  N2.addToRepeatedField = function(a, b2, c, d) {
    q2(a, N2);
    b2 = O2(a, b2);
    void 0 != d ? b2.splice(d, 0, c) : b2.push(c);
    return a;
  };
  function kb2(a, b2, c, d) {
    q2(a, N2);
    (c = cb2(a, c)) && c !== b2 && void 0 !== d && (a.f && c in a.f && (a.f[c] = void 0), P2(a, c, void 0));
    return P2(a, b2, d);
  }
  N2.setOneofField = kb2;
  function cb2(a, b2) {
    for (var c, d, f2 = 0; f2 < b2.length; f2++) {
      var h2 = b2[f2], m2 = O2(a, h2);
      null != m2 && (c = h2, d = m2, P2(a, h2, void 0));
    }
    return c ? (P2(a, c, d), c) : 0;
  }
  N2.computeOneofCase = cb2;
  N2.getWrapperField = function(a, b2, c, d) {
    a.f || (a.f = {});
    if (!a.f[c]) {
      var f2 = O2(a, c);
      if (d || f2)
        a.f[c] = new b2(f2);
    }
    return a.f[c];
  };
  N2.getRepeatedWrapperField = function(a, b2, c) {
    lb2(a, b2, c);
    b2 = a.f[c];
    b2 == ab2 && (b2 = a.f[c] = []);
    return b2;
  };
  function lb2(a, b2, c) {
    a.f || (a.f = {});
    if (!a.f[c]) {
      for (var d = O2(a, c), f2 = [], h2 = 0; h2 < d.length; h2++)
        f2[h2] = new b2(d[h2]);
      a.f[c] = f2;
    }
  }
  N2.setWrapperField = function(a, b2, c) {
    q2(a, N2);
    a.f || (a.f = {});
    var d = c ? c.g() : c;
    a.f[b2] = c;
    return P2(a, b2, d);
  };
  N2.setOneofWrapperField = function(a, b2, c, d) {
    q2(a, N2);
    a.f || (a.f = {});
    var f2 = d ? d.g() : d;
    a.f[b2] = d;
    return kb2(a, b2, c, f2);
  };
  N2.setRepeatedWrapperField = function(a, b2, c) {
    q2(a, N2);
    a.f || (a.f = {});
    c = c || [];
    for (var d = [], f2 = 0; f2 < c.length; f2++)
      d[f2] = c[f2].g();
    a.f[b2] = c;
    return P2(a, b2, d);
  };
  N2.addToRepeatedWrapperField = function(a, b2, c, d, f2) {
    lb2(a, d, b2);
    var h2 = a.f[b2];
    h2 || (h2 = a.f[b2] = []);
    c = c ? c : new d();
    a = O2(a, b2);
    void 0 != f2 ? (h2.splice(f2, 0, c), a.splice(f2, 0, c.g())) : (h2.push(c), a.push(c.g()));
    return c;
  };
  N2.toMap = function(a, b2, c, d) {
    for (var f2 = {}, h2 = 0; h2 < a.length; h2++)
      f2[b2.call(a[h2])] = c ? c.call(a[h2], d, a[h2]) : a[h2];
    return f2;
  };
  function mb2(a) {
    if (a.f)
      for (var b2 in a.f) {
        var c = a.f[b2];
        if (Array.isArray(c))
          for (var d = 0; d < c.length; d++)
            c[d] && c[d].g();
        else
          c && c.g();
      }
  }
  N2.prototype.g = function() {
    mb2(this);
    return this.u;
  };
  N2.prototype.toArray = N2.prototype.g;
  N2.prototype.toString = function() {
    mb2(this);
    return this.u.toString();
  };
  N2.prototype.getExtension = function(a) {
    if (this.i) {
      this.f || (this.f = {});
      var b2 = a.ma;
      if (a.na) {
        if (a.F())
          return this.f[b2] || (this.f[b2] = l2(this.i[b2] || [], function(c) {
            return new a.la(c);
          })), this.f[b2];
      } else if (a.F())
        return !this.f[b2] && this.i[b2] && (this.f[b2] = new a.la(this.i[b2])), this.f[b2];
      return this.i[b2];
    }
  };
  N2.prototype.getExtension = N2.prototype.getExtension;
  N2.prototype.Kc = function(a, b2) {
    this.f || (this.f = {});
    bb2(this);
    var c = a.ma;
    a.na ? (b2 = b2 || [], a.F() ? (this.f[c] = b2, this.i[c] = l2(b2, function(d) {
      return d.g();
    })) : this.i[c] = b2) : a.F() ? (this.f[c] = b2, this.i[c] = b2 ? b2.g() : b2) : this.i[c] = b2;
    return this;
  };
  N2.prototype.setExtension = N2.prototype.Kc;
  N2.difference = function(a, b2) {
    if (!(a instanceof b2.constructor))
      throw Error("Messages have different types.");
    var c = a.g();
    b2 = b2.g();
    var d = [], f2 = 0, h2 = c.length > b2.length ? c.length : b2.length;
    a.b && (d[0] = a.b, f2 = 1);
    for (; f2 < h2; f2++)
      nb2(c[f2], b2[f2]) || (d[f2] = b2[f2]);
    return new a.constructor(d);
  };
  N2.equals = function(a, b2) {
    return a == b2 || !(!a || !b2) && a instanceof b2.constructor && nb2(a.g(), b2.g());
  };
  function ob2(a, b2) {
    a = a || {};
    b2 = b2 || {};
    var c = {}, d;
    for (d in a)
      c[d] = 0;
    for (d in b2)
      c[d] = 0;
    for (d in c)
      if (!nb2(a[d], b2[d]))
        return false;
    return true;
  }
  N2.compareExtensions = ob2;
  function nb2(a, b2) {
    if (a == b2)
      return true;
    if (!la2(a) || !la2(b2))
      return "number" === typeof a && isNaN(a) || "number" === typeof b2 && isNaN(b2) ? String(a) == String(b2) : false;
    if (a.constructor != b2.constructor)
      return false;
    if ($a && a.constructor === Uint8Array) {
      if (a.length != b2.length)
        return false;
      for (var c = 0; c < a.length; c++)
        if (a[c] != b2[c])
          return false;
      return true;
    }
    if (a.constructor === Array) {
      var d = void 0, f2 = void 0, h2 = Math.max(a.length, b2.length);
      for (c = 0; c < h2; c++) {
        var m2 = a[c], t2 = b2[c];
        m2 && m2.constructor == Object && (n2(void 0 === d), n2(c === a.length - 1), d = m2, m2 = void 0);
        t2 && t2.constructor == Object && (n2(void 0 === f2), n2(c === b2.length - 1), f2 = t2, t2 = void 0);
        if (!nb2(m2, t2))
          return false;
      }
      return d || f2 ? (d = d || {}, f2 = f2 || {}, ob2(d, f2)) : true;
    }
    if (a.constructor === Object)
      return ob2(a, b2);
    throw Error("Invalid type in JSPB array");
  }
  N2.compareFields = nb2;
  N2.prototype.Bb = function() {
    return pb2(this);
  };
  N2.prototype.cloneMessage = N2.prototype.Bb;
  N2.prototype.clone = function() {
    return pb2(this);
  };
  N2.prototype.clone = N2.prototype.clone;
  N2.clone = function(a) {
    return pb2(a);
  };
  function pb2(a) {
    return new a.constructor(qb2(a.g()));
  }
  N2.copyInto = function(a, b2) {
    q2(a, N2);
    q2(b2, N2);
    n2(a.constructor == b2.constructor, "Copy source and target message should have the same type.");
    a = pb2(a);
    for (var c = b2.g(), d = a.g(), f2 = c.length = 0; f2 < d.length; f2++)
      c[f2] = d[f2];
    b2.f = a.f;
    b2.i = a.i;
  };
  function qb2(a) {
    if (Array.isArray(a)) {
      for (var b2 = Array(a.length), c = 0; c < a.length; c++) {
        var d = a[c];
        null != d && (b2[c] = "object" == typeof d ? qb2(n2(d)) : d);
      }
      return b2;
    }
    if ($a && a instanceof Uint8Array)
      return new Uint8Array(a);
    b2 = {};
    for (c in a)
      d = a[c], null != d && (b2[c] = "object" == typeof d ? qb2(n2(d)) : d);
    return b2;
  }
  N2.registerMessageType = function(a, b2) {
    b2.we = a;
  };
  var R2 = { dump: function(a) {
    q2(a, N2, "jspb.Message instance expected");
    n2(a.getExtension, "Only unobfuscated and unoptimized compilation modes supported.");
    return R2.X(a);
  } };
  g("jspb.debug.dump", R2.dump, void 0);
  R2.X = function(a) {
    var b2 = k2(a);
    if ("number" == b2 || "string" == b2 || "boolean" == b2 || "null" == b2 || "undefined" == b2 || "undefined" !== typeof Uint8Array && a instanceof Uint8Array)
      return a;
    if ("array" == b2)
      return ua2(a), l2(a, R2.X);
    if (a instanceof r2) {
      var c = {};
      a = a.entries();
      for (var d = a.next(); !d.done; d = a.next())
        c[d.value[0]] = R2.X(d.value[1]);
      return c;
    }
    q2(a, N2, "Only messages expected: " + a);
    b2 = a.constructor;
    var f2 = { $name: b2.name || b2.displayName };
    for (t2 in b2.prototype) {
      var h2 = /^get([A-Z]\w*)/.exec(t2);
      if (h2 && "getExtension" != t2 && "getJsPbMessageId" != t2) {
        var m2 = "has" + h2[1];
        if (!a[m2] || a[m2]())
          m2 = a[t2](), f2[R2.$a(h2[1])] = R2.X(m2);
      }
    }
    if (a.extensionObject_)
      return f2.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly", f2;
    for (d in b2.extensions)
      if (/^\d+$/.test(d)) {
        m2 = b2.extensions[d];
        var t2 = a.getExtension(m2);
        h2 = void 0;
        m2 = m2.Ba;
        var B2 = [], M2 = 0;
        for (h2 in m2)
          B2[M2++] = h2;
        h2 = B2[0];
        null != t2 && (c || (c = f2.$extensions = {}), c[R2.$a(h2)] = R2.X(t2));
      }
    return f2;
  };
  R2.$a = function(a) {
    return a.replace(/^[A-Z]/, function(b2) {
      return b2.toLowerCase();
    });
  };
  function S2() {
    this.a = [];
  }
  g("jspb.BinaryEncoder", S2, void 0);
  S2.prototype.length = function() {
    return this.a.length;
  };
  S2.prototype.length = S2.prototype.length;
  S2.prototype.end = function() {
    var a = this.a;
    this.a = [];
    return a;
  };
  S2.prototype.end = S2.prototype.end;
  S2.prototype.l = function(a, b2) {
    n2(a == Math.floor(a));
    n2(b2 == Math.floor(b2));
    n2(0 <= a && 4294967296 > a);
    for (n2(0 <= b2 && 4294967296 > b2); 0 < b2 || 127 < a; )
      this.a.push(a & 127 | 128), a = (a >>> 7 | b2 << 25) >>> 0, b2 >>>= 7;
    this.a.push(a);
  };
  S2.prototype.writeSplitVarint64 = S2.prototype.l;
  S2.prototype.A = function(a, b2) {
    n2(a == Math.floor(a));
    n2(b2 == Math.floor(b2));
    n2(0 <= a && 4294967296 > a);
    n2(0 <= b2 && 4294967296 > b2);
    this.s(a);
    this.s(b2);
  };
  S2.prototype.writeSplitFixed64 = S2.prototype.A;
  S2.prototype.j = function(a) {
    n2(a == Math.floor(a));
    for (n2(0 <= a && 4294967296 > a); 127 < a; )
      this.a.push(a & 127 | 128), a >>>= 7;
    this.a.push(a);
  };
  S2.prototype.writeUnsignedVarint32 = S2.prototype.j;
  S2.prototype.M = function(a) {
    n2(a == Math.floor(a));
    n2(-2147483648 <= a && 2147483648 > a);
    if (0 <= a)
      this.j(a);
    else {
      for (var b2 = 0; 9 > b2; b2++)
        this.a.push(a & 127 | 128), a >>= 7;
      this.a.push(1);
    }
  };
  S2.prototype.writeSignedVarint32 = S2.prototype.M;
  S2.prototype.va = function(a) {
    n2(a == Math.floor(a));
    n2(0 <= a && 18446744073709552e3 > a);
    A2(a);
    this.l(y2, z2);
  };
  S2.prototype.writeUnsignedVarint64 = S2.prototype.va;
  S2.prototype.ua = function(a) {
    n2(a == Math.floor(a));
    n2(-9223372036854776e3 <= a && 9223372036854776e3 > a);
    A2(a);
    this.l(y2, z2);
  };
  S2.prototype.writeSignedVarint64 = S2.prototype.ua;
  S2.prototype.wa = function(a) {
    n2(a == Math.floor(a));
    n2(-2147483648 <= a && 2147483648 > a);
    this.j((a << 1 ^ a >> 31) >>> 0);
  };
  S2.prototype.writeZigzagVarint32 = S2.prototype.wa;
  S2.prototype.xa = function(a) {
    n2(a == Math.floor(a));
    n2(-9223372036854776e3 <= a && 9223372036854776e3 > a);
    Ga2(a);
    this.l(y2, z2);
  };
  S2.prototype.writeZigzagVarint64 = S2.prototype.xa;
  S2.prototype.Ta = function(a) {
    this.W(H2(a));
  };
  S2.prototype.writeZigzagVarint64String = S2.prototype.Ta;
  S2.prototype.W = function(a) {
    var b2 = this;
    C2(a);
    Ja2(y2, z2, function(c, d) {
      b2.l(c >>> 0, d >>> 0);
    });
  };
  S2.prototype.writeZigzagVarintHash64 = S2.prototype.W;
  S2.prototype.be = function(a) {
    n2(a == Math.floor(a));
    n2(0 <= a && 256 > a);
    this.a.push(a >>> 0 & 255);
  };
  S2.prototype.writeUint8 = S2.prototype.be;
  S2.prototype.ae = function(a) {
    n2(a == Math.floor(a));
    n2(0 <= a && 65536 > a);
    this.a.push(a >>> 0 & 255);
    this.a.push(a >>> 8 & 255);
  };
  S2.prototype.writeUint16 = S2.prototype.ae;
  S2.prototype.s = function(a) {
    n2(a == Math.floor(a));
    n2(0 <= a && 4294967296 > a);
    this.a.push(a >>> 0 & 255);
    this.a.push(a >>> 8 & 255);
    this.a.push(a >>> 16 & 255);
    this.a.push(a >>> 24 & 255);
  };
  S2.prototype.writeUint32 = S2.prototype.s;
  S2.prototype.V = function(a) {
    n2(a == Math.floor(a));
    n2(0 <= a && 18446744073709552e3 > a);
    Fa2(a);
    this.s(y2);
    this.s(z2);
  };
  S2.prototype.writeUint64 = S2.prototype.V;
  S2.prototype.Qc = function(a) {
    n2(a == Math.floor(a));
    n2(-128 <= a && 128 > a);
    this.a.push(a >>> 0 & 255);
  };
  S2.prototype.writeInt8 = S2.prototype.Qc;
  S2.prototype.Pc = function(a) {
    n2(a == Math.floor(a));
    n2(-32768 <= a && 32768 > a);
    this.a.push(a >>> 0 & 255);
    this.a.push(a >>> 8 & 255);
  };
  S2.prototype.writeInt16 = S2.prototype.Pc;
  S2.prototype.S = function(a) {
    n2(a == Math.floor(a));
    n2(-2147483648 <= a && 2147483648 > a);
    this.a.push(a >>> 0 & 255);
    this.a.push(a >>> 8 & 255);
    this.a.push(a >>> 16 & 255);
    this.a.push(a >>> 24 & 255);
  };
  S2.prototype.writeInt32 = S2.prototype.S;
  S2.prototype.T = function(a) {
    n2(a == Math.floor(a));
    n2(-9223372036854776e3 <= a && 9223372036854776e3 > a);
    A2(a);
    this.A(y2, z2);
  };
  S2.prototype.writeInt64 = S2.prototype.T;
  S2.prototype.ka = function(a) {
    n2(a == Math.floor(a));
    n2(-9223372036854776e3 <= +a && 9223372036854776e3 > +a);
    C2(H2(a));
    this.A(y2, z2);
  };
  S2.prototype.writeInt64String = S2.prototype.ka;
  S2.prototype.L = function(a) {
    n2(Infinity === a || -Infinity === a || isNaN(a) || -34028234663852886e22 <= a && 34028234663852886e22 >= a);
    Ha2(a);
    this.s(y2);
  };
  S2.prototype.writeFloat = S2.prototype.L;
  S2.prototype.J = function(a) {
    n2(Infinity === a || -Infinity === a || isNaN(a) || -17976931348623157e292 <= a && 17976931348623157e292 >= a);
    Ia2(a);
    this.s(y2);
    this.s(z2);
  };
  S2.prototype.writeDouble = S2.prototype.J;
  S2.prototype.I = function(a) {
    n2("boolean" === typeof a || "number" === typeof a);
    this.a.push(a ? 1 : 0);
  };
  S2.prototype.writeBool = S2.prototype.I;
  S2.prototype.R = function(a) {
    n2(a == Math.floor(a));
    n2(-2147483648 <= a && 2147483648 > a);
    this.M(a);
  };
  S2.prototype.writeEnum = S2.prototype.R;
  S2.prototype.ja = function(a) {
    this.a.push.apply(this.a, a);
  };
  S2.prototype.writeBytes = S2.prototype.ja;
  S2.prototype.N = function(a) {
    C2(a);
    this.l(y2, z2);
  };
  S2.prototype.writeVarintHash64 = S2.prototype.N;
  S2.prototype.K = function(a) {
    C2(a);
    this.s(y2);
    this.s(z2);
  };
  S2.prototype.writeFixedHash64 = S2.prototype.K;
  S2.prototype.U = function(a) {
    var b2 = this.a.length;
    ta2(a);
    for (var c = 0; c < a.length; c++) {
      var d = a.charCodeAt(c);
      if (128 > d)
        this.a.push(d);
      else if (2048 > d)
        this.a.push(d >> 6 | 192), this.a.push(d & 63 | 128);
      else if (65536 > d)
        if (55296 <= d && 56319 >= d && c + 1 < a.length) {
          var f2 = a.charCodeAt(c + 1);
          56320 <= f2 && 57343 >= f2 && (d = 1024 * (d - 55296) + f2 - 56320 + 65536, this.a.push(d >> 18 | 240), this.a.push(d >> 12 & 63 | 128), this.a.push(d >> 6 & 63 | 128), this.a.push(d & 63 | 128), c++);
        } else
          this.a.push(d >> 12 | 224), this.a.push(d >> 6 & 63 | 128), this.a.push(d & 63 | 128);
    }
    return this.a.length - b2;
  };
  S2.prototype.writeString = S2.prototype.U;
  function T9(a, b2) {
    this.lo = a;
    this.hi = b2;
  }
  g("jspb.arith.UInt64", T9, void 0);
  T9.prototype.cmp = function(a) {
    return this.hi < a.hi || this.hi == a.hi && this.lo < a.lo ? -1 : this.hi == a.hi && this.lo == a.lo ? 0 : 1;
  };
  T9.prototype.cmp = T9.prototype.cmp;
  T9.prototype.La = function() {
    return new T9((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
  };
  T9.prototype.rightShift = T9.prototype.La;
  T9.prototype.Da = function() {
    return new T9(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
  };
  T9.prototype.leftShift = T9.prototype.Da;
  T9.prototype.cb = function() {
    return !!(this.hi & 2147483648);
  };
  T9.prototype.msb = T9.prototype.cb;
  T9.prototype.Ob = function() {
    return !!(this.lo & 1);
  };
  T9.prototype.lsb = T9.prototype.Ob;
  T9.prototype.Ua = function() {
    return 0 == this.lo && 0 == this.hi;
  };
  T9.prototype.zero = T9.prototype.Ua;
  T9.prototype.add = function(a) {
    return new T9((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
  };
  T9.prototype.add = T9.prototype.add;
  T9.prototype.sub = function(a) {
    return new T9((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
  };
  T9.prototype.sub = T9.prototype.sub;
  function rb2(a, b2) {
    var c = a & 65535;
    a >>>= 16;
    var d = b2 & 65535, f2 = b2 >>> 16;
    b2 = c * d + 65536 * (c * f2 & 65535) + 65536 * (a * d & 65535);
    for (c = a * f2 + (c * f2 >>> 16) + (a * d >>> 16); 4294967296 <= b2; )
      b2 -= 4294967296, c += 1;
    return new T9(b2 >>> 0, c >>> 0);
  }
  T9.mul32x32 = rb2;
  T9.prototype.eb = function(a) {
    var b2 = rb2(this.lo, a);
    a = rb2(this.hi, a);
    a.hi = a.lo;
    a.lo = 0;
    return b2.add(a);
  };
  T9.prototype.mul = T9.prototype.eb;
  T9.prototype.Xa = function(a) {
    if (0 == a)
      return [];
    var b2 = new T9(0, 0), c = new T9(this.lo, this.hi);
    a = new T9(a, 0);
    for (var d = new T9(1, 0); !a.cb(); )
      a = a.Da(), d = d.Da();
    for (; !d.Ua(); )
      0 >= a.cmp(c) && (b2 = b2.add(d), c = c.sub(a)), a = a.La(), d = d.La();
    return [b2, c];
  };
  T9.prototype.div = T9.prototype.Xa;
  T9.prototype.toString = function() {
    for (var a = "", b2 = this; !b2.Ua(); ) {
      b2 = b2.Xa(10);
      var c = b2[0];
      a = b2[1].lo + a;
      b2 = c;
    }
    "" == a && (a = "0");
    return a;
  };
  T9.prototype.toString = T9.prototype.toString;
  function U5(a) {
    for (var b2 = new T9(0, 0), c = new T9(0, 0), d = 0; d < a.length; d++) {
      if ("0" > a[d] || "9" < a[d])
        return null;
      c.lo = parseInt(a[d], 10);
      b2 = b2.eb(10).add(c);
    }
    return b2;
  }
  T9.fromString = U5;
  T9.prototype.clone = function() {
    return new T9(this.lo, this.hi);
  };
  T9.prototype.clone = T9.prototype.clone;
  function V2(a, b2) {
    this.lo = a;
    this.hi = b2;
  }
  g("jspb.arith.Int64", V2, void 0);
  V2.prototype.add = function(a) {
    return new V2((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
  };
  V2.prototype.add = V2.prototype.add;
  V2.prototype.sub = function(a) {
    return new V2((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
  };
  V2.prototype.sub = V2.prototype.sub;
  V2.prototype.clone = function() {
    return new V2(this.lo, this.hi);
  };
  V2.prototype.clone = V2.prototype.clone;
  V2.prototype.toString = function() {
    var a = 0 != (this.hi & 2147483648), b2 = new T9(this.lo, this.hi);
    a && (b2 = new T9(0, 0).sub(b2));
    return (a ? "-" : "") + b2.toString();
  };
  V2.prototype.toString = V2.prototype.toString;
  function sb2(a) {
    var b2 = 0 < a.length && "-" == a[0];
    b2 && (a = a.substring(1));
    a = U5(a);
    if (null === a)
      return null;
    b2 && (a = new T9(0, 0).sub(a));
    return new V2(a.lo, a.hi);
  }
  V2.fromString = sb2;
  function W2() {
    this.c = [];
    this.b = 0;
    this.a = new S2();
    this.h = [];
  }
  g("jspb.BinaryWriter", W2, void 0);
  function tb2(a, b2) {
    var c = a.a.end();
    a.c.push(c);
    a.c.push(b2);
    a.b += c.length + b2.length;
  }
  function X2(a, b2) {
    Y2(a, b2, 2);
    b2 = a.a.end();
    a.c.push(b2);
    a.b += b2.length;
    b2.push(a.b);
    return b2;
  }
  function Z2(a, b2) {
    var c = b2.pop();
    c = a.b + a.a.length() - c;
    for (n2(0 <= c); 127 < c; )
      b2.push(c & 127 | 128), c >>>= 7, a.b++;
    b2.push(c);
    a.b++;
  }
  W2.prototype.pb = function(a, b2, c) {
    tb2(this, a.subarray(b2, c));
  };
  W2.prototype.writeSerializedMessage = W2.prototype.pb;
  W2.prototype.Pb = function(a, b2, c) {
    null != a && null != b2 && null != c && this.pb(a, b2, c);
  };
  W2.prototype.maybeWriteSerializedMessage = W2.prototype.Pb;
  W2.prototype.reset = function() {
    this.c = [];
    this.a.end();
    this.b = 0;
    this.h = [];
  };
  W2.prototype.reset = W2.prototype.reset;
  W2.prototype.ab = function() {
    n2(0 == this.h.length);
    for (var a = new Uint8Array(this.b + this.a.length()), b2 = this.c, c = b2.length, d = 0, f2 = 0; f2 < c; f2++) {
      var h2 = b2[f2];
      a.set(h2, d);
      d += h2.length;
    }
    b2 = this.a.end();
    a.set(b2, d);
    d += b2.length;
    n2(d == a.length);
    this.c = [a];
    return a;
  };
  W2.prototype.getResultBuffer = W2.prototype.ab;
  W2.prototype.Kb = function(a) {
    return Ba2(this.ab(), a);
  };
  W2.prototype.getResultBase64String = W2.prototype.Kb;
  W2.prototype.Va = function(a) {
    this.h.push(X2(this, a));
  };
  W2.prototype.beginSubMessage = W2.prototype.Va;
  W2.prototype.Ya = function() {
    n2(0 <= this.h.length);
    Z2(this, this.h.pop());
  };
  W2.prototype.endSubMessage = W2.prototype.Ya;
  function Y2(a, b2, c) {
    n2(1 <= b2 && b2 == Math.floor(b2));
    a.a.j(8 * b2 + c);
  }
  W2.prototype.Nc = function(a, b2, c) {
    switch (a) {
      case 1:
        this.J(b2, c);
        break;
      case 2:
        this.L(b2, c);
        break;
      case 3:
        this.T(b2, c);
        break;
      case 4:
        this.V(b2, c);
        break;
      case 5:
        this.S(b2, c);
        break;
      case 6:
        this.Qa(b2, c);
        break;
      case 7:
        this.Pa(b2, c);
        break;
      case 8:
        this.I(b2, c);
        break;
      case 9:
        this.U(b2, c);
        break;
      case 10:
        p2("Group field type not supported in writeAny()");
        break;
      case 11:
        p2("Message field type not supported in writeAny()");
        break;
      case 12:
        this.ja(b2, c);
        break;
      case 13:
        this.s(b2, c);
        break;
      case 14:
        this.R(b2, c);
        break;
      case 15:
        this.Ra(b2, c);
        break;
      case 16:
        this.Sa(b2, c);
        break;
      case 17:
        this.rb(b2, c);
        break;
      case 18:
        this.sb(b2, c);
        break;
      case 30:
        this.K(b2, c);
        break;
      case 31:
        this.N(b2, c);
        break;
      default:
        p2("Invalid field type in writeAny()");
    }
  };
  W2.prototype.writeAny = W2.prototype.Nc;
  function ub2(a, b2, c) {
    null != c && (Y2(a, b2, 0), a.a.j(c));
  }
  function vb2(a, b2, c) {
    null != c && (Y2(a, b2, 0), a.a.M(c));
  }
  W2.prototype.S = function(a, b2) {
    null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), vb2(this, a, b2));
  };
  W2.prototype.writeInt32 = W2.prototype.S;
  W2.prototype.ob = function(a, b2) {
    null != b2 && (b2 = parseInt(b2, 10), n2(-2147483648 <= b2 && 2147483648 > b2), vb2(this, a, b2));
  };
  W2.prototype.writeInt32String = W2.prototype.ob;
  W2.prototype.T = function(a, b2) {
    null != b2 && (n2(-9223372036854776e3 <= b2 && 9223372036854776e3 > b2), null != b2 && (Y2(this, a, 0), this.a.ua(b2)));
  };
  W2.prototype.writeInt64 = W2.prototype.T;
  W2.prototype.ka = function(a, b2) {
    null != b2 && (b2 = sb2(b2), Y2(this, a, 0), this.a.l(b2.lo, b2.hi));
  };
  W2.prototype.writeInt64String = W2.prototype.ka;
  W2.prototype.s = function(a, b2) {
    null != b2 && (n2(0 <= b2 && 4294967296 > b2), ub2(this, a, b2));
  };
  W2.prototype.writeUint32 = W2.prototype.s;
  W2.prototype.ub = function(a, b2) {
    null != b2 && (b2 = parseInt(b2, 10), n2(0 <= b2 && 4294967296 > b2), ub2(this, a, b2));
  };
  W2.prototype.writeUint32String = W2.prototype.ub;
  W2.prototype.V = function(a, b2) {
    null != b2 && (n2(0 <= b2 && 18446744073709552e3 > b2), null != b2 && (Y2(this, a, 0), this.a.va(b2)));
  };
  W2.prototype.writeUint64 = W2.prototype.V;
  W2.prototype.vb = function(a, b2) {
    null != b2 && (b2 = U5(b2), Y2(this, a, 0), this.a.l(b2.lo, b2.hi));
  };
  W2.prototype.writeUint64String = W2.prototype.vb;
  W2.prototype.rb = function(a, b2) {
    null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), null != b2 && (Y2(this, a, 0), this.a.wa(b2)));
  };
  W2.prototype.writeSint32 = W2.prototype.rb;
  W2.prototype.sb = function(a, b2) {
    null != b2 && (n2(-9223372036854776e3 <= b2 && 9223372036854776e3 > b2), null != b2 && (Y2(this, a, 0), this.a.xa(b2)));
  };
  W2.prototype.writeSint64 = W2.prototype.sb;
  W2.prototype.$d = function(a, b2) {
    null != b2 && null != b2 && (Y2(this, a, 0), this.a.W(b2));
  };
  W2.prototype.writeSintHash64 = W2.prototype.$d;
  W2.prototype.Zd = function(a, b2) {
    null != b2 && null != b2 && (Y2(this, a, 0), this.a.Ta(b2));
  };
  W2.prototype.writeSint64String = W2.prototype.Zd;
  W2.prototype.Pa = function(a, b2) {
    null != b2 && (n2(0 <= b2 && 4294967296 > b2), Y2(this, a, 5), this.a.s(b2));
  };
  W2.prototype.writeFixed32 = W2.prototype.Pa;
  W2.prototype.Qa = function(a, b2) {
    null != b2 && (n2(0 <= b2 && 18446744073709552e3 > b2), Y2(this, a, 1), this.a.V(b2));
  };
  W2.prototype.writeFixed64 = W2.prototype.Qa;
  W2.prototype.nb = function(a, b2) {
    null != b2 && (b2 = U5(b2), Y2(this, a, 1), this.a.A(b2.lo, b2.hi));
  };
  W2.prototype.writeFixed64String = W2.prototype.nb;
  W2.prototype.Ra = function(a, b2) {
    null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), Y2(this, a, 5), this.a.S(b2));
  };
  W2.prototype.writeSfixed32 = W2.prototype.Ra;
  W2.prototype.Sa = function(a, b2) {
    null != b2 && (n2(-9223372036854776e3 <= b2 && 9223372036854776e3 > b2), Y2(this, a, 1), this.a.T(b2));
  };
  W2.prototype.writeSfixed64 = W2.prototype.Sa;
  W2.prototype.qb = function(a, b2) {
    null != b2 && (b2 = sb2(b2), Y2(this, a, 1), this.a.A(b2.lo, b2.hi));
  };
  W2.prototype.writeSfixed64String = W2.prototype.qb;
  W2.prototype.L = function(a, b2) {
    null != b2 && (Y2(this, a, 5), this.a.L(b2));
  };
  W2.prototype.writeFloat = W2.prototype.L;
  W2.prototype.J = function(a, b2) {
    null != b2 && (Y2(this, a, 1), this.a.J(b2));
  };
  W2.prototype.writeDouble = W2.prototype.J;
  W2.prototype.I = function(a, b2) {
    null != b2 && (n2("boolean" === typeof b2 || "number" === typeof b2), Y2(this, a, 0), this.a.I(b2));
  };
  W2.prototype.writeBool = W2.prototype.I;
  W2.prototype.R = function(a, b2) {
    null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), Y2(this, a, 0), this.a.M(b2));
  };
  W2.prototype.writeEnum = W2.prototype.R;
  W2.prototype.U = function(a, b2) {
    null != b2 && (a = X2(this, a), this.a.U(b2), Z2(this, a));
  };
  W2.prototype.writeString = W2.prototype.U;
  W2.prototype.ja = function(a, b2) {
    null != b2 && (b2 = Ua2(b2), Y2(this, a, 2), this.a.j(b2.length), tb2(this, b2));
  };
  W2.prototype.writeBytes = W2.prototype.ja;
  W2.prototype.Rc = function(a, b2, c) {
    null != b2 && (a = X2(this, a), c(b2, this), Z2(this, a));
  };
  W2.prototype.writeMessage = W2.prototype.Rc;
  W2.prototype.Sc = function(a, b2, c) {
    null != b2 && (Y2(this, 1, 3), Y2(this, 2, 0), this.a.M(a), a = X2(this, 3), c(b2, this), Z2(this, a), Y2(this, 1, 4));
  };
  W2.prototype.writeMessageSet = W2.prototype.Sc;
  W2.prototype.Oc = function(a, b2, c) {
    null != b2 && (Y2(this, a, 3), c(b2, this), Y2(this, a, 4));
  };
  W2.prototype.writeGroup = W2.prototype.Oc;
  W2.prototype.K = function(a, b2) {
    null != b2 && (n2(8 == b2.length), Y2(this, a, 1), this.a.K(b2));
  };
  W2.prototype.writeFixedHash64 = W2.prototype.K;
  W2.prototype.N = function(a, b2) {
    null != b2 && (n2(8 == b2.length), Y2(this, a, 0), this.a.N(b2));
  };
  W2.prototype.writeVarintHash64 = W2.prototype.N;
  W2.prototype.A = function(a, b2, c) {
    Y2(this, a, 1);
    this.a.A(b2, c);
  };
  W2.prototype.writeSplitFixed64 = W2.prototype.A;
  W2.prototype.l = function(a, b2, c) {
    Y2(this, a, 0);
    this.a.l(b2, c);
  };
  W2.prototype.writeSplitVarint64 = W2.prototype.l;
  W2.prototype.tb = function(a, b2, c) {
    Y2(this, a, 0);
    var d = this.a;
    Ja2(b2, c, function(f2, h2) {
      d.l(f2 >>> 0, h2 >>> 0);
    });
  };
  W2.prototype.writeSplitZigzagVarint64 = W2.prototype.tb;
  W2.prototype.Ed = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        vb2(this, a, b2[c]);
  };
  W2.prototype.writeRepeatedInt32 = W2.prototype.Ed;
  W2.prototype.Fd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.ob(a, b2[c]);
  };
  W2.prototype.writeRepeatedInt32String = W2.prototype.Fd;
  W2.prototype.Gd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y2(this, a, 0), this.a.ua(d));
      }
  };
  W2.prototype.writeRepeatedInt64 = W2.prototype.Gd;
  W2.prototype.Qd = function(a, b2, c, d) {
    if (null != b2)
      for (var f2 = 0; f2 < b2.length; f2++)
        this.A(a, c(b2[f2]), d(b2[f2]));
  };
  W2.prototype.writeRepeatedSplitFixed64 = W2.prototype.Qd;
  W2.prototype.Rd = function(a, b2, c, d) {
    if (null != b2)
      for (var f2 = 0; f2 < b2.length; f2++)
        this.l(a, c(b2[f2]), d(b2[f2]));
  };
  W2.prototype.writeRepeatedSplitVarint64 = W2.prototype.Rd;
  W2.prototype.Sd = function(a, b2, c, d) {
    if (null != b2)
      for (var f2 = 0; f2 < b2.length; f2++)
        this.tb(a, c(b2[f2]), d(b2[f2]));
  };
  W2.prototype.writeRepeatedSplitZigzagVarint64 = W2.prototype.Sd;
  W2.prototype.Hd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.ka(a, b2[c]);
  };
  W2.prototype.writeRepeatedInt64String = W2.prototype.Hd;
  W2.prototype.Ud = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        ub2(this, a, b2[c]);
  };
  W2.prototype.writeRepeatedUint32 = W2.prototype.Ud;
  W2.prototype.Vd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.ub(a, b2[c]);
  };
  W2.prototype.writeRepeatedUint32String = W2.prototype.Vd;
  W2.prototype.Wd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y2(this, a, 0), this.a.va(d));
      }
  };
  W2.prototype.writeRepeatedUint64 = W2.prototype.Wd;
  W2.prototype.Xd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.vb(a, b2[c]);
  };
  W2.prototype.writeRepeatedUint64String = W2.prototype.Xd;
  W2.prototype.Md = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y2(this, a, 0), this.a.wa(d));
      }
  };
  W2.prototype.writeRepeatedSint32 = W2.prototype.Md;
  W2.prototype.Nd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y2(this, a, 0), this.a.xa(d));
      }
  };
  W2.prototype.writeRepeatedSint64 = W2.prototype.Nd;
  W2.prototype.Od = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y2(this, a, 0), this.a.Ta(d));
      }
  };
  W2.prototype.writeRepeatedSint64String = W2.prototype.Od;
  W2.prototype.Pd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y2(this, a, 0), this.a.W(d));
      }
  };
  W2.prototype.writeRepeatedSintHash64 = W2.prototype.Pd;
  W2.prototype.yd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.Pa(a, b2[c]);
  };
  W2.prototype.writeRepeatedFixed32 = W2.prototype.yd;
  W2.prototype.zd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.Qa(a, b2[c]);
  };
  W2.prototype.writeRepeatedFixed64 = W2.prototype.zd;
  W2.prototype.Ad = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.nb(a, b2[c]);
  };
  W2.prototype.writeRepeatedFixed64String = W2.prototype.Ad;
  W2.prototype.Jd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.Ra(a, b2[c]);
  };
  W2.prototype.writeRepeatedSfixed32 = W2.prototype.Jd;
  W2.prototype.Kd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.Sa(a, b2[c]);
  };
  W2.prototype.writeRepeatedSfixed64 = W2.prototype.Kd;
  W2.prototype.Ld = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.qb(a, b2[c]);
  };
  W2.prototype.writeRepeatedSfixed64String = W2.prototype.Ld;
  W2.prototype.Cd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.L(a, b2[c]);
  };
  W2.prototype.writeRepeatedFloat = W2.prototype.Cd;
  W2.prototype.wd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.J(a, b2[c]);
  };
  W2.prototype.writeRepeatedDouble = W2.prototype.wd;
  W2.prototype.ud = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.I(a, b2[c]);
  };
  W2.prototype.writeRepeatedBool = W2.prototype.ud;
  W2.prototype.xd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.R(a, b2[c]);
  };
  W2.prototype.writeRepeatedEnum = W2.prototype.xd;
  W2.prototype.Td = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.U(a, b2[c]);
  };
  W2.prototype.writeRepeatedString = W2.prototype.Td;
  W2.prototype.vd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.ja(a, b2[c]);
  };
  W2.prototype.writeRepeatedBytes = W2.prototype.vd;
  W2.prototype.Id = function(a, b2, c) {
    if (null != b2)
      for (var d = 0; d < b2.length; d++) {
        var f2 = X2(this, a);
        c(b2[d], this);
        Z2(this, f2);
      }
  };
  W2.prototype.writeRepeatedMessage = W2.prototype.Id;
  W2.prototype.Dd = function(a, b2, c) {
    if (null != b2)
      for (var d = 0; d < b2.length; d++)
        Y2(this, a, 3), c(b2[d], this), Y2(this, a, 4);
  };
  W2.prototype.writeRepeatedGroup = W2.prototype.Dd;
  W2.prototype.Bd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.K(a, b2[c]);
  };
  W2.prototype.writeRepeatedFixedHash64 = W2.prototype.Bd;
  W2.prototype.Yd = function(a, b2) {
    if (null != b2)
      for (var c = 0; c < b2.length; c++)
        this.N(a, b2[c]);
  };
  W2.prototype.writeRepeatedVarintHash64 = W2.prototype.Yd;
  W2.prototype.ad = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.M(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedInt32 = W2.prototype.ad;
  W2.prototype.bd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.M(parseInt(b2[c], 10));
      Z2(this, a);
    }
  };
  W2.prototype.writePackedInt32String = W2.prototype.bd;
  W2.prototype.cd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.ua(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedInt64 = W2.prototype.cd;
  W2.prototype.md = function(a, b2, c, d) {
    if (null != b2) {
      a = X2(this, a);
      for (var f2 = 0; f2 < b2.length; f2++)
        this.a.A(c(b2[f2]), d(b2[f2]));
      Z2(this, a);
    }
  };
  W2.prototype.writePackedSplitFixed64 = W2.prototype.md;
  W2.prototype.nd = function(a, b2, c, d) {
    if (null != b2) {
      a = X2(this, a);
      for (var f2 = 0; f2 < b2.length; f2++)
        this.a.l(c(b2[f2]), d(b2[f2]));
      Z2(this, a);
    }
  };
  W2.prototype.writePackedSplitVarint64 = W2.prototype.nd;
  W2.prototype.od = function(a, b2, c, d) {
    if (null != b2) {
      a = X2(this, a);
      for (var f2 = this.a, h2 = 0; h2 < b2.length; h2++)
        Ja2(c(b2[h2]), d(b2[h2]), function(m2, t2) {
          f2.l(m2 >>> 0, t2 >>> 0);
        });
      Z2(this, a);
    }
  };
  W2.prototype.writePackedSplitZigzagVarint64 = W2.prototype.od;
  W2.prototype.dd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++) {
        var d = sb2(b2[c]);
        this.a.l(d.lo, d.hi);
      }
      Z2(this, a);
    }
  };
  W2.prototype.writePackedInt64String = W2.prototype.dd;
  W2.prototype.pd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.j(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedUint32 = W2.prototype.pd;
  W2.prototype.qd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.j(parseInt(b2[c], 10));
      Z2(this, a);
    }
  };
  W2.prototype.writePackedUint32String = W2.prototype.qd;
  W2.prototype.rd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.va(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedUint64 = W2.prototype.rd;
  W2.prototype.sd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++) {
        var d = U5(b2[c]);
        this.a.l(d.lo, d.hi);
      }
      Z2(this, a);
    }
  };
  W2.prototype.writePackedUint64String = W2.prototype.sd;
  W2.prototype.hd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.wa(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedSint32 = W2.prototype.hd;
  W2.prototype.jd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.xa(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedSint64 = W2.prototype.jd;
  W2.prototype.kd = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.W(H2(b2[c]));
      Z2(this, a);
    }
  };
  W2.prototype.writePackedSint64String = W2.prototype.kd;
  W2.prototype.ld = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.W(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedSintHash64 = W2.prototype.ld;
  W2.prototype.Wc = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(4 * b2.length), a = 0; a < b2.length; a++)
        this.a.s(b2[a]);
  };
  W2.prototype.writePackedFixed32 = W2.prototype.Wc;
  W2.prototype.Xc = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++)
        this.a.V(b2[a]);
  };
  W2.prototype.writePackedFixed64 = W2.prototype.Xc;
  W2.prototype.Yc = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++) {
        var c = U5(b2[a]);
        this.a.A(c.lo, c.hi);
      }
  };
  W2.prototype.writePackedFixed64String = W2.prototype.Yc;
  W2.prototype.ed = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(4 * b2.length), a = 0; a < b2.length; a++)
        this.a.S(b2[a]);
  };
  W2.prototype.writePackedSfixed32 = W2.prototype.ed;
  W2.prototype.fd = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++)
        this.a.T(b2[a]);
  };
  W2.prototype.writePackedSfixed64 = W2.prototype.fd;
  W2.prototype.gd = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++)
        this.a.ka(b2[a]);
  };
  W2.prototype.writePackedSfixed64String = W2.prototype.gd;
  W2.prototype.$c = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(4 * b2.length), a = 0; a < b2.length; a++)
        this.a.L(b2[a]);
  };
  W2.prototype.writePackedFloat = W2.prototype.$c;
  W2.prototype.Uc = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++)
        this.a.J(b2[a]);
  };
  W2.prototype.writePackedDouble = W2.prototype.Uc;
  W2.prototype.Tc = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(b2.length), a = 0; a < b2.length; a++)
        this.a.I(b2[a]);
  };
  W2.prototype.writePackedBool = W2.prototype.Tc;
  W2.prototype.Vc = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.R(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedEnum = W2.prototype.Vc;
  W2.prototype.Zc = function(a, b2) {
    if (null != b2 && b2.length)
      for (Y2(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++)
        this.a.K(b2[a]);
  };
  W2.prototype.writePackedFixedHash64 = W2.prototype.Zc;
  W2.prototype.td = function(a, b2) {
    if (null != b2 && b2.length) {
      a = X2(this, a);
      for (var c = 0; c < b2.length; c++)
        this.a.N(b2[c]);
      Z2(this, a);
    }
  };
  W2.prototype.writePackedVarintHash64 = W2.prototype.td;
  exports.debug = R2, exports.Map = r2, exports.Message = N2, exports.BinaryReader = J2, exports.BinaryWriter = W2, exports.ExtensionFieldInfo = Ya2, exports.ExtensionFieldBinaryInfo = Za2, exports.exportSymbol = ma2, exports.inherits = na, exports.object = { extend: pa2 }, exports.typeOf = k2;
})(googleProtobuf);
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  goog.exportSymbol("proto.google.protobuf.Any", null, global2);
  proto.google.protobuf.Any = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(proto.google.protobuf.Any, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    proto.google.protobuf.Any.displayName = "proto.google.protobuf.Any";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    proto.google.protobuf.Any.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.Any.toObject(opt_includeInstance, this);
    };
    proto.google.protobuf.Any.toObject = function(includeInstance, msg) {
      var obj = {
        typeUrl: jspb.Message.getFieldWithDefault(msg, 1, ""),
        value: msg.getValue_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  proto.google.protobuf.Any.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new proto.google.protobuf.Any();
    return proto.google.protobuf.Any.deserializeBinaryFromReader(msg, reader);
  };
  proto.google.protobuf.Any.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setTypeUrl(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setValue(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  proto.google.protobuf.Any.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    proto.google.protobuf.Any.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  proto.google.protobuf.Any.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getTypeUrl();
    if (f2.length > 0) {
      writer.writeString(
        1,
        f2
      );
    }
    f2 = message2.getValue_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
  };
  proto.google.protobuf.Any.prototype.getTypeUrl = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  proto.google.protobuf.Any.prototype.setTypeUrl = function(value) {
    return jspb.Message.setProto3StringField(this, 1, value);
  };
  proto.google.protobuf.Any.prototype.getValue = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  proto.google.protobuf.Any.prototype.getValue_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getValue()
      )
    );
  };
  proto.google.protobuf.Any.prototype.getValue_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getValue()
      )
    );
  };
  proto.google.protobuf.Any.prototype.setValue = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  goog.object.extend(exports, proto.google.protobuf);
  proto.google.protobuf.Any.prototype.getTypeName = function() {
    return this.getTypeUrl().split("/").pop();
  };
  proto.google.protobuf.Any.prototype.pack = function(serialized, name, opt_typeUrlPrefix) {
    if (!opt_typeUrlPrefix) {
      opt_typeUrlPrefix = "type.googleapis.com/";
    }
    if (opt_typeUrlPrefix.substr(-1) != "/") {
      this.setTypeUrl(opt_typeUrlPrefix + "/" + name);
    } else {
      this.setTypeUrl(opt_typeUrlPrefix + name);
    }
    this.setValue(serialized);
  };
  proto.google.protobuf.Any.prototype.unpack = function(deserialize2, name) {
    if (this.getTypeName() == name) {
      return deserialize2(this.getValue_asU8());
    } else {
      return null;
    }
  };
})(any_pb);
const google_protobuf_any_pb = /* @__PURE__ */ getDefaultExportFromCjs$1(any_pb);
var Tron_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  var google_protobuf_any_pb2 = any_pb;
  goog.object.extend(proto, google_protobuf_any_pb2);
  goog.exportSymbol("TronWebProto.Account", null, global2);
  goog.exportSymbol("TronWebProto.Account.AccountResource", null, global2);
  goog.exportSymbol("TronWebProto.Account.Frozen", null, global2);
  goog.exportSymbol("TronWebProto.AccountId", null, global2);
  goog.exportSymbol("TronWebProto.AccountType", null, global2);
  goog.exportSymbol("TronWebProto.DelegatedResource", null, global2);
  goog.exportSymbol("TronWebProto.Exchange", null, global2);
  goog.exportSymbol("TronWebProto.Key", null, global2);
  goog.exportSymbol("TronWebProto.MarketOrderDetail", null, global2);
  goog.exportSymbol("TronWebProto.Permission", null, global2);
  goog.exportSymbol("TronWebProto.Permission.PermissionType", null, global2);
  goog.exportSymbol("TronWebProto.Proposal", null, global2);
  goog.exportSymbol("TronWebProto.Proposal.State", null, global2);
  goog.exportSymbol("TronWebProto.Transaction", null, global2);
  goog.exportSymbol("TronWebProto.Transaction.Contract", null, global2);
  goog.exportSymbol("TronWebProto.Transaction.Contract.ContractType", null, global2);
  goog.exportSymbol("TronWebProto.Transaction.Result", null, global2);
  goog.exportSymbol("TronWebProto.Transaction.Result.code", null, global2);
  goog.exportSymbol("TronWebProto.Transaction.Result.contractResult", null, global2);
  goog.exportSymbol("TronWebProto.Transaction.raw", null, global2);
  goog.exportSymbol("TronWebProto.Vote", null, global2);
  goog.exportSymbol("TronWebProto.Votes", null, global2);
  goog.exportSymbol("TronWebProto.Witness", null, global2);
  goog.exportSymbol("TronWebProto.authority", null, global2);
  TronWebProto.AccountId = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AccountId, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountId.displayName = "TronWebProto.AccountId";
  }
  TronWebProto.Vote = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.Vote, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Vote.displayName = "TronWebProto.Vote";
  }
  TronWebProto.Proposal = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Proposal.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.Proposal, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Proposal.displayName = "TronWebProto.Proposal";
  }
  TronWebProto.Exchange = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.Exchange, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Exchange.displayName = "TronWebProto.Exchange";
  }
  TronWebProto.Account = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Account.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.Account, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Account.displayName = "TronWebProto.Account";
  }
  TronWebProto.Account.Frozen = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.Account.Frozen, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Account.Frozen.displayName = "TronWebProto.Account.Frozen";
  }
  TronWebProto.Account.AccountResource = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.Account.AccountResource, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Account.AccountResource.displayName = "TronWebProto.Account.AccountResource";
  }
  TronWebProto.Key = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.Key, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Key.displayName = "TronWebProto.Key";
  }
  TronWebProto.DelegatedResource = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.DelegatedResource, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.DelegatedResource.displayName = "TronWebProto.DelegatedResource";
  }
  TronWebProto.authority = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.authority, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.authority.displayName = "TronWebProto.authority";
  }
  TronWebProto.Permission = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Permission.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.Permission, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Permission.displayName = "TronWebProto.Permission";
  }
  TronWebProto.Witness = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.Witness, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Witness.displayName = "TronWebProto.Witness";
  }
  TronWebProto.Votes = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Votes.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.Votes, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Votes.displayName = "TronWebProto.Votes";
  }
  TronWebProto.MarketOrderDetail = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.MarketOrderDetail, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.MarketOrderDetail.displayName = "TronWebProto.MarketOrderDetail";
  }
  TronWebProto.Transaction = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Transaction.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.Transaction, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Transaction.displayName = "TronWebProto.Transaction";
  }
  TronWebProto.Transaction.Contract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.Transaction.Contract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Transaction.Contract.displayName = "TronWebProto.Transaction.Contract";
  }
  TronWebProto.Transaction.Result = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Transaction.Result.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.Transaction.Result, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Transaction.Result.displayName = "TronWebProto.Transaction.Result";
  }
  TronWebProto.Transaction.raw = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Transaction.raw.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.Transaction.raw, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.Transaction.raw.displayName = "TronWebProto.Transaction.raw";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountId.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountId.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountId.toObject = function(includeInstance, msg) {
      var obj = {
        name: msg.getName_asB64(),
        address: msg.getAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountId.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountId();
    return TronWebProto.AccountId.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountId.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setName(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountId.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountId.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountId.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
  };
  TronWebProto.AccountId.prototype.getName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.AccountId.prototype.getName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getName()
      )
    );
  };
  TronWebProto.AccountId.prototype.getName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getName()
      )
    );
  };
  TronWebProto.AccountId.prototype.setName = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.AccountId.prototype.getAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.AccountId.prototype.getAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAddress()
      )
    );
  };
  TronWebProto.AccountId.prototype.getAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAddress()
      )
    );
  };
  TronWebProto.AccountId.prototype.setAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Vote.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Vote.toObject(opt_includeInstance, this);
    };
    TronWebProto.Vote.toObject = function(includeInstance, msg) {
      var obj = {
        voteAddress: msg.getVoteAddress_asB64(),
        voteCount: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Vote.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Vote();
    return TronWebProto.Vote.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Vote.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setVoteAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setVoteCount(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Vote.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Vote.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Vote.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getVoteAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getVoteCount();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.Vote.prototype.getVoteAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.Vote.prototype.getVoteAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getVoteAddress()
      )
    );
  };
  TronWebProto.Vote.prototype.getVoteAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getVoteAddress()
      )
    );
  };
  TronWebProto.Vote.prototype.setVoteAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.Vote.prototype.getVoteCount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.Vote.prototype.setVoteCount = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.Proposal.repeatedFields_ = [6];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Proposal.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Proposal.toObject(opt_includeInstance, this);
    };
    TronWebProto.Proposal.toObject = function(includeInstance, msg) {
      var f2, obj = {
        proposalId: jspb.Message.getFieldWithDefault(msg, 1, 0),
        proposerAddress: msg.getProposerAddress_asB64(),
        parametersMap: (f2 = msg.getParametersMap()) ? f2.toObject(includeInstance, void 0) : [],
        expirationTime: jspb.Message.getFieldWithDefault(msg, 4, 0),
        createTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
        approvalsList: msg.getApprovalsList_asB64(),
        state: jspb.Message.getFieldWithDefault(msg, 7, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Proposal.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Proposal();
    return TronWebProto.Proposal.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Proposal.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setProposalId(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setProposerAddress(value);
          break;
        case 3:
          var value = msg.getParametersMap();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readInt64, jspb.BinaryReader.prototype.readInt64, null, 0, 0);
          });
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExpirationTime(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setCreateTime(value);
          break;
        case 6:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.addApprovals(value);
          break;
        case 7:
          var value = (
            /** @type {!TronWebProto.Proposal.State} */
            reader.readEnum()
          );
          msg.setState(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Proposal.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Proposal.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Proposal.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getProposalId();
    if (f2 !== 0) {
      writer.writeInt64(
        1,
        f2
      );
    }
    f2 = message2.getProposerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getParametersMap(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(3, writer, jspb.BinaryWriter.prototype.writeInt64, jspb.BinaryWriter.prototype.writeInt64);
    }
    f2 = message2.getExpirationTime();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getCreateTime();
    if (f2 !== 0) {
      writer.writeInt64(
        5,
        f2
      );
    }
    f2 = message2.getApprovalsList_asU8();
    if (f2.length > 0) {
      writer.writeRepeatedBytes(
        6,
        f2
      );
    }
    f2 = message2.getState();
    if (f2 !== 0) {
      writer.writeEnum(
        7,
        f2
      );
    }
  };
  TronWebProto.Proposal.State = {
    PENDING: 0,
    DISAPPROVED: 1,
    APPROVED: 2,
    CANCELED: 3
  };
  TronWebProto.Proposal.prototype.getProposalId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.Proposal.prototype.setProposalId = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.Proposal.prototype.getProposerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.Proposal.prototype.getProposerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getProposerAddress()
      )
    );
  };
  TronWebProto.Proposal.prototype.getProposerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getProposerAddress()
      )
    );
  };
  TronWebProto.Proposal.prototype.setProposerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.Proposal.prototype.getParametersMap = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<number,number>} */
      jspb.Message.getMapField(
        this,
        3,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.Proposal.prototype.clearParametersMap = function() {
    this.getParametersMap().clear();
    return this;
  };
  TronWebProto.Proposal.prototype.getExpirationTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.Proposal.prototype.setExpirationTime = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.Proposal.prototype.getCreateTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.Proposal.prototype.setCreateTime = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.Proposal.prototype.getApprovalsList = function() {
    return (
      /** @type {!(Array<!Uint8Array>|Array<string>)} */
      jspb.Message.getRepeatedField(this, 6)
    );
  };
  TronWebProto.Proposal.prototype.getApprovalsList_asB64 = function() {
    return (
      /** @type {!Array<string>} */
      jspb.Message.bytesListAsB64(
        this.getApprovalsList()
      )
    );
  };
  TronWebProto.Proposal.prototype.getApprovalsList_asU8 = function() {
    return (
      /** @type {!Array<!Uint8Array>} */
      jspb.Message.bytesListAsU8(
        this.getApprovalsList()
      )
    );
  };
  TronWebProto.Proposal.prototype.setApprovalsList = function(value) {
    return jspb.Message.setField(this, 6, value || []);
  };
  TronWebProto.Proposal.prototype.addApprovals = function(value, opt_index) {
    return jspb.Message.addToRepeatedField(this, 6, value, opt_index);
  };
  TronWebProto.Proposal.prototype.clearApprovalsList = function() {
    return this.setApprovalsList([]);
  };
  TronWebProto.Proposal.prototype.getState = function() {
    return (
      /** @type {!TronWebProto.Proposal.State} */
      jspb.Message.getFieldWithDefault(this, 7, 0)
    );
  };
  TronWebProto.Proposal.prototype.setState = function(value) {
    return jspb.Message.setProto3EnumField(this, 7, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Exchange.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Exchange.toObject(opt_includeInstance, this);
    };
    TronWebProto.Exchange.toObject = function(includeInstance, msg) {
      var obj = {
        exchangeId: jspb.Message.getFieldWithDefault(msg, 1, 0),
        creatorAddress: msg.getCreatorAddress_asB64(),
        createTime: jspb.Message.getFieldWithDefault(msg, 3, 0),
        firstTokenId: msg.getFirstTokenId_asB64(),
        firstTokenBalance: jspb.Message.getFieldWithDefault(msg, 7, 0),
        secondTokenId: msg.getSecondTokenId_asB64(),
        secondTokenBalance: jspb.Message.getFieldWithDefault(msg, 9, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Exchange.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Exchange();
    return TronWebProto.Exchange.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Exchange.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeId(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setCreatorAddress(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setCreateTime(value);
          break;
        case 6:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setFirstTokenId(value);
          break;
        case 7:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFirstTokenBalance(value);
          break;
        case 8:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setSecondTokenId(value);
          break;
        case 9:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setSecondTokenBalance(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Exchange.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Exchange.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Exchange.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getExchangeId();
    if (f2 !== 0) {
      writer.writeInt64(
        1,
        f2
      );
    }
    f2 = message2.getCreatorAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getCreateTime();
    if (f2 !== 0) {
      writer.writeInt64(
        3,
        f2
      );
    }
    f2 = message2.getFirstTokenId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        6,
        f2
      );
    }
    f2 = message2.getFirstTokenBalance();
    if (f2 !== 0) {
      writer.writeInt64(
        7,
        f2
      );
    }
    f2 = message2.getSecondTokenId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        8,
        f2
      );
    }
    f2 = message2.getSecondTokenBalance();
    if (f2 !== 0) {
      writer.writeInt64(
        9,
        f2
      );
    }
  };
  TronWebProto.Exchange.prototype.getExchangeId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.Exchange.prototype.setExchangeId = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.Exchange.prototype.getCreatorAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.Exchange.prototype.getCreatorAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getCreatorAddress()
      )
    );
  };
  TronWebProto.Exchange.prototype.getCreatorAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getCreatorAddress()
      )
    );
  };
  TronWebProto.Exchange.prototype.setCreatorAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.Exchange.prototype.getCreateTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.Exchange.prototype.setCreateTime = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.Exchange.prototype.getFirstTokenId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 6, "")
    );
  };
  TronWebProto.Exchange.prototype.getFirstTokenId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getFirstTokenId()
      )
    );
  };
  TronWebProto.Exchange.prototype.getFirstTokenId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getFirstTokenId()
      )
    );
  };
  TronWebProto.Exchange.prototype.setFirstTokenId = function(value) {
    return jspb.Message.setProto3BytesField(this, 6, value);
  };
  TronWebProto.Exchange.prototype.getFirstTokenBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 7, 0)
    );
  };
  TronWebProto.Exchange.prototype.setFirstTokenBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 7, value);
  };
  TronWebProto.Exchange.prototype.getSecondTokenId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 8, "")
    );
  };
  TronWebProto.Exchange.prototype.getSecondTokenId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getSecondTokenId()
      )
    );
  };
  TronWebProto.Exchange.prototype.getSecondTokenId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getSecondTokenId()
      )
    );
  };
  TronWebProto.Exchange.prototype.setSecondTokenId = function(value) {
    return jspb.Message.setProto3BytesField(this, 8, value);
  };
  TronWebProto.Exchange.prototype.getSecondTokenBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 9, 0)
    );
  };
  TronWebProto.Exchange.prototype.setSecondTokenBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 9, value);
  };
  TronWebProto.Account.repeatedFields_ = [5, 7, 16, 33];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Account.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Account.toObject(opt_includeInstance, this);
    };
    TronWebProto.Account.toObject = function(includeInstance, msg) {
      var f2, obj = {
        accountName: msg.getAccountName_asB64(),
        type: jspb.Message.getFieldWithDefault(msg, 2, 0),
        address: msg.getAddress_asB64(),
        balance: jspb.Message.getFieldWithDefault(msg, 4, 0),
        votesList: jspb.Message.toObjectList(
          msg.getVotesList(),
          TronWebProto.Vote.toObject,
          includeInstance
        ),
        assetMap: (f2 = msg.getAssetMap()) ? f2.toObject(includeInstance, void 0) : [],
        assetv2Map: (f2 = msg.getAssetv2Map()) ? f2.toObject(includeInstance, void 0) : [],
        frozenList: jspb.Message.toObjectList(
          msg.getFrozenList(),
          TronWebProto.Account.Frozen.toObject,
          includeInstance
        ),
        netUsage: jspb.Message.getFieldWithDefault(msg, 8, 0),
        acquiredDelegatedFrozenBalanceForBandwidth: jspb.Message.getFieldWithDefault(msg, 41, 0),
        delegatedFrozenBalanceForBandwidth: jspb.Message.getFieldWithDefault(msg, 42, 0),
        oldTronPower: jspb.Message.getFieldWithDefault(msg, 46, 0),
        tronPower: (f2 = msg.getTronPower()) && TronWebProto.Account.Frozen.toObject(includeInstance, f2),
        assetOptimized: jspb.Message.getBooleanFieldWithDefault(msg, 60, false),
        createTime: jspb.Message.getFieldWithDefault(msg, 9, 0),
        latestOprationTime: jspb.Message.getFieldWithDefault(msg, 10, 0),
        allowance: jspb.Message.getFieldWithDefault(msg, 11, 0),
        latestWithdrawTime: jspb.Message.getFieldWithDefault(msg, 12, 0),
        code: msg.getCode_asB64(),
        isWitness: jspb.Message.getBooleanFieldWithDefault(msg, 14, false),
        isCommittee: jspb.Message.getBooleanFieldWithDefault(msg, 15, false),
        frozenSupplyList: jspb.Message.toObjectList(
          msg.getFrozenSupplyList(),
          TronWebProto.Account.Frozen.toObject,
          includeInstance
        ),
        assetIssuedName: msg.getAssetIssuedName_asB64(),
        assetIssuedId: msg.getAssetIssuedId_asB64(),
        latestAssetOperationTimeMap: (f2 = msg.getLatestAssetOperationTimeMap()) ? f2.toObject(includeInstance, void 0) : [],
        latestAssetOperationTimev2Map: (f2 = msg.getLatestAssetOperationTimev2Map()) ? f2.toObject(includeInstance, void 0) : [],
        freeNetUsage: jspb.Message.getFieldWithDefault(msg, 19, 0),
        freeAssetNetUsageMap: (f2 = msg.getFreeAssetNetUsageMap()) ? f2.toObject(includeInstance, void 0) : [],
        freeAssetNetUsagev2Map: (f2 = msg.getFreeAssetNetUsagev2Map()) ? f2.toObject(includeInstance, void 0) : [],
        latestConsumeTime: jspb.Message.getFieldWithDefault(msg, 21, 0),
        latestConsumeFreeTime: jspb.Message.getFieldWithDefault(msg, 22, 0),
        accountId: msg.getAccountId_asB64(),
        accountResource: (f2 = msg.getAccountResource()) && TronWebProto.Account.AccountResource.toObject(includeInstance, f2),
        codehash: msg.getCodehash_asB64(),
        ownerPermission: (f2 = msg.getOwnerPermission()) && TronWebProto.Permission.toObject(includeInstance, f2),
        witnessPermission: (f2 = msg.getWitnessPermission()) && TronWebProto.Permission.toObject(includeInstance, f2),
        activePermissionList: jspb.Message.toObjectList(
          msg.getActivePermissionList(),
          TronWebProto.Permission.toObject,
          includeInstance
        )
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Account.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Account();
    return TronWebProto.Account.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Account.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAccountName(value);
          break;
        case 2:
          var value = (
            /** @type {!TronWebProto.AccountType} */
            reader.readEnum()
          );
          msg.setType(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAddress(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setBalance(value);
          break;
        case 5:
          var value = new TronWebProto.Vote();
          reader.readMessage(value, TronWebProto.Vote.deserializeBinaryFromReader);
          msg.addVotes(value);
          break;
        case 6:
          var value = msg.getAssetMap();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
          });
          break;
        case 56:
          var value = msg.getAssetv2Map();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
          });
          break;
        case 7:
          var value = new TronWebProto.Account.Frozen();
          reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
          msg.addFrozen(value);
          break;
        case 8:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setNetUsage(value);
          break;
        case 41:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setAcquiredDelegatedFrozenBalanceForBandwidth(value);
          break;
        case 42:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setDelegatedFrozenBalanceForBandwidth(value);
          break;
        case 46:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setOldTronPower(value);
          break;
        case 47:
          var value = new TronWebProto.Account.Frozen();
          reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
          msg.setTronPower(value);
          break;
        case 60:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setAssetOptimized(value);
          break;
        case 9:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setCreateTime(value);
          break;
        case 10:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestOprationTime(value);
          break;
        case 11:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setAllowance(value);
          break;
        case 12:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestWithdrawTime(value);
          break;
        case 13:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setCode(value);
          break;
        case 14:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setIsWitness(value);
          break;
        case 15:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setIsCommittee(value);
          break;
        case 16:
          var value = new TronWebProto.Account.Frozen();
          reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
          msg.addFrozenSupply(value);
          break;
        case 17:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAssetIssuedName(value);
          break;
        case 57:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAssetIssuedId(value);
          break;
        case 18:
          var value = msg.getLatestAssetOperationTimeMap();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
          });
          break;
        case 58:
          var value = msg.getLatestAssetOperationTimev2Map();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
          });
          break;
        case 19:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFreeNetUsage(value);
          break;
        case 20:
          var value = msg.getFreeAssetNetUsageMap();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
          });
          break;
        case 59:
          var value = msg.getFreeAssetNetUsagev2Map();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
          });
          break;
        case 21:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestConsumeTime(value);
          break;
        case 22:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestConsumeFreeTime(value);
          break;
        case 23:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAccountId(value);
          break;
        case 26:
          var value = new TronWebProto.Account.AccountResource();
          reader.readMessage(value, TronWebProto.Account.AccountResource.deserializeBinaryFromReader);
          msg.setAccountResource(value);
          break;
        case 30:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setCodehash(value);
          break;
        case 31:
          var value = new TronWebProto.Permission();
          reader.readMessage(value, TronWebProto.Permission.deserializeBinaryFromReader);
          msg.setOwnerPermission(value);
          break;
        case 32:
          var value = new TronWebProto.Permission();
          reader.readMessage(value, TronWebProto.Permission.deserializeBinaryFromReader);
          msg.setWitnessPermission(value);
          break;
        case 33:
          var value = new TronWebProto.Permission();
          reader.readMessage(value, TronWebProto.Permission.deserializeBinaryFromReader);
          msg.addActivePermission(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Account.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Account.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Account.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAccountName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getType();
    if (f2 !== 0) {
      writer.writeEnum(
        2,
        f2
      );
    }
    f2 = message2.getAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getBalance();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getVotesList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        5,
        f2,
        TronWebProto.Vote.serializeBinaryToWriter
      );
    }
    f2 = message2.getAssetMap(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(6, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
    }
    f2 = message2.getAssetv2Map(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(56, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
    }
    f2 = message2.getFrozenList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        7,
        f2,
        TronWebProto.Account.Frozen.serializeBinaryToWriter
      );
    }
    f2 = message2.getNetUsage();
    if (f2 !== 0) {
      writer.writeInt64(
        8,
        f2
      );
    }
    f2 = message2.getAcquiredDelegatedFrozenBalanceForBandwidth();
    if (f2 !== 0) {
      writer.writeInt64(
        41,
        f2
      );
    }
    f2 = message2.getDelegatedFrozenBalanceForBandwidth();
    if (f2 !== 0) {
      writer.writeInt64(
        42,
        f2
      );
    }
    f2 = message2.getOldTronPower();
    if (f2 !== 0) {
      writer.writeInt64(
        46,
        f2
      );
    }
    f2 = message2.getTronPower();
    if (f2 != null) {
      writer.writeMessage(
        47,
        f2,
        TronWebProto.Account.Frozen.serializeBinaryToWriter
      );
    }
    f2 = message2.getAssetOptimized();
    if (f2) {
      writer.writeBool(
        60,
        f2
      );
    }
    f2 = message2.getCreateTime();
    if (f2 !== 0) {
      writer.writeInt64(
        9,
        f2
      );
    }
    f2 = message2.getLatestOprationTime();
    if (f2 !== 0) {
      writer.writeInt64(
        10,
        f2
      );
    }
    f2 = message2.getAllowance();
    if (f2 !== 0) {
      writer.writeInt64(
        11,
        f2
      );
    }
    f2 = message2.getLatestWithdrawTime();
    if (f2 !== 0) {
      writer.writeInt64(
        12,
        f2
      );
    }
    f2 = message2.getCode_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        13,
        f2
      );
    }
    f2 = message2.getIsWitness();
    if (f2) {
      writer.writeBool(
        14,
        f2
      );
    }
    f2 = message2.getIsCommittee();
    if (f2) {
      writer.writeBool(
        15,
        f2
      );
    }
    f2 = message2.getFrozenSupplyList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        16,
        f2,
        TronWebProto.Account.Frozen.serializeBinaryToWriter
      );
    }
    f2 = message2.getAssetIssuedName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        17,
        f2
      );
    }
    f2 = message2.getAssetIssuedId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        57,
        f2
      );
    }
    f2 = message2.getLatestAssetOperationTimeMap(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(18, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
    }
    f2 = message2.getLatestAssetOperationTimev2Map(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(58, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
    }
    f2 = message2.getFreeNetUsage();
    if (f2 !== 0) {
      writer.writeInt64(
        19,
        f2
      );
    }
    f2 = message2.getFreeAssetNetUsageMap(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(20, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
    }
    f2 = message2.getFreeAssetNetUsagev2Map(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(59, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
    }
    f2 = message2.getLatestConsumeTime();
    if (f2 !== 0) {
      writer.writeInt64(
        21,
        f2
      );
    }
    f2 = message2.getLatestConsumeFreeTime();
    if (f2 !== 0) {
      writer.writeInt64(
        22,
        f2
      );
    }
    f2 = message2.getAccountId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        23,
        f2
      );
    }
    f2 = message2.getAccountResource();
    if (f2 != null) {
      writer.writeMessage(
        26,
        f2,
        TronWebProto.Account.AccountResource.serializeBinaryToWriter
      );
    }
    f2 = message2.getCodehash_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        30,
        f2
      );
    }
    f2 = message2.getOwnerPermission();
    if (f2 != null) {
      writer.writeMessage(
        31,
        f2,
        TronWebProto.Permission.serializeBinaryToWriter
      );
    }
    f2 = message2.getWitnessPermission();
    if (f2 != null) {
      writer.writeMessage(
        32,
        f2,
        TronWebProto.Permission.serializeBinaryToWriter
      );
    }
    f2 = message2.getActivePermissionList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        33,
        f2,
        TronWebProto.Permission.serializeBinaryToWriter
      );
    }
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Account.Frozen.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Account.Frozen.toObject(opt_includeInstance, this);
    };
    TronWebProto.Account.Frozen.toObject = function(includeInstance, msg) {
      var obj = {
        frozenBalance: jspb.Message.getFieldWithDefault(msg, 1, 0),
        expireTime: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Account.Frozen.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Account.Frozen();
    return TronWebProto.Account.Frozen.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Account.Frozen.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenBalance(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExpireTime(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Account.Frozen.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Account.Frozen.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Account.Frozen.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getFrozenBalance();
    if (f2 !== 0) {
      writer.writeInt64(
        1,
        f2
      );
    }
    f2 = message2.getExpireTime();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.Account.Frozen.prototype.getFrozenBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.Account.Frozen.prototype.setFrozenBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.Account.Frozen.prototype.getExpireTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.Account.Frozen.prototype.setExpireTime = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Account.AccountResource.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Account.AccountResource.toObject(opt_includeInstance, this);
    };
    TronWebProto.Account.AccountResource.toObject = function(includeInstance, msg) {
      var f2, obj = {
        energyUsage: jspb.Message.getFieldWithDefault(msg, 1, 0),
        frozenBalanceForEnergy: (f2 = msg.getFrozenBalanceForEnergy()) && TronWebProto.Account.Frozen.toObject(includeInstance, f2),
        latestConsumeTimeForEnergy: jspb.Message.getFieldWithDefault(msg, 3, 0),
        acquiredDelegatedFrozenBalanceForEnergy: jspb.Message.getFieldWithDefault(msg, 4, 0),
        delegatedFrozenBalanceForEnergy: jspb.Message.getFieldWithDefault(msg, 5, 0),
        storageLimit: jspb.Message.getFieldWithDefault(msg, 6, 0),
        storageUsage: jspb.Message.getFieldWithDefault(msg, 7, 0),
        latestExchangeStorageTime: jspb.Message.getFieldWithDefault(msg, 8, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Account.AccountResource.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Account.AccountResource();
    return TronWebProto.Account.AccountResource.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Account.AccountResource.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setEnergyUsage(value);
          break;
        case 2:
          var value = new TronWebProto.Account.Frozen();
          reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
          msg.setFrozenBalanceForEnergy(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestConsumeTimeForEnergy(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setAcquiredDelegatedFrozenBalanceForEnergy(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setDelegatedFrozenBalanceForEnergy(value);
          break;
        case 6:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setStorageLimit(value);
          break;
        case 7:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setStorageUsage(value);
          break;
        case 8:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestExchangeStorageTime(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Account.AccountResource.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Account.AccountResource.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Account.AccountResource.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getEnergyUsage();
    if (f2 !== 0) {
      writer.writeInt64(
        1,
        f2
      );
    }
    f2 = message2.getFrozenBalanceForEnergy();
    if (f2 != null) {
      writer.writeMessage(
        2,
        f2,
        TronWebProto.Account.Frozen.serializeBinaryToWriter
      );
    }
    f2 = message2.getLatestConsumeTimeForEnergy();
    if (f2 !== 0) {
      writer.writeInt64(
        3,
        f2
      );
    }
    f2 = message2.getAcquiredDelegatedFrozenBalanceForEnergy();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getDelegatedFrozenBalanceForEnergy();
    if (f2 !== 0) {
      writer.writeInt64(
        5,
        f2
      );
    }
    f2 = message2.getStorageLimit();
    if (f2 !== 0) {
      writer.writeInt64(
        6,
        f2
      );
    }
    f2 = message2.getStorageUsage();
    if (f2 !== 0) {
      writer.writeInt64(
        7,
        f2
      );
    }
    f2 = message2.getLatestExchangeStorageTime();
    if (f2 !== 0) {
      writer.writeInt64(
        8,
        f2
      );
    }
  };
  TronWebProto.Account.AccountResource.prototype.getEnergyUsage = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setEnergyUsage = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.Account.AccountResource.prototype.getFrozenBalanceForEnergy = function() {
    return (
      /** @type{?TronWebProto.Account.Frozen} */
      jspb.Message.getWrapperField(this, TronWebProto.Account.Frozen, 2)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setFrozenBalanceForEnergy = function(value) {
    return jspb.Message.setWrapperField(this, 2, value);
  };
  TronWebProto.Account.AccountResource.prototype.clearFrozenBalanceForEnergy = function() {
    return this.setFrozenBalanceForEnergy(void 0);
  };
  TronWebProto.Account.AccountResource.prototype.hasFrozenBalanceForEnergy = function() {
    return jspb.Message.getField(this, 2) != null;
  };
  TronWebProto.Account.AccountResource.prototype.getLatestConsumeTimeForEnergy = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setLatestConsumeTimeForEnergy = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.Account.AccountResource.prototype.getAcquiredDelegatedFrozenBalanceForEnergy = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setAcquiredDelegatedFrozenBalanceForEnergy = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.Account.AccountResource.prototype.getDelegatedFrozenBalanceForEnergy = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setDelegatedFrozenBalanceForEnergy = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.Account.AccountResource.prototype.getStorageLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setStorageLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 6, value);
  };
  TronWebProto.Account.AccountResource.prototype.getStorageUsage = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 7, 0)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setStorageUsage = function(value) {
    return jspb.Message.setProto3IntField(this, 7, value);
  };
  TronWebProto.Account.AccountResource.prototype.getLatestExchangeStorageTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 8, 0)
    );
  };
  TronWebProto.Account.AccountResource.prototype.setLatestExchangeStorageTime = function(value) {
    return jspb.Message.setProto3IntField(this, 8, value);
  };
  TronWebProto.Account.prototype.getAccountName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.Account.prototype.getAccountName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAccountName()
      )
    );
  };
  TronWebProto.Account.prototype.getAccountName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAccountName()
      )
    );
  };
  TronWebProto.Account.prototype.setAccountName = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.Account.prototype.getType = function() {
    return (
      /** @type {!TronWebProto.AccountType} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.Account.prototype.setType = function(value) {
    return jspb.Message.setProto3EnumField(this, 2, value);
  };
  TronWebProto.Account.prototype.getAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.Account.prototype.getAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAddress()
      )
    );
  };
  TronWebProto.Account.prototype.getAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAddress()
      )
    );
  };
  TronWebProto.Account.prototype.setAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.Account.prototype.getBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.Account.prototype.setBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.Account.prototype.getVotesList = function() {
    return (
      /** @type{!Array<!TronWebProto.Vote>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 5)
    );
  };
  TronWebProto.Account.prototype.setVotesList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 5, value);
  };
  TronWebProto.Account.prototype.addVotes = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.Vote, opt_index);
  };
  TronWebProto.Account.prototype.clearVotesList = function() {
    return this.setVotesList([]);
  };
  TronWebProto.Account.prototype.getAssetMap = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<string,number>} */
      jspb.Message.getMapField(
        this,
        6,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.Account.prototype.clearAssetMap = function() {
    this.getAssetMap().clear();
    return this;
  };
  TronWebProto.Account.prototype.getAssetv2Map = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<string,number>} */
      jspb.Message.getMapField(
        this,
        56,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.Account.prototype.clearAssetv2Map = function() {
    this.getAssetv2Map().clear();
    return this;
  };
  TronWebProto.Account.prototype.getFrozenList = function() {
    return (
      /** @type{!Array<!TronWebProto.Account.Frozen>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 7)
    );
  };
  TronWebProto.Account.prototype.setFrozenList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 7, value);
  };
  TronWebProto.Account.prototype.addFrozen = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, TronWebProto.Account.Frozen, opt_index);
  };
  TronWebProto.Account.prototype.clearFrozenList = function() {
    return this.setFrozenList([]);
  };
  TronWebProto.Account.prototype.getNetUsage = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 8, 0)
    );
  };
  TronWebProto.Account.prototype.setNetUsage = function(value) {
    return jspb.Message.setProto3IntField(this, 8, value);
  };
  TronWebProto.Account.prototype.getAcquiredDelegatedFrozenBalanceForBandwidth = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 41, 0)
    );
  };
  TronWebProto.Account.prototype.setAcquiredDelegatedFrozenBalanceForBandwidth = function(value) {
    return jspb.Message.setProto3IntField(this, 41, value);
  };
  TronWebProto.Account.prototype.getDelegatedFrozenBalanceForBandwidth = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 42, 0)
    );
  };
  TronWebProto.Account.prototype.setDelegatedFrozenBalanceForBandwidth = function(value) {
    return jspb.Message.setProto3IntField(this, 42, value);
  };
  TronWebProto.Account.prototype.getOldTronPower = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 46, 0)
    );
  };
  TronWebProto.Account.prototype.setOldTronPower = function(value) {
    return jspb.Message.setProto3IntField(this, 46, value);
  };
  TronWebProto.Account.prototype.getTronPower = function() {
    return (
      /** @type{?TronWebProto.Account.Frozen} */
      jspb.Message.getWrapperField(this, TronWebProto.Account.Frozen, 47)
    );
  };
  TronWebProto.Account.prototype.setTronPower = function(value) {
    return jspb.Message.setWrapperField(this, 47, value);
  };
  TronWebProto.Account.prototype.clearTronPower = function() {
    return this.setTronPower(void 0);
  };
  TronWebProto.Account.prototype.hasTronPower = function() {
    return jspb.Message.getField(this, 47) != null;
  };
  TronWebProto.Account.prototype.getAssetOptimized = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 60, false)
    );
  };
  TronWebProto.Account.prototype.setAssetOptimized = function(value) {
    return jspb.Message.setProto3BooleanField(this, 60, value);
  };
  TronWebProto.Account.prototype.getCreateTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 9, 0)
    );
  };
  TronWebProto.Account.prototype.setCreateTime = function(value) {
    return jspb.Message.setProto3IntField(this, 9, value);
  };
  TronWebProto.Account.prototype.getLatestOprationTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 10, 0)
    );
  };
  TronWebProto.Account.prototype.setLatestOprationTime = function(value) {
    return jspb.Message.setProto3IntField(this, 10, value);
  };
  TronWebProto.Account.prototype.getAllowance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 11, 0)
    );
  };
  TronWebProto.Account.prototype.setAllowance = function(value) {
    return jspb.Message.setProto3IntField(this, 11, value);
  };
  TronWebProto.Account.prototype.getLatestWithdrawTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 12, 0)
    );
  };
  TronWebProto.Account.prototype.setLatestWithdrawTime = function(value) {
    return jspb.Message.setProto3IntField(this, 12, value);
  };
  TronWebProto.Account.prototype.getCode = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 13, "")
    );
  };
  TronWebProto.Account.prototype.getCode_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getCode()
      )
    );
  };
  TronWebProto.Account.prototype.getCode_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getCode()
      )
    );
  };
  TronWebProto.Account.prototype.setCode = function(value) {
    return jspb.Message.setProto3BytesField(this, 13, value);
  };
  TronWebProto.Account.prototype.getIsWitness = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 14, false)
    );
  };
  TronWebProto.Account.prototype.setIsWitness = function(value) {
    return jspb.Message.setProto3BooleanField(this, 14, value);
  };
  TronWebProto.Account.prototype.getIsCommittee = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 15, false)
    );
  };
  TronWebProto.Account.prototype.setIsCommittee = function(value) {
    return jspb.Message.setProto3BooleanField(this, 15, value);
  };
  TronWebProto.Account.prototype.getFrozenSupplyList = function() {
    return (
      /** @type{!Array<!TronWebProto.Account.Frozen>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 16)
    );
  };
  TronWebProto.Account.prototype.setFrozenSupplyList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 16, value);
  };
  TronWebProto.Account.prototype.addFrozenSupply = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 16, opt_value, TronWebProto.Account.Frozen, opt_index);
  };
  TronWebProto.Account.prototype.clearFrozenSupplyList = function() {
    return this.setFrozenSupplyList([]);
  };
  TronWebProto.Account.prototype.getAssetIssuedName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 17, "")
    );
  };
  TronWebProto.Account.prototype.getAssetIssuedName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAssetIssuedName()
      )
    );
  };
  TronWebProto.Account.prototype.getAssetIssuedName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAssetIssuedName()
      )
    );
  };
  TronWebProto.Account.prototype.setAssetIssuedName = function(value) {
    return jspb.Message.setProto3BytesField(this, 17, value);
  };
  TronWebProto.Account.prototype.getAssetIssuedId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 57, "")
    );
  };
  TronWebProto.Account.prototype.getAssetIssuedId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAssetIssuedId()
      )
    );
  };
  TronWebProto.Account.prototype.getAssetIssuedId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAssetIssuedId()
      )
    );
  };
  TronWebProto.Account.prototype.setAssetIssuedId = function(value) {
    return jspb.Message.setProto3BytesField(this, 57, value);
  };
  TronWebProto.Account.prototype.getLatestAssetOperationTimeMap = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<string,number>} */
      jspb.Message.getMapField(
        this,
        18,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.Account.prototype.clearLatestAssetOperationTimeMap = function() {
    this.getLatestAssetOperationTimeMap().clear();
    return this;
  };
  TronWebProto.Account.prototype.getLatestAssetOperationTimev2Map = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<string,number>} */
      jspb.Message.getMapField(
        this,
        58,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.Account.prototype.clearLatestAssetOperationTimev2Map = function() {
    this.getLatestAssetOperationTimev2Map().clear();
    return this;
  };
  TronWebProto.Account.prototype.getFreeNetUsage = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 19, 0)
    );
  };
  TronWebProto.Account.prototype.setFreeNetUsage = function(value) {
    return jspb.Message.setProto3IntField(this, 19, value);
  };
  TronWebProto.Account.prototype.getFreeAssetNetUsageMap = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<string,number>} */
      jspb.Message.getMapField(
        this,
        20,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.Account.prototype.clearFreeAssetNetUsageMap = function() {
    this.getFreeAssetNetUsageMap().clear();
    return this;
  };
  TronWebProto.Account.prototype.getFreeAssetNetUsagev2Map = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<string,number>} */
      jspb.Message.getMapField(
        this,
        59,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.Account.prototype.clearFreeAssetNetUsagev2Map = function() {
    this.getFreeAssetNetUsagev2Map().clear();
    return this;
  };
  TronWebProto.Account.prototype.getLatestConsumeTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 21, 0)
    );
  };
  TronWebProto.Account.prototype.setLatestConsumeTime = function(value) {
    return jspb.Message.setProto3IntField(this, 21, value);
  };
  TronWebProto.Account.prototype.getLatestConsumeFreeTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 22, 0)
    );
  };
  TronWebProto.Account.prototype.setLatestConsumeFreeTime = function(value) {
    return jspb.Message.setProto3IntField(this, 22, value);
  };
  TronWebProto.Account.prototype.getAccountId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 23, "")
    );
  };
  TronWebProto.Account.prototype.getAccountId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAccountId()
      )
    );
  };
  TronWebProto.Account.prototype.getAccountId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAccountId()
      )
    );
  };
  TronWebProto.Account.prototype.setAccountId = function(value) {
    return jspb.Message.setProto3BytesField(this, 23, value);
  };
  TronWebProto.Account.prototype.getAccountResource = function() {
    return (
      /** @type{?TronWebProto.Account.AccountResource} */
      jspb.Message.getWrapperField(this, TronWebProto.Account.AccountResource, 26)
    );
  };
  TronWebProto.Account.prototype.setAccountResource = function(value) {
    return jspb.Message.setWrapperField(this, 26, value);
  };
  TronWebProto.Account.prototype.clearAccountResource = function() {
    return this.setAccountResource(void 0);
  };
  TronWebProto.Account.prototype.hasAccountResource = function() {
    return jspb.Message.getField(this, 26) != null;
  };
  TronWebProto.Account.prototype.getCodehash = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 30, "")
    );
  };
  TronWebProto.Account.prototype.getCodehash_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getCodehash()
      )
    );
  };
  TronWebProto.Account.prototype.getCodehash_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getCodehash()
      )
    );
  };
  TronWebProto.Account.prototype.setCodehash = function(value) {
    return jspb.Message.setProto3BytesField(this, 30, value);
  };
  TronWebProto.Account.prototype.getOwnerPermission = function() {
    return (
      /** @type{?TronWebProto.Permission} */
      jspb.Message.getWrapperField(this, TronWebProto.Permission, 31)
    );
  };
  TronWebProto.Account.prototype.setOwnerPermission = function(value) {
    return jspb.Message.setWrapperField(this, 31, value);
  };
  TronWebProto.Account.prototype.clearOwnerPermission = function() {
    return this.setOwnerPermission(void 0);
  };
  TronWebProto.Account.prototype.hasOwnerPermission = function() {
    return jspb.Message.getField(this, 31) != null;
  };
  TronWebProto.Account.prototype.getWitnessPermission = function() {
    return (
      /** @type{?TronWebProto.Permission} */
      jspb.Message.getWrapperField(this, TronWebProto.Permission, 32)
    );
  };
  TronWebProto.Account.prototype.setWitnessPermission = function(value) {
    return jspb.Message.setWrapperField(this, 32, value);
  };
  TronWebProto.Account.prototype.clearWitnessPermission = function() {
    return this.setWitnessPermission(void 0);
  };
  TronWebProto.Account.prototype.hasWitnessPermission = function() {
    return jspb.Message.getField(this, 32) != null;
  };
  TronWebProto.Account.prototype.getActivePermissionList = function() {
    return (
      /** @type{!Array<!TronWebProto.Permission>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Permission, 33)
    );
  };
  TronWebProto.Account.prototype.setActivePermissionList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 33, value);
  };
  TronWebProto.Account.prototype.addActivePermission = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 33, opt_value, TronWebProto.Permission, opt_index);
  };
  TronWebProto.Account.prototype.clearActivePermissionList = function() {
    return this.setActivePermissionList([]);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Key.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Key.toObject(opt_includeInstance, this);
    };
    TronWebProto.Key.toObject = function(includeInstance, msg) {
      var obj = {
        address: msg.getAddress_asB64(),
        weight: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Key.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Key();
    return TronWebProto.Key.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Key.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setWeight(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Key.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Key.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Key.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getWeight();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.Key.prototype.getAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.Key.prototype.getAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAddress()
      )
    );
  };
  TronWebProto.Key.prototype.getAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAddress()
      )
    );
  };
  TronWebProto.Key.prototype.setAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.Key.prototype.getWeight = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.Key.prototype.setWeight = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.DelegatedResource.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.DelegatedResource.toObject(opt_includeInstance, this);
    };
    TronWebProto.DelegatedResource.toObject = function(includeInstance, msg) {
      var obj = {
        from: msg.getFrom_asB64(),
        to: msg.getTo_asB64(),
        frozenBalanceForBandwidth: jspb.Message.getFieldWithDefault(msg, 3, 0),
        frozenBalanceForEnergy: jspb.Message.getFieldWithDefault(msg, 4, 0),
        expireTimeForBandwidth: jspb.Message.getFieldWithDefault(msg, 5, 0),
        expireTimeForEnergy: jspb.Message.getFieldWithDefault(msg, 6, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.DelegatedResource.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.DelegatedResource();
    return TronWebProto.DelegatedResource.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.DelegatedResource.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setFrom(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setTo(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenBalanceForBandwidth(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenBalanceForEnergy(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExpireTimeForBandwidth(value);
          break;
        case 6:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExpireTimeForEnergy(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.DelegatedResource.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.DelegatedResource.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.DelegatedResource.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getFrom_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getTo_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getFrozenBalanceForBandwidth();
    if (f2 !== 0) {
      writer.writeInt64(
        3,
        f2
      );
    }
    f2 = message2.getFrozenBalanceForEnergy();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getExpireTimeForBandwidth();
    if (f2 !== 0) {
      writer.writeInt64(
        5,
        f2
      );
    }
    f2 = message2.getExpireTimeForEnergy();
    if (f2 !== 0) {
      writer.writeInt64(
        6,
        f2
      );
    }
  };
  TronWebProto.DelegatedResource.prototype.getFrom = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.DelegatedResource.prototype.getFrom_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getFrom()
      )
    );
  };
  TronWebProto.DelegatedResource.prototype.getFrom_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getFrom()
      )
    );
  };
  TronWebProto.DelegatedResource.prototype.setFrom = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.DelegatedResource.prototype.getTo = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.DelegatedResource.prototype.getTo_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getTo()
      )
    );
  };
  TronWebProto.DelegatedResource.prototype.getTo_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getTo()
      )
    );
  };
  TronWebProto.DelegatedResource.prototype.setTo = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.DelegatedResource.prototype.getFrozenBalanceForBandwidth = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.DelegatedResource.prototype.setFrozenBalanceForBandwidth = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.DelegatedResource.prototype.getFrozenBalanceForEnergy = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.DelegatedResource.prototype.setFrozenBalanceForEnergy = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.DelegatedResource.prototype.getExpireTimeForBandwidth = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.DelegatedResource.prototype.setExpireTimeForBandwidth = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.DelegatedResource.prototype.getExpireTimeForEnergy = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.DelegatedResource.prototype.setExpireTimeForEnergy = function(value) {
    return jspb.Message.setProto3IntField(this, 6, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.authority.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.authority.toObject(opt_includeInstance, this);
    };
    TronWebProto.authority.toObject = function(includeInstance, msg) {
      var f2, obj = {
        account: (f2 = msg.getAccount()) && TronWebProto.AccountId.toObject(includeInstance, f2),
        permissionName: msg.getPermissionName_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.authority.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.authority();
    return TronWebProto.authority.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.authority.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = new TronWebProto.AccountId();
          reader.readMessage(value, TronWebProto.AccountId.deserializeBinaryFromReader);
          msg.setAccount(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setPermissionName(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.authority.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.authority.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.authority.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAccount();
    if (f2 != null) {
      writer.writeMessage(
        1,
        f2,
        TronWebProto.AccountId.serializeBinaryToWriter
      );
    }
    f2 = message2.getPermissionName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
  };
  TronWebProto.authority.prototype.getAccount = function() {
    return (
      /** @type{?TronWebProto.AccountId} */
      jspb.Message.getWrapperField(this, TronWebProto.AccountId, 1)
    );
  };
  TronWebProto.authority.prototype.setAccount = function(value) {
    return jspb.Message.setWrapperField(this, 1, value);
  };
  TronWebProto.authority.prototype.clearAccount = function() {
    return this.setAccount(void 0);
  };
  TronWebProto.authority.prototype.hasAccount = function() {
    return jspb.Message.getField(this, 1) != null;
  };
  TronWebProto.authority.prototype.getPermissionName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.authority.prototype.getPermissionName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getPermissionName()
      )
    );
  };
  TronWebProto.authority.prototype.getPermissionName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getPermissionName()
      )
    );
  };
  TronWebProto.authority.prototype.setPermissionName = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.Permission.repeatedFields_ = [7];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Permission.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Permission.toObject(opt_includeInstance, this);
    };
    TronWebProto.Permission.toObject = function(includeInstance, msg) {
      var obj = {
        type: jspb.Message.getFieldWithDefault(msg, 1, 0),
        id: jspb.Message.getFieldWithDefault(msg, 2, 0),
        permissionName: jspb.Message.getFieldWithDefault(msg, 3, ""),
        threshold: jspb.Message.getFieldWithDefault(msg, 4, 0),
        parentId: jspb.Message.getFieldWithDefault(msg, 5, 0),
        operations: msg.getOperations_asB64(),
        keysList: jspb.Message.toObjectList(
          msg.getKeysList(),
          TronWebProto.Key.toObject,
          includeInstance
        )
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Permission.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Permission();
    return TronWebProto.Permission.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Permission.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!TronWebProto.Permission.PermissionType} */
            reader.readEnum()
          );
          msg.setType(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setId(value);
          break;
        case 3:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setPermissionName(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setThreshold(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setParentId(value);
          break;
        case 6:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOperations(value);
          break;
        case 7:
          var value = new TronWebProto.Key();
          reader.readMessage(value, TronWebProto.Key.deserializeBinaryFromReader);
          msg.addKeys(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Permission.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Permission.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Permission.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getType();
    if (f2 !== 0) {
      writer.writeEnum(
        1,
        f2
      );
    }
    f2 = message2.getId();
    if (f2 !== 0) {
      writer.writeInt32(
        2,
        f2
      );
    }
    f2 = message2.getPermissionName();
    if (f2.length > 0) {
      writer.writeString(
        3,
        f2
      );
    }
    f2 = message2.getThreshold();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getParentId();
    if (f2 !== 0) {
      writer.writeInt32(
        5,
        f2
      );
    }
    f2 = message2.getOperations_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        6,
        f2
      );
    }
    f2 = message2.getKeysList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        7,
        f2,
        TronWebProto.Key.serializeBinaryToWriter
      );
    }
  };
  TronWebProto.Permission.PermissionType = {
    OWNER: 0,
    WITNESS: 1,
    ACTIVE: 2
  };
  TronWebProto.Permission.prototype.getType = function() {
    return (
      /** @type {!TronWebProto.Permission.PermissionType} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.Permission.prototype.setType = function(value) {
    return jspb.Message.setProto3EnumField(this, 1, value);
  };
  TronWebProto.Permission.prototype.getId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.Permission.prototype.setId = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.Permission.prototype.getPermissionName = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.Permission.prototype.setPermissionName = function(value) {
    return jspb.Message.setProto3StringField(this, 3, value);
  };
  TronWebProto.Permission.prototype.getThreshold = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.Permission.prototype.setThreshold = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.Permission.prototype.getParentId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.Permission.prototype.setParentId = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.Permission.prototype.getOperations = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 6, "")
    );
  };
  TronWebProto.Permission.prototype.getOperations_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOperations()
      )
    );
  };
  TronWebProto.Permission.prototype.getOperations_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOperations()
      )
    );
  };
  TronWebProto.Permission.prototype.setOperations = function(value) {
    return jspb.Message.setProto3BytesField(this, 6, value);
  };
  TronWebProto.Permission.prototype.getKeysList = function() {
    return (
      /** @type{!Array<!TronWebProto.Key>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Key, 7)
    );
  };
  TronWebProto.Permission.prototype.setKeysList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 7, value);
  };
  TronWebProto.Permission.prototype.addKeys = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, TronWebProto.Key, opt_index);
  };
  TronWebProto.Permission.prototype.clearKeysList = function() {
    return this.setKeysList([]);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Witness.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Witness.toObject(opt_includeInstance, this);
    };
    TronWebProto.Witness.toObject = function(includeInstance, msg) {
      var obj = {
        address: msg.getAddress_asB64(),
        votecount: jspb.Message.getFieldWithDefault(msg, 2, 0),
        pubkey: msg.getPubkey_asB64(),
        url: jspb.Message.getFieldWithDefault(msg, 4, ""),
        totalproduced: jspb.Message.getFieldWithDefault(msg, 5, 0),
        totalmissed: jspb.Message.getFieldWithDefault(msg, 6, 0),
        latestblocknum: jspb.Message.getFieldWithDefault(msg, 7, 0),
        latestslotnum: jspb.Message.getFieldWithDefault(msg, 8, 0),
        isjobs: jspb.Message.getBooleanFieldWithDefault(msg, 9, false)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Witness.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Witness();
    return TronWebProto.Witness.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Witness.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setVotecount(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setPubkey(value);
          break;
        case 4:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setUrl(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setTotalproduced(value);
          break;
        case 6:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setTotalmissed(value);
          break;
        case 7:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestblocknum(value);
          break;
        case 8:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLatestslotnum(value);
          break;
        case 9:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setIsjobs(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Witness.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Witness.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Witness.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getVotecount();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
    f2 = message2.getPubkey_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getUrl();
    if (f2.length > 0) {
      writer.writeString(
        4,
        f2
      );
    }
    f2 = message2.getTotalproduced();
    if (f2 !== 0) {
      writer.writeInt64(
        5,
        f2
      );
    }
    f2 = message2.getTotalmissed();
    if (f2 !== 0) {
      writer.writeInt64(
        6,
        f2
      );
    }
    f2 = message2.getLatestblocknum();
    if (f2 !== 0) {
      writer.writeInt64(
        7,
        f2
      );
    }
    f2 = message2.getLatestslotnum();
    if (f2 !== 0) {
      writer.writeInt64(
        8,
        f2
      );
    }
    f2 = message2.getIsjobs();
    if (f2) {
      writer.writeBool(
        9,
        f2
      );
    }
  };
  TronWebProto.Witness.prototype.getAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.Witness.prototype.getAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAddress()
      )
    );
  };
  TronWebProto.Witness.prototype.getAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAddress()
      )
    );
  };
  TronWebProto.Witness.prototype.setAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.Witness.prototype.getVotecount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.Witness.prototype.setVotecount = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.Witness.prototype.getPubkey = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.Witness.prototype.getPubkey_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getPubkey()
      )
    );
  };
  TronWebProto.Witness.prototype.getPubkey_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getPubkey()
      )
    );
  };
  TronWebProto.Witness.prototype.setPubkey = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.Witness.prototype.getUrl = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.Witness.prototype.setUrl = function(value) {
    return jspb.Message.setProto3StringField(this, 4, value);
  };
  TronWebProto.Witness.prototype.getTotalproduced = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.Witness.prototype.setTotalproduced = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.Witness.prototype.getTotalmissed = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.Witness.prototype.setTotalmissed = function(value) {
    return jspb.Message.setProto3IntField(this, 6, value);
  };
  TronWebProto.Witness.prototype.getLatestblocknum = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 7, 0)
    );
  };
  TronWebProto.Witness.prototype.setLatestblocknum = function(value) {
    return jspb.Message.setProto3IntField(this, 7, value);
  };
  TronWebProto.Witness.prototype.getLatestslotnum = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 8, 0)
    );
  };
  TronWebProto.Witness.prototype.setLatestslotnum = function(value) {
    return jspb.Message.setProto3IntField(this, 8, value);
  };
  TronWebProto.Witness.prototype.getIsjobs = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 9, false)
    );
  };
  TronWebProto.Witness.prototype.setIsjobs = function(value) {
    return jspb.Message.setProto3BooleanField(this, 9, value);
  };
  TronWebProto.Votes.repeatedFields_ = [2, 3];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Votes.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Votes.toObject(opt_includeInstance, this);
    };
    TronWebProto.Votes.toObject = function(includeInstance, msg) {
      var obj = {
        address: msg.getAddress_asB64(),
        oldVotesList: jspb.Message.toObjectList(
          msg.getOldVotesList(),
          TronWebProto.Vote.toObject,
          includeInstance
        ),
        newVotesList: jspb.Message.toObjectList(
          msg.getNewVotesList(),
          TronWebProto.Vote.toObject,
          includeInstance
        )
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Votes.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Votes();
    return TronWebProto.Votes.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Votes.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAddress(value);
          break;
        case 2:
          var value = new TronWebProto.Vote();
          reader.readMessage(value, TronWebProto.Vote.deserializeBinaryFromReader);
          msg.addOldVotes(value);
          break;
        case 3:
          var value = new TronWebProto.Vote();
          reader.readMessage(value, TronWebProto.Vote.deserializeBinaryFromReader);
          msg.addNewVotes(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Votes.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Votes.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Votes.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getOldVotesList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        2,
        f2,
        TronWebProto.Vote.serializeBinaryToWriter
      );
    }
    f2 = message2.getNewVotesList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        3,
        f2,
        TronWebProto.Vote.serializeBinaryToWriter
      );
    }
  };
  TronWebProto.Votes.prototype.getAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.Votes.prototype.getAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAddress()
      )
    );
  };
  TronWebProto.Votes.prototype.getAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAddress()
      )
    );
  };
  TronWebProto.Votes.prototype.setAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.Votes.prototype.getOldVotesList = function() {
    return (
      /** @type{!Array<!TronWebProto.Vote>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 2)
    );
  };
  TronWebProto.Votes.prototype.setOldVotesList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 2, value);
  };
  TronWebProto.Votes.prototype.addOldVotes = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, TronWebProto.Vote, opt_index);
  };
  TronWebProto.Votes.prototype.clearOldVotesList = function() {
    return this.setOldVotesList([]);
  };
  TronWebProto.Votes.prototype.getNewVotesList = function() {
    return (
      /** @type{!Array<!TronWebProto.Vote>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 3)
    );
  };
  TronWebProto.Votes.prototype.setNewVotesList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 3, value);
  };
  TronWebProto.Votes.prototype.addNewVotes = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, TronWebProto.Vote, opt_index);
  };
  TronWebProto.Votes.prototype.clearNewVotesList = function() {
    return this.setNewVotesList([]);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.MarketOrderDetail.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.MarketOrderDetail.toObject(opt_includeInstance, this);
    };
    TronWebProto.MarketOrderDetail.toObject = function(includeInstance, msg) {
      var obj = {
        makerorderid: msg.getMakerorderid_asB64(),
        takerorderid: msg.getTakerorderid_asB64(),
        fillsellquantity: jspb.Message.getFieldWithDefault(msg, 3, 0),
        fillbuyquantity: jspb.Message.getFieldWithDefault(msg, 4, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.MarketOrderDetail.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.MarketOrderDetail();
    return TronWebProto.MarketOrderDetail.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.MarketOrderDetail.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setMakerorderid(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setTakerorderid(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFillsellquantity(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFillbuyquantity(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.MarketOrderDetail.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.MarketOrderDetail.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.MarketOrderDetail.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getMakerorderid_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getTakerorderid_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getFillsellquantity();
    if (f2 !== 0) {
      writer.writeInt64(
        3,
        f2
      );
    }
    f2 = message2.getFillbuyquantity();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
  };
  TronWebProto.MarketOrderDetail.prototype.getMakerorderid = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getMakerorderid()
      )
    );
  };
  TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getMakerorderid()
      )
    );
  };
  TronWebProto.MarketOrderDetail.prototype.setMakerorderid = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.MarketOrderDetail.prototype.getTakerorderid = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getTakerorderid()
      )
    );
  };
  TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getTakerorderid()
      )
    );
  };
  TronWebProto.MarketOrderDetail.prototype.setTakerorderid = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.MarketOrderDetail.prototype.getFillsellquantity = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.MarketOrderDetail.prototype.setFillsellquantity = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.MarketOrderDetail.prototype.getFillbuyquantity = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.MarketOrderDetail.prototype.setFillbuyquantity = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.Transaction.repeatedFields_ = [2, 5];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Transaction.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Transaction.toObject(opt_includeInstance, this);
    };
    TronWebProto.Transaction.toObject = function(includeInstance, msg) {
      var f2, obj = {
        rawData: (f2 = msg.getRawData()) && TronWebProto.Transaction.raw.toObject(includeInstance, f2),
        signatureList: msg.getSignatureList_asB64(),
        retList: jspb.Message.toObjectList(
          msg.getRetList(),
          TronWebProto.Transaction.Result.toObject,
          includeInstance
        )
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Transaction.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Transaction();
    return TronWebProto.Transaction.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Transaction.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = new TronWebProto.Transaction.raw();
          reader.readMessage(value, TronWebProto.Transaction.raw.deserializeBinaryFromReader);
          msg.setRawData(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.addSignature(value);
          break;
        case 5:
          var value = new TronWebProto.Transaction.Result();
          reader.readMessage(value, TronWebProto.Transaction.Result.deserializeBinaryFromReader);
          msg.addRet(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Transaction.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Transaction.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Transaction.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getRawData();
    if (f2 != null) {
      writer.writeMessage(
        1,
        f2,
        TronWebProto.Transaction.raw.serializeBinaryToWriter
      );
    }
    f2 = message2.getSignatureList_asU8();
    if (f2.length > 0) {
      writer.writeRepeatedBytes(
        2,
        f2
      );
    }
    f2 = message2.getRetList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        5,
        f2,
        TronWebProto.Transaction.Result.serializeBinaryToWriter
      );
    }
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Transaction.Contract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Transaction.Contract.toObject(opt_includeInstance, this);
    };
    TronWebProto.Transaction.Contract.toObject = function(includeInstance, msg) {
      var f2, obj = {
        type: jspb.Message.getFieldWithDefault(msg, 1, 0),
        parameter: (f2 = msg.getParameter()) && google_protobuf_any_pb2.Any.toObject(includeInstance, f2),
        provider: msg.getProvider_asB64(),
        contractname: msg.getContractname_asB64(),
        permissionId: jspb.Message.getFieldWithDefault(msg, 5, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Transaction.Contract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Transaction.Contract();
    return TronWebProto.Transaction.Contract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Transaction.Contract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!TronWebProto.Transaction.Contract.ContractType} */
            reader.readEnum()
          );
          msg.setType(value);
          break;
        case 2:
          var value = new google_protobuf_any_pb2.Any();
          reader.readMessage(value, google_protobuf_any_pb2.Any.deserializeBinaryFromReader);
          msg.setParameter(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setProvider(value);
          break;
        case 4:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setContractname(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setPermissionId(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Transaction.Contract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Transaction.Contract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Transaction.Contract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getType();
    if (f2 !== 0) {
      writer.writeEnum(
        1,
        f2
      );
    }
    f2 = message2.getParameter();
    if (f2 != null) {
      writer.writeMessage(
        2,
        f2,
        google_protobuf_any_pb2.Any.serializeBinaryToWriter
      );
    }
    f2 = message2.getProvider_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getContractname_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        4,
        f2
      );
    }
    f2 = message2.getPermissionId();
    if (f2 !== 0) {
      writer.writeInt32(
        5,
        f2
      );
    }
  };
  TronWebProto.Transaction.Contract.ContractType = {
    ACCOUNTCREATECONTRACT: 0,
    TRANSFERCONTRACT: 1,
    TRANSFERASSETCONTRACT: 2,
    VOTEASSETCONTRACT: 3,
    VOTEWITNESSCONTRACT: 4,
    WITNESSCREATECONTRACT: 5,
    ASSETISSUECONTRACT: 6,
    WITNESSUPDATECONTRACT: 8,
    PARTICIPATEASSETISSUECONTRACT: 9,
    ACCOUNTUPDATECONTRACT: 10,
    FREEZEBALANCECONTRACT: 11,
    UNFREEZEBALANCECONTRACT: 12,
    WITHDRAWBALANCECONTRACT: 13,
    UNFREEZEASSETCONTRACT: 14,
    UPDATEASSETCONTRACT: 15,
    PROPOSALCREATECONTRACT: 16,
    PROPOSALAPPROVECONTRACT: 17,
    PROPOSALDELETECONTRACT: 18,
    SETACCOUNTIDCONTRACT: 19,
    CUSTOMCONTRACT: 20,
    CREATESMARTCONTRACT: 30,
    TRIGGERSMARTCONTRACT: 31,
    GETCONTRACT: 32,
    UPDATESETTINGCONTRACT: 33,
    EXCHANGECREATECONTRACT: 41,
    EXCHANGEINJECTCONTRACT: 42,
    EXCHANGEWITHDRAWCONTRACT: 43,
    EXCHANGETRANSACTIONCONTRACT: 44,
    UPDATEENERGYLIMITCONTRACT: 45,
    ACCOUNTPERMISSIONUPDATECONTRACT: 46,
    CLEARABICONTRACT: 48,
    UPDATEBROKERAGECONTRACT: 49,
    SHIELDEDTRANSFERCONTRACT: 51,
    MARKETSELLASSETCONTRACT: 52,
    MARKETCANCELORDERCONTRACT: 53,
    FREEZEBALANCEV2CONTRACT: 54,
    UNFREEZEBALANCEV2CONTRACT: 55,
    WITHDRAWEXPIREUNFREEZECONTRACT: 56,
    DELEGATERESOURCECONTRACT: 57,
    UNDELEGATERESOURCECONTRACT: 58,
    CANCELALLUNFREEZEV2CONTRACT: 59
  };
  TronWebProto.Transaction.Contract.prototype.getType = function() {
    return (
      /** @type {!TronWebProto.Transaction.Contract.ContractType} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.Transaction.Contract.prototype.setType = function(value) {
    return jspb.Message.setProto3EnumField(this, 1, value);
  };
  TronWebProto.Transaction.Contract.prototype.getParameter = function() {
    return (
      /** @type{?TronWebProto.Any} */
      jspb.Message.getWrapperField(this, google_protobuf_any_pb2.Any, 2)
    );
  };
  TronWebProto.Transaction.Contract.prototype.setParameter = function(value) {
    return jspb.Message.setWrapperField(this, 2, value);
  };
  TronWebProto.Transaction.Contract.prototype.clearParameter = function() {
    return this.setParameter(void 0);
  };
  TronWebProto.Transaction.Contract.prototype.hasParameter = function() {
    return jspb.Message.getField(this, 2) != null;
  };
  TronWebProto.Transaction.Contract.prototype.getProvider = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.Transaction.Contract.prototype.getProvider_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getProvider()
      )
    );
  };
  TronWebProto.Transaction.Contract.prototype.getProvider_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getProvider()
      )
    );
  };
  TronWebProto.Transaction.Contract.prototype.setProvider = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.Transaction.Contract.prototype.getContractname = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.Transaction.Contract.prototype.getContractname_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getContractname()
      )
    );
  };
  TronWebProto.Transaction.Contract.prototype.getContractname_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getContractname()
      )
    );
  };
  TronWebProto.Transaction.Contract.prototype.setContractname = function(value) {
    return jspb.Message.setProto3BytesField(this, 4, value);
  };
  TronWebProto.Transaction.Contract.prototype.getPermissionId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.Transaction.Contract.prototype.setPermissionId = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.Transaction.Result.repeatedFields_ = [26];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Transaction.Result.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Transaction.Result.toObject(opt_includeInstance, this);
    };
    TronWebProto.Transaction.Result.toObject = function(includeInstance, msg) {
      var obj = {
        fee: jspb.Message.getFieldWithDefault(msg, 1, 0),
        ret: jspb.Message.getFieldWithDefault(msg, 2, 0),
        contractret: jspb.Message.getFieldWithDefault(msg, 3, 0),
        assetissueid: jspb.Message.getFieldWithDefault(msg, 14, ""),
        withdrawAmount: jspb.Message.getFieldWithDefault(msg, 15, 0),
        unfreezeAmount: jspb.Message.getFieldWithDefault(msg, 16, 0),
        exchangeReceivedAmount: jspb.Message.getFieldWithDefault(msg, 18, 0),
        exchangeInjectAnotherAmount: jspb.Message.getFieldWithDefault(msg, 19, 0),
        exchangeWithdrawAnotherAmount: jspb.Message.getFieldWithDefault(msg, 20, 0),
        exchangeId: jspb.Message.getFieldWithDefault(msg, 21, 0),
        shieldedTransactionFee: jspb.Message.getFieldWithDefault(msg, 22, 0),
        orderid: msg.getOrderid_asB64(),
        orderdetailsList: jspb.Message.toObjectList(
          msg.getOrderdetailsList(),
          TronWebProto.MarketOrderDetail.toObject,
          includeInstance
        )
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Transaction.Result.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Transaction.Result();
    return TronWebProto.Transaction.Result.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Transaction.Result.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFee(value);
          break;
        case 2:
          var value = (
            /** @type {!TronWebProto.Transaction.Result.code} */
            reader.readEnum()
          );
          msg.setRet(value);
          break;
        case 3:
          var value = (
            /** @type {!TronWebProto.Transaction.Result.contractResult} */
            reader.readEnum()
          );
          msg.setContractret(value);
          break;
        case 14:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setAssetissueid(value);
          break;
        case 15:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setWithdrawAmount(value);
          break;
        case 16:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setUnfreezeAmount(value);
          break;
        case 18:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeReceivedAmount(value);
          break;
        case 19:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeInjectAnotherAmount(value);
          break;
        case 20:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeWithdrawAnotherAmount(value);
          break;
        case 21:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeId(value);
          break;
        case 22:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setShieldedTransactionFee(value);
          break;
        case 25:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOrderid(value);
          break;
        case 26:
          var value = new TronWebProto.MarketOrderDetail();
          reader.readMessage(value, TronWebProto.MarketOrderDetail.deserializeBinaryFromReader);
          msg.addOrderdetails(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Transaction.Result.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Transaction.Result.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Transaction.Result.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getFee();
    if (f2 !== 0) {
      writer.writeInt64(
        1,
        f2
      );
    }
    f2 = message2.getRet();
    if (f2 !== 0) {
      writer.writeEnum(
        2,
        f2
      );
    }
    f2 = message2.getContractret();
    if (f2 !== 0) {
      writer.writeEnum(
        3,
        f2
      );
    }
    f2 = message2.getAssetissueid();
    if (f2.length > 0) {
      writer.writeString(
        14,
        f2
      );
    }
    f2 = message2.getWithdrawAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        15,
        f2
      );
    }
    f2 = message2.getUnfreezeAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        16,
        f2
      );
    }
    f2 = message2.getExchangeReceivedAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        18,
        f2
      );
    }
    f2 = message2.getExchangeInjectAnotherAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        19,
        f2
      );
    }
    f2 = message2.getExchangeWithdrawAnotherAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        20,
        f2
      );
    }
    f2 = message2.getExchangeId();
    if (f2 !== 0) {
      writer.writeInt64(
        21,
        f2
      );
    }
    f2 = message2.getShieldedTransactionFee();
    if (f2 !== 0) {
      writer.writeInt64(
        22,
        f2
      );
    }
    f2 = message2.getOrderid_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        25,
        f2
      );
    }
    f2 = message2.getOrderdetailsList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        26,
        f2,
        TronWebProto.MarketOrderDetail.serializeBinaryToWriter
      );
    }
  };
  TronWebProto.Transaction.Result.code = {
    SUCESS: 0,
    FAILED: 1
  };
  TronWebProto.Transaction.Result.contractResult = {
    DEFAULT: 0,
    SUCCESS: 1,
    REVERT: 2,
    BAD_JUMP_DESTINATION: 3,
    OUT_OF_MEMORY: 4,
    PRECOMPILED_CONTRACT: 5,
    STACK_TOO_SMALL: 6,
    STACK_TOO_LARGE: 7,
    ILLEGAL_OPERATION: 8,
    STACK_OVERFLOW: 9,
    OUT_OF_ENERGY: 10,
    OUT_OF_TIME: 11,
    JVM_STACK_OVER_FLOW: 12,
    UNKNOWN: 13,
    TRANSFER_FAILED: 14,
    INVALID_CODE: 15
  };
  TronWebProto.Transaction.Result.prototype.getFee = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setFee = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.Transaction.Result.prototype.getRet = function() {
    return (
      /** @type {!TronWebProto.Transaction.Result.code} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setRet = function(value) {
    return jspb.Message.setProto3EnumField(this, 2, value);
  };
  TronWebProto.Transaction.Result.prototype.getContractret = function() {
    return (
      /** @type {!TronWebProto.Transaction.Result.contractResult} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setContractret = function(value) {
    return jspb.Message.setProto3EnumField(this, 3, value);
  };
  TronWebProto.Transaction.Result.prototype.getAssetissueid = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 14, "")
    );
  };
  TronWebProto.Transaction.Result.prototype.setAssetissueid = function(value) {
    return jspb.Message.setProto3StringField(this, 14, value);
  };
  TronWebProto.Transaction.Result.prototype.getWithdrawAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 15, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setWithdrawAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 15, value);
  };
  TronWebProto.Transaction.Result.prototype.getUnfreezeAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 16, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setUnfreezeAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 16, value);
  };
  TronWebProto.Transaction.Result.prototype.getExchangeReceivedAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 18, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setExchangeReceivedAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 18, value);
  };
  TronWebProto.Transaction.Result.prototype.getExchangeInjectAnotherAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 19, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setExchangeInjectAnotherAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 19, value);
  };
  TronWebProto.Transaction.Result.prototype.getExchangeWithdrawAnotherAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 20, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setExchangeWithdrawAnotherAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 20, value);
  };
  TronWebProto.Transaction.Result.prototype.getExchangeId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 21, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setExchangeId = function(value) {
    return jspb.Message.setProto3IntField(this, 21, value);
  };
  TronWebProto.Transaction.Result.prototype.getShieldedTransactionFee = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 22, 0)
    );
  };
  TronWebProto.Transaction.Result.prototype.setShieldedTransactionFee = function(value) {
    return jspb.Message.setProto3IntField(this, 22, value);
  };
  TronWebProto.Transaction.Result.prototype.getOrderid = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 25, "")
    );
  };
  TronWebProto.Transaction.Result.prototype.getOrderid_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOrderid()
      )
    );
  };
  TronWebProto.Transaction.Result.prototype.getOrderid_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOrderid()
      )
    );
  };
  TronWebProto.Transaction.Result.prototype.setOrderid = function(value) {
    return jspb.Message.setProto3BytesField(this, 25, value);
  };
  TronWebProto.Transaction.Result.prototype.getOrderdetailsList = function() {
    return (
      /** @type{!Array<!TronWebProto.MarketOrderDetail>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.MarketOrderDetail, 26)
    );
  };
  TronWebProto.Transaction.Result.prototype.setOrderdetailsList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 26, value);
  };
  TronWebProto.Transaction.Result.prototype.addOrderdetails = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 26, opt_value, TronWebProto.MarketOrderDetail, opt_index);
  };
  TronWebProto.Transaction.Result.prototype.clearOrderdetailsList = function() {
    return this.setOrderdetailsList([]);
  };
  TronWebProto.Transaction.raw.repeatedFields_ = [9, 11];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.Transaction.raw.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.Transaction.raw.toObject(opt_includeInstance, this);
    };
    TronWebProto.Transaction.raw.toObject = function(includeInstance, msg) {
      var obj = {
        refBlockBytes: msg.getRefBlockBytes_asB64(),
        refBlockNum: jspb.Message.getFieldWithDefault(msg, 3, 0),
        refBlockHash: msg.getRefBlockHash_asB64(),
        expiration: jspb.Message.getFieldWithDefault(msg, 8, 0),
        authsList: jspb.Message.toObjectList(
          msg.getAuthsList(),
          TronWebProto.authority.toObject,
          includeInstance
        ),
        data: msg.getData_asB64(),
        contractList: jspb.Message.toObjectList(
          msg.getContractList(),
          TronWebProto.Transaction.Contract.toObject,
          includeInstance
        ),
        scripts: msg.getScripts_asB64(),
        timestamp: jspb.Message.getFieldWithDefault(msg, 14, 0),
        feeLimit: jspb.Message.getFieldWithDefault(msg, 18, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.Transaction.raw.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.Transaction.raw();
    return TronWebProto.Transaction.raw.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.Transaction.raw.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setRefBlockBytes(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setRefBlockNum(value);
          break;
        case 4:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setRefBlockHash(value);
          break;
        case 8:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExpiration(value);
          break;
        case 9:
          var value = new TronWebProto.authority();
          reader.readMessage(value, TronWebProto.authority.deserializeBinaryFromReader);
          msg.addAuths(value);
          break;
        case 10:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setData(value);
          break;
        case 11:
          var value = new TronWebProto.Transaction.Contract();
          reader.readMessage(value, TronWebProto.Transaction.Contract.deserializeBinaryFromReader);
          msg.addContract(value);
          break;
        case 12:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setScripts(value);
          break;
        case 14:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setTimestamp(value);
          break;
        case 18:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFeeLimit(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.Transaction.raw.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.Transaction.raw.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.Transaction.raw.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getRefBlockBytes_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getRefBlockNum();
    if (f2 !== 0) {
      writer.writeInt64(
        3,
        f2
      );
    }
    f2 = message2.getRefBlockHash_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        4,
        f2
      );
    }
    f2 = message2.getExpiration();
    if (f2 !== 0) {
      writer.writeInt64(
        8,
        f2
      );
    }
    f2 = message2.getAuthsList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        9,
        f2,
        TronWebProto.authority.serializeBinaryToWriter
      );
    }
    f2 = message2.getData_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        10,
        f2
      );
    }
    f2 = message2.getContractList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        11,
        f2,
        TronWebProto.Transaction.Contract.serializeBinaryToWriter
      );
    }
    f2 = message2.getScripts_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        12,
        f2
      );
    }
    f2 = message2.getTimestamp();
    if (f2 !== 0) {
      writer.writeInt64(
        14,
        f2
      );
    }
    f2 = message2.getFeeLimit();
    if (f2 !== 0) {
      writer.writeInt64(
        18,
        f2
      );
    }
  };
  TronWebProto.Transaction.raw.prototype.getRefBlockBytes = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getRefBlockBytes()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getRefBlockBytes()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.setRefBlockBytes = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.Transaction.raw.prototype.getRefBlockNum = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.Transaction.raw.prototype.setRefBlockNum = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.Transaction.raw.prototype.getRefBlockHash = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.Transaction.raw.prototype.getRefBlockHash_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getRefBlockHash()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.getRefBlockHash_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getRefBlockHash()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.setRefBlockHash = function(value) {
    return jspb.Message.setProto3BytesField(this, 4, value);
  };
  TronWebProto.Transaction.raw.prototype.getExpiration = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 8, 0)
    );
  };
  TronWebProto.Transaction.raw.prototype.setExpiration = function(value) {
    return jspb.Message.setProto3IntField(this, 8, value);
  };
  TronWebProto.Transaction.raw.prototype.getAuthsList = function() {
    return (
      /** @type{!Array<!TronWebProto.authority>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.authority, 9)
    );
  };
  TronWebProto.Transaction.raw.prototype.setAuthsList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 9, value);
  };
  TronWebProto.Transaction.raw.prototype.addAuths = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 9, opt_value, TronWebProto.authority, opt_index);
  };
  TronWebProto.Transaction.raw.prototype.clearAuthsList = function() {
    return this.setAuthsList([]);
  };
  TronWebProto.Transaction.raw.prototype.getData = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 10, "")
    );
  };
  TronWebProto.Transaction.raw.prototype.getData_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getData()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.getData_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getData()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.setData = function(value) {
    return jspb.Message.setProto3BytesField(this, 10, value);
  };
  TronWebProto.Transaction.raw.prototype.getContractList = function() {
    return (
      /** @type{!Array<!TronWebProto.Transaction.Contract>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Contract, 11)
    );
  };
  TronWebProto.Transaction.raw.prototype.setContractList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 11, value);
  };
  TronWebProto.Transaction.raw.prototype.addContract = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 11, opt_value, TronWebProto.Transaction.Contract, opt_index);
  };
  TronWebProto.Transaction.raw.prototype.clearContractList = function() {
    return this.setContractList([]);
  };
  TronWebProto.Transaction.raw.prototype.getScripts = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 12, "")
    );
  };
  TronWebProto.Transaction.raw.prototype.getScripts_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getScripts()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.getScripts_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getScripts()
      )
    );
  };
  TronWebProto.Transaction.raw.prototype.setScripts = function(value) {
    return jspb.Message.setProto3BytesField(this, 12, value);
  };
  TronWebProto.Transaction.raw.prototype.getTimestamp = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 14, 0)
    );
  };
  TronWebProto.Transaction.raw.prototype.setTimestamp = function(value) {
    return jspb.Message.setProto3IntField(this, 14, value);
  };
  TronWebProto.Transaction.raw.prototype.getFeeLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 18, 0)
    );
  };
  TronWebProto.Transaction.raw.prototype.setFeeLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 18, value);
  };
  TronWebProto.Transaction.prototype.getRawData = function() {
    return (
      /** @type{?TronWebProto.Transaction.raw} */
      jspb.Message.getWrapperField(this, TronWebProto.Transaction.raw, 1)
    );
  };
  TronWebProto.Transaction.prototype.setRawData = function(value) {
    return jspb.Message.setWrapperField(this, 1, value);
  };
  TronWebProto.Transaction.prototype.clearRawData = function() {
    return this.setRawData(void 0);
  };
  TronWebProto.Transaction.prototype.hasRawData = function() {
    return jspb.Message.getField(this, 1) != null;
  };
  TronWebProto.Transaction.prototype.getSignatureList = function() {
    return (
      /** @type {!(Array<!Uint8Array>|Array<string>)} */
      jspb.Message.getRepeatedField(this, 2)
    );
  };
  TronWebProto.Transaction.prototype.getSignatureList_asB64 = function() {
    return (
      /** @type {!Array<string>} */
      jspb.Message.bytesListAsB64(
        this.getSignatureList()
      )
    );
  };
  TronWebProto.Transaction.prototype.getSignatureList_asU8 = function() {
    return (
      /** @type {!Array<!Uint8Array>} */
      jspb.Message.bytesListAsU8(
        this.getSignatureList()
      )
    );
  };
  TronWebProto.Transaction.prototype.setSignatureList = function(value) {
    return jspb.Message.setField(this, 2, value || []);
  };
  TronWebProto.Transaction.prototype.addSignature = function(value, opt_index) {
    return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
  };
  TronWebProto.Transaction.prototype.clearSignatureList = function() {
    return this.setSignatureList([]);
  };
  TronWebProto.Transaction.prototype.getRetList = function() {
    return (
      /** @type{!Array<!TronWebProto.Transaction.Result>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Result, 5)
    );
  };
  TronWebProto.Transaction.prototype.setRetList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 5, value);
  };
  TronWebProto.Transaction.prototype.addRet = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.Transaction.Result, opt_index);
  };
  TronWebProto.Transaction.prototype.clearRetList = function() {
    return this.setRetList([]);
  };
  TronWebProto.AccountType = {
    NORMAL: 0,
    ASSETISSUE: 1,
    CONTRACT: 2
  };
  goog.object.extend(exports, TronWebProto);
})(Tron_pb);
var balance_contract_pb = {};
var common_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  goog.exportSymbol("TronWebProto.ResourceCode", null, global2);
  TronWebProto.ResourceCode = {
    BANDWIDTH: 0,
    ENERGY: 1,
    TRON_POWER: 2
  };
  goog.object.extend(exports, TronWebProto);
})(common_pb);
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  var core_contract_common_pb = common_pb;
  goog.object.extend(proto, core_contract_common_pb);
  goog.exportSymbol("TronWebProto.AccountBalanceRequest", null, global2);
  goog.exportSymbol("TronWebProto.AccountBalanceResponse", null, global2);
  goog.exportSymbol("TronWebProto.AccountIdentifier", null, global2);
  goog.exportSymbol("TronWebProto.AccountTrace", null, global2);
  goog.exportSymbol("TronWebProto.BlockBalanceTrace", null, global2);
  goog.exportSymbol("TronWebProto.BlockBalanceTrace.BlockIdentifier", null, global2);
  goog.exportSymbol("TronWebProto.CancelAllUnfreezeV2Contract", null, global2);
  goog.exportSymbol("TronWebProto.DelegateResourceContract", null, global2);
  goog.exportSymbol("TronWebProto.FreezeBalanceContract", null, global2);
  goog.exportSymbol("TronWebProto.FreezeBalanceV2Contract", null, global2);
  goog.exportSymbol("TronWebProto.TransactionBalanceTrace", null, global2);
  goog.exportSymbol("TronWebProto.TransactionBalanceTrace.Operation", null, global2);
  goog.exportSymbol("TronWebProto.TransferContract", null, global2);
  goog.exportSymbol("TronWebProto.UnDelegateResourceContract", null, global2);
  goog.exportSymbol("TronWebProto.UnfreezeBalanceContract", null, global2);
  goog.exportSymbol("TronWebProto.UnfreezeBalanceV2Contract", null, global2);
  goog.exportSymbol("TronWebProto.WithdrawBalanceContract", null, global2);
  goog.exportSymbol("TronWebProto.WithdrawExpireUnfreezeContract", null, global2);
  TronWebProto.FreezeBalanceContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.FreezeBalanceContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.FreezeBalanceContract.displayName = "TronWebProto.FreezeBalanceContract";
  }
  TronWebProto.UnfreezeBalanceContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UnfreezeBalanceContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UnfreezeBalanceContract.displayName = "TronWebProto.UnfreezeBalanceContract";
  }
  TronWebProto.WithdrawBalanceContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.WithdrawBalanceContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.WithdrawBalanceContract.displayName = "TronWebProto.WithdrawBalanceContract";
  }
  TronWebProto.TransferContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.TransferContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.TransferContract.displayName = "TronWebProto.TransferContract";
  }
  TronWebProto.TransactionBalanceTrace = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.TransactionBalanceTrace.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.TransactionBalanceTrace, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.TransactionBalanceTrace.displayName = "TronWebProto.TransactionBalanceTrace";
  }
  TronWebProto.TransactionBalanceTrace.Operation = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.TransactionBalanceTrace.Operation, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.TransactionBalanceTrace.Operation.displayName = "TronWebProto.TransactionBalanceTrace.Operation";
  }
  TronWebProto.BlockBalanceTrace = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.BlockBalanceTrace.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.BlockBalanceTrace, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.BlockBalanceTrace.displayName = "TronWebProto.BlockBalanceTrace";
  }
  TronWebProto.BlockBalanceTrace.BlockIdentifier = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.BlockBalanceTrace.BlockIdentifier, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.BlockBalanceTrace.BlockIdentifier.displayName = "TronWebProto.BlockBalanceTrace.BlockIdentifier";
  }
  TronWebProto.AccountTrace = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AccountTrace, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountTrace.displayName = "TronWebProto.AccountTrace";
  }
  TronWebProto.AccountIdentifier = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AccountIdentifier, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountIdentifier.displayName = "TronWebProto.AccountIdentifier";
  }
  TronWebProto.AccountBalanceRequest = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AccountBalanceRequest, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountBalanceRequest.displayName = "TronWebProto.AccountBalanceRequest";
  }
  TronWebProto.AccountBalanceResponse = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AccountBalanceResponse, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountBalanceResponse.displayName = "TronWebProto.AccountBalanceResponse";
  }
  TronWebProto.FreezeBalanceV2Contract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.FreezeBalanceV2Contract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.FreezeBalanceV2Contract.displayName = "TronWebProto.FreezeBalanceV2Contract";
  }
  TronWebProto.UnfreezeBalanceV2Contract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UnfreezeBalanceV2Contract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UnfreezeBalanceV2Contract.displayName = "TronWebProto.UnfreezeBalanceV2Contract";
  }
  TronWebProto.WithdrawExpireUnfreezeContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.WithdrawExpireUnfreezeContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.WithdrawExpireUnfreezeContract.displayName = "TronWebProto.WithdrawExpireUnfreezeContract";
  }
  TronWebProto.DelegateResourceContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.DelegateResourceContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.DelegateResourceContract.displayName = "TronWebProto.DelegateResourceContract";
  }
  TronWebProto.UnDelegateResourceContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UnDelegateResourceContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UnDelegateResourceContract.displayName = "TronWebProto.UnDelegateResourceContract";
  }
  TronWebProto.CancelAllUnfreezeV2Contract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.CancelAllUnfreezeV2Contract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.CancelAllUnfreezeV2Contract.displayName = "TronWebProto.CancelAllUnfreezeV2Contract";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.FreezeBalanceContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.FreezeBalanceContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.FreezeBalanceContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        frozenBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
        frozenDuration: jspb.Message.getFieldWithDefault(msg, 3, 0),
        resource: jspb.Message.getFieldWithDefault(msg, 10, 0),
        receiverAddress: msg.getReceiverAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.FreezeBalanceContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.FreezeBalanceContract();
    return TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenBalance(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenDuration(value);
          break;
        case 10:
          var value = (
            /** @type {!TronWebProto.ResourceCode} */
            reader.readEnum()
          );
          msg.setResource(value);
          break;
        case 15:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setReceiverAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.FreezeBalanceContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.FreezeBalanceContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.FreezeBalanceContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getFrozenBalance();
    if (f2 !== 0) {
      writer.writeInt64(2, f2);
    }
    f2 = message2.getFrozenDuration();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
    f2 = message2.getResource();
    if (f2 !== 0) {
      writer.writeEnum(10, f2);
    }
    f2 = message2.getReceiverAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(15, f2);
    }
  };
  TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.FreezeBalanceContract.prototype.getFrozenBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.setFrozenBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.FreezeBalanceContract.prototype.getFrozenDuration = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.setFrozenDuration = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.FreezeBalanceContract.prototype.getResource = function() {
    return (
      /** @type {!TronWebProto.ResourceCode} */
      jspb.Message.getFieldWithDefault(this, 10, 0)
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.setResource = function(value) {
    return jspb.Message.setProto3EnumField(this, 10, value);
  };
  TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 15, "")
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getReceiverAddress())
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getReceiverAddress())
    );
  };
  TronWebProto.FreezeBalanceContract.prototype.setReceiverAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 15, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UnfreezeBalanceContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UnfreezeBalanceContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UnfreezeBalanceContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        resource: jspb.Message.getFieldWithDefault(msg, 10, 0),
        receiverAddress: msg.getReceiverAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UnfreezeBalanceContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UnfreezeBalanceContract();
    return TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 10:
          var value = (
            /** @type {!TronWebProto.ResourceCode} */
            reader.readEnum()
          );
          msg.setResource(value);
          break;
        case 15:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setReceiverAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UnfreezeBalanceContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getResource();
    if (f2 !== 0) {
      writer.writeEnum(10, f2);
    }
    f2 = message2.getReceiverAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(15, f2);
    }
  };
  TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.UnfreezeBalanceContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.UnfreezeBalanceContract.prototype.getResource = function() {
    return (
      /** @type {!TronWebProto.ResourceCode} */
      jspb.Message.getFieldWithDefault(this, 10, 0)
    );
  };
  TronWebProto.UnfreezeBalanceContract.prototype.setResource = function(value) {
    return jspb.Message.setProto3EnumField(this, 10, value);
  };
  TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 15, "")
    );
  };
  TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getReceiverAddress())
    );
  };
  TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getReceiverAddress())
    );
  };
  TronWebProto.UnfreezeBalanceContract.prototype.setReceiverAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 15, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.WithdrawBalanceContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.WithdrawBalanceContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.WithdrawBalanceContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.WithdrawBalanceContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.WithdrawBalanceContract();
    return TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.WithdrawBalanceContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
  };
  TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.WithdrawBalanceContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.TransferContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.TransferContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.TransferContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        toAddress: msg.getToAddress_asB64(),
        amount: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.TransferContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.TransferContract();
    return TronWebProto.TransferContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.TransferContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setToAddress(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setAmount(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.TransferContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.TransferContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.TransferContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getToAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getAmount();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
  };
  TronWebProto.TransferContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.TransferContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.TransferContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.TransferContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.TransferContract.prototype.getToAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.TransferContract.prototype.getToAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getToAddress())
    );
  };
  TronWebProto.TransferContract.prototype.getToAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getToAddress())
    );
  };
  TronWebProto.TransferContract.prototype.setToAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.TransferContract.prototype.getAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.TransferContract.prototype.setAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.TransactionBalanceTrace.repeatedFields_ = [2];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.TransactionBalanceTrace.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.TransactionBalanceTrace.toObject(opt_includeInstance, this);
    };
    TronWebProto.TransactionBalanceTrace.toObject = function(includeInstance, msg) {
      var obj = {
        transactionIdentifier: msg.getTransactionIdentifier_asB64(),
        operationList: jspb.Message.toObjectList(
          msg.getOperationList(),
          TronWebProto.TransactionBalanceTrace.Operation.toObject,
          includeInstance
        ),
        type: jspb.Message.getFieldWithDefault(msg, 3, ""),
        status: jspb.Message.getFieldWithDefault(msg, 4, "")
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.TransactionBalanceTrace.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.TransactionBalanceTrace();
    return TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setTransactionIdentifier(value);
          break;
        case 2:
          var value = new TronWebProto.TransactionBalanceTrace.Operation();
          reader.readMessage(value, TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader);
          msg.addOperation(value);
          break;
        case 3:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setType(value);
          break;
        case 4:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setStatus(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.TransactionBalanceTrace.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getTransactionIdentifier_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getOperationList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(2, f2, TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter);
    }
    f2 = message2.getType();
    if (f2.length > 0) {
      writer.writeString(3, f2);
    }
    f2 = message2.getStatus();
    if (f2.length > 0) {
      writer.writeString(4, f2);
    }
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.TransactionBalanceTrace.Operation.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.TransactionBalanceTrace.Operation.toObject(opt_includeInstance, this);
    };
    TronWebProto.TransactionBalanceTrace.Operation.toObject = function(includeInstance, msg) {
      var obj = {
        operationIdentifier: jspb.Message.getFieldWithDefault(msg, 1, 0),
        address: msg.getAddress_asB64(),
        amount: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.TransactionBalanceTrace.Operation.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.TransactionBalanceTrace.Operation();
    return TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setOperationIdentifier(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAddress(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setAmount(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOperationIdentifier();
    if (f2 !== 0) {
      writer.writeInt64(1, f2);
    }
    f2 = message2.getAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getAmount();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.getOperationIdentifier = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.setOperationIdentifier = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getAddress())
    );
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getAddress())
    );
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.setAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.getAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.TransactionBalanceTrace.Operation.prototype.setAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getTransactionIdentifier())
    );
  };
  TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getTransactionIdentifier())
    );
  };
  TronWebProto.TransactionBalanceTrace.prototype.setTransactionIdentifier = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.TransactionBalanceTrace.prototype.getOperationList = function() {
    return (
      /** @type{!Array<!TronWebProto.TransactionBalanceTrace.Operation>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace.Operation, 2)
    );
  };
  TronWebProto.TransactionBalanceTrace.prototype.setOperationList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 2, value);
  };
  TronWebProto.TransactionBalanceTrace.prototype.addOperation = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, TronWebProto.TransactionBalanceTrace.Operation, opt_index);
  };
  TronWebProto.TransactionBalanceTrace.prototype.clearOperationList = function() {
    return this.setOperationList([]);
  };
  TronWebProto.TransactionBalanceTrace.prototype.getType = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.TransactionBalanceTrace.prototype.setType = function(value) {
    return jspb.Message.setProto3StringField(this, 3, value);
  };
  TronWebProto.TransactionBalanceTrace.prototype.getStatus = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.TransactionBalanceTrace.prototype.setStatus = function(value) {
    return jspb.Message.setProto3StringField(this, 4, value);
  };
  TronWebProto.BlockBalanceTrace.repeatedFields_ = [3];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.BlockBalanceTrace.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.BlockBalanceTrace.toObject(opt_includeInstance, this);
    };
    TronWebProto.BlockBalanceTrace.toObject = function(includeInstance, msg) {
      var f2, obj = {
        blockIdentifier: (f2 = msg.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(includeInstance, f2),
        timestamp: jspb.Message.getFieldWithDefault(msg, 2, 0),
        transactionBalanceTraceList: jspb.Message.toObjectList(
          msg.getTransactionBalanceTraceList(),
          TronWebProto.TransactionBalanceTrace.toObject,
          includeInstance
        )
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.BlockBalanceTrace.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.BlockBalanceTrace();
    return TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
          reader.readMessage(value, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader);
          msg.setBlockIdentifier(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setTimestamp(value);
          break;
        case 3:
          var value = new TronWebProto.TransactionBalanceTrace();
          reader.readMessage(value, TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader);
          msg.addTransactionBalanceTrace(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.BlockBalanceTrace.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.BlockBalanceTrace.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.BlockBalanceTrace.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getBlockIdentifier();
    if (f2 != null) {
      writer.writeMessage(1, f2, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter);
    }
    f2 = message2.getTimestamp();
    if (f2 !== 0) {
      writer.writeInt64(2, f2);
    }
    f2 = message2.getTransactionBalanceTraceList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(3, f2, TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter);
    }
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(opt_includeInstance, this);
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject = function(includeInstance, msg) {
      var obj = {
        hash: msg.getHash_asB64(),
        number: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
    return TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setHash(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setNumber(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getHash_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getNumber();
    if (f2 !== 0) {
      writer.writeInt64(2, f2);
    }
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getHash())
    );
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getHash())
    );
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setHash = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getNumber = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setNumber = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.BlockBalanceTrace.prototype.getBlockIdentifier = function() {
    return (
      /** @type{?TronWebProto.BlockBalanceTrace.BlockIdentifier} */
      jspb.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 1)
    );
  };
  TronWebProto.BlockBalanceTrace.prototype.setBlockIdentifier = function(value) {
    return jspb.Message.setWrapperField(this, 1, value);
  };
  TronWebProto.BlockBalanceTrace.prototype.clearBlockIdentifier = function() {
    return this.setBlockIdentifier(void 0);
  };
  TronWebProto.BlockBalanceTrace.prototype.hasBlockIdentifier = function() {
    return jspb.Message.getField(this, 1) != null;
  };
  TronWebProto.BlockBalanceTrace.prototype.getTimestamp = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.BlockBalanceTrace.prototype.setTimestamp = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.BlockBalanceTrace.prototype.getTransactionBalanceTraceList = function() {
    return (
      /** @type{!Array<!TronWebProto.TransactionBalanceTrace>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace, 3)
    );
  };
  TronWebProto.BlockBalanceTrace.prototype.setTransactionBalanceTraceList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 3, value);
  };
  TronWebProto.BlockBalanceTrace.prototype.addTransactionBalanceTrace = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, TronWebProto.TransactionBalanceTrace, opt_index);
  };
  TronWebProto.BlockBalanceTrace.prototype.clearTransactionBalanceTraceList = function() {
    return this.setTransactionBalanceTraceList([]);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountTrace.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountTrace.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountTrace.toObject = function(includeInstance, msg) {
      var obj = {
        balance: jspb.Message.getFieldWithDefault(msg, 1, 0),
        placeholder: jspb.Message.getFieldWithDefault(msg, 99, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountTrace.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountTrace();
    return TronWebProto.AccountTrace.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountTrace.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setBalance(value);
          break;
        case 99:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setPlaceholder(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountTrace.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountTrace.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountTrace.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getBalance();
    if (f2 !== 0) {
      writer.writeInt64(1, f2);
    }
    f2 = message2.getPlaceholder();
    if (f2 !== 0) {
      writer.writeInt64(99, f2);
    }
  };
  TronWebProto.AccountTrace.prototype.getBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.AccountTrace.prototype.setBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.AccountTrace.prototype.getPlaceholder = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 99, 0)
    );
  };
  TronWebProto.AccountTrace.prototype.setPlaceholder = function(value) {
    return jspb.Message.setProto3IntField(this, 99, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountIdentifier.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountIdentifier.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountIdentifier.toObject = function(includeInstance, msg) {
      var obj = {
        address: msg.getAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountIdentifier.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountIdentifier();
    return TronWebProto.AccountIdentifier.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountIdentifier.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountIdentifier.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountIdentifier.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountIdentifier.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
  };
  TronWebProto.AccountIdentifier.prototype.getAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.AccountIdentifier.prototype.getAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getAddress())
    );
  };
  TronWebProto.AccountIdentifier.prototype.getAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getAddress())
    );
  };
  TronWebProto.AccountIdentifier.prototype.setAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountBalanceRequest.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountBalanceRequest.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountBalanceRequest.toObject = function(includeInstance, msg) {
      var f2, obj = {
        accountIdentifier: (f2 = msg.getAccountIdentifier()) && TronWebProto.AccountIdentifier.toObject(includeInstance, f2),
        blockIdentifier: (f2 = msg.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(includeInstance, f2)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountBalanceRequest.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountBalanceRequest();
    return TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = new TronWebProto.AccountIdentifier();
          reader.readMessage(value, TronWebProto.AccountIdentifier.deserializeBinaryFromReader);
          msg.setAccountIdentifier(value);
          break;
        case 2:
          var value = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
          reader.readMessage(value, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader);
          msg.setBlockIdentifier(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountBalanceRequest.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountBalanceRequest.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountBalanceRequest.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAccountIdentifier();
    if (f2 != null) {
      writer.writeMessage(1, f2, TronWebProto.AccountIdentifier.serializeBinaryToWriter);
    }
    f2 = message2.getBlockIdentifier();
    if (f2 != null) {
      writer.writeMessage(2, f2, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter);
    }
  };
  TronWebProto.AccountBalanceRequest.prototype.getAccountIdentifier = function() {
    return (
      /** @type{?TronWebProto.AccountIdentifier} */
      jspb.Message.getWrapperField(this, TronWebProto.AccountIdentifier, 1)
    );
  };
  TronWebProto.AccountBalanceRequest.prototype.setAccountIdentifier = function(value) {
    return jspb.Message.setWrapperField(this, 1, value);
  };
  TronWebProto.AccountBalanceRequest.prototype.clearAccountIdentifier = function() {
    return this.setAccountIdentifier(void 0);
  };
  TronWebProto.AccountBalanceRequest.prototype.hasAccountIdentifier = function() {
    return jspb.Message.getField(this, 1) != null;
  };
  TronWebProto.AccountBalanceRequest.prototype.getBlockIdentifier = function() {
    return (
      /** @type{?TronWebProto.BlockBalanceTrace.BlockIdentifier} */
      jspb.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
    );
  };
  TronWebProto.AccountBalanceRequest.prototype.setBlockIdentifier = function(value) {
    return jspb.Message.setWrapperField(this, 2, value);
  };
  TronWebProto.AccountBalanceRequest.prototype.clearBlockIdentifier = function() {
    return this.setBlockIdentifier(void 0);
  };
  TronWebProto.AccountBalanceRequest.prototype.hasBlockIdentifier = function() {
    return jspb.Message.getField(this, 2) != null;
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountBalanceResponse.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountBalanceResponse.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountBalanceResponse.toObject = function(includeInstance, msg) {
      var f2, obj = {
        balance: jspb.Message.getFieldWithDefault(msg, 1, 0),
        blockIdentifier: (f2 = msg.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(includeInstance, f2)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountBalanceResponse.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountBalanceResponse();
    return TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setBalance(value);
          break;
        case 2:
          var value = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
          reader.readMessage(value, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader);
          msg.setBlockIdentifier(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountBalanceResponse.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountBalanceResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountBalanceResponse.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getBalance();
    if (f2 !== 0) {
      writer.writeInt64(1, f2);
    }
    f2 = message2.getBlockIdentifier();
    if (f2 != null) {
      writer.writeMessage(2, f2, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter);
    }
  };
  TronWebProto.AccountBalanceResponse.prototype.getBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.AccountBalanceResponse.prototype.setBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.AccountBalanceResponse.prototype.getBlockIdentifier = function() {
    return (
      /** @type{?TronWebProto.BlockBalanceTrace.BlockIdentifier} */
      jspb.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
    );
  };
  TronWebProto.AccountBalanceResponse.prototype.setBlockIdentifier = function(value) {
    return jspb.Message.setWrapperField(this, 2, value);
  };
  TronWebProto.AccountBalanceResponse.prototype.clearBlockIdentifier = function() {
    return this.setBlockIdentifier(void 0);
  };
  TronWebProto.AccountBalanceResponse.prototype.hasBlockIdentifier = function() {
    return jspb.Message.getField(this, 2) != null;
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.FreezeBalanceV2Contract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.FreezeBalanceV2Contract.toObject(opt_includeInstance, this);
    };
    TronWebProto.FreezeBalanceV2Contract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        frozenBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
        resource: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.FreezeBalanceV2Contract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.FreezeBalanceV2Contract();
    return TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenBalance(value);
          break;
        case 3:
          var value = (
            /** @type {!TronWebProto.ResourceCode} */
            reader.readEnum()
          );
          msg.setResource(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getFrozenBalance();
    if (f2 !== 0) {
      writer.writeInt64(2, f2);
    }
    f2 = message2.getResource();
    if (f2 !== 0) {
      writer.writeEnum(3, f2);
    }
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.getFrozenBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.setFrozenBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.getResource = function() {
    return (
      /** @type {!TronWebProto.ResourceCode} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.FreezeBalanceV2Contract.prototype.setResource = function(value) {
    return jspb.Message.setProto3EnumField(this, 3, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UnfreezeBalanceV2Contract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UnfreezeBalanceV2Contract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UnfreezeBalanceV2Contract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        unfreezeBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
        resource: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UnfreezeBalanceV2Contract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UnfreezeBalanceV2Contract();
    return TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setUnfreezeBalance(value);
          break;
        case 3:
          var value = (
            /** @type {!TronWebProto.ResourceCode} */
            reader.readEnum()
          );
          msg.setResource(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getUnfreezeBalance();
    if (f2 !== 0) {
      writer.writeInt64(2, f2);
    }
    f2 = message2.getResource();
    if (f2 !== 0) {
      writer.writeEnum(3, f2);
    }
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.getUnfreezeBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.setUnfreezeBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.getResource = function() {
    return (
      /** @type {!TronWebProto.ResourceCode} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.UnfreezeBalanceV2Contract.prototype.setResource = function(value) {
    return jspb.Message.setProto3EnumField(this, 3, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.WithdrawExpireUnfreezeContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.WithdrawExpireUnfreezeContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.WithdrawExpireUnfreezeContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.WithdrawExpireUnfreezeContract();
    return TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.WithdrawExpireUnfreezeContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
  };
  TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.WithdrawExpireUnfreezeContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.DelegateResourceContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.DelegateResourceContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.DelegateResourceContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        resource: jspb.Message.getFieldWithDefault(msg, 2, 0),
        balance: jspb.Message.getFieldWithDefault(msg, 3, 0),
        receiverAddress: msg.getReceiverAddress_asB64(),
        lock: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
        lockPeriod: jspb.Message.getFieldWithDefault(msg, 6, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.DelegateResourceContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.DelegateResourceContract();
    return TronWebProto.DelegateResourceContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.DelegateResourceContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!TronWebProto.ResourceCode} */
            reader.readEnum()
          );
          msg.setResource(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setBalance(value);
          break;
        case 4:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setReceiverAddress(value);
          break;
        case 5:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setLock(value);
          break;
        case 6:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setLockPeriod(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.DelegateResourceContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.DelegateResourceContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.DelegateResourceContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getResource();
    if (f2 !== 0) {
      writer.writeEnum(2, f2);
    }
    f2 = message2.getBalance();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
    f2 = message2.getReceiverAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(4, f2);
    }
    f2 = message2.getLock();
    if (f2) {
      writer.writeBool(5, f2);
    }
    f2 = message2.getLockPeriod();
    if (f2 !== 0) {
      writer.writeInt64(6, f2);
    }
  };
  TronWebProto.DelegateResourceContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.DelegateResourceContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.DelegateResourceContract.prototype.getResource = function() {
    return (
      /** @type {!TronWebProto.ResourceCode} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.DelegateResourceContract.prototype.setResource = function(value) {
    return jspb.Message.setProto3EnumField(this, 2, value);
  };
  TronWebProto.DelegateResourceContract.prototype.getBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.DelegateResourceContract.prototype.setBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.DelegateResourceContract.prototype.getReceiverAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getReceiverAddress())
    );
  };
  TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getReceiverAddress())
    );
  };
  TronWebProto.DelegateResourceContract.prototype.setReceiverAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 4, value);
  };
  TronWebProto.DelegateResourceContract.prototype.getLock = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 5, false)
    );
  };
  TronWebProto.DelegateResourceContract.prototype.setLock = function(value) {
    return jspb.Message.setProto3BooleanField(this, 5, value);
  };
  TronWebProto.DelegateResourceContract.prototype.getLockPeriod = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.DelegateResourceContract.prototype.setLockPeriod = function(value) {
    return jspb.Message.setProto3IntField(this, 6, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UnDelegateResourceContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UnDelegateResourceContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UnDelegateResourceContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        resource: jspb.Message.getFieldWithDefault(msg, 2, 0),
        balance: jspb.Message.getFieldWithDefault(msg, 3, 0),
        receiverAddress: msg.getReceiverAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UnDelegateResourceContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UnDelegateResourceContract();
    return TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!TronWebProto.ResourceCode} */
            reader.readEnum()
          );
          msg.setResource(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setBalance(value);
          break;
        case 4:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setReceiverAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UnDelegateResourceContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getResource();
    if (f2 !== 0) {
      writer.writeEnum(2, f2);
    }
    f2 = message2.getBalance();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
    f2 = message2.getReceiverAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(4, f2);
    }
  };
  TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.UnDelegateResourceContract.prototype.getResource = function() {
    return (
      /** @type {!TronWebProto.ResourceCode} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.setResource = function(value) {
    return jspb.Message.setProto3EnumField(this, 2, value);
  };
  TronWebProto.UnDelegateResourceContract.prototype.getBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.setBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getReceiverAddress())
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getReceiverAddress())
    );
  };
  TronWebProto.UnDelegateResourceContract.prototype.setReceiverAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 4, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.CancelAllUnfreezeV2Contract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.CancelAllUnfreezeV2Contract.toObject(opt_includeInstance, this);
    };
    TronWebProto.CancelAllUnfreezeV2Contract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.CancelAllUnfreezeV2Contract();
    return TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.CancelAllUnfreezeV2Contract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
  };
  TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.CancelAllUnfreezeV2Contract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  goog.object.extend(exports, TronWebProto);
})(balance_contract_pb);
var asset_issue_contract_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  goog.exportSymbol("TronWebProto.AssetIssueContract", null, global2);
  goog.exportSymbol("TronWebProto.AssetIssueContract.FrozenSupply", null, global2);
  goog.exportSymbol("TronWebProto.ParticipateAssetIssueContract", null, global2);
  goog.exportSymbol("TronWebProto.TransferAssetContract", null, global2);
  goog.exportSymbol("TronWebProto.UnfreezeAssetContract", null, global2);
  goog.exportSymbol("TronWebProto.UpdateAssetContract", null, global2);
  TronWebProto.AssetIssueContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.AssetIssueContract.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.AssetIssueContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AssetIssueContract.displayName = "TronWebProto.AssetIssueContract";
  }
  TronWebProto.AssetIssueContract.FrozenSupply = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AssetIssueContract.FrozenSupply, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AssetIssueContract.FrozenSupply.displayName = "TronWebProto.AssetIssueContract.FrozenSupply";
  }
  TronWebProto.TransferAssetContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.TransferAssetContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.TransferAssetContract.displayName = "TronWebProto.TransferAssetContract";
  }
  TronWebProto.UnfreezeAssetContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UnfreezeAssetContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UnfreezeAssetContract.displayName = "TronWebProto.UnfreezeAssetContract";
  }
  TronWebProto.UpdateAssetContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UpdateAssetContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UpdateAssetContract.displayName = "TronWebProto.UpdateAssetContract";
  }
  TronWebProto.ParticipateAssetIssueContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ParticipateAssetIssueContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ParticipateAssetIssueContract.displayName = "TronWebProto.ParticipateAssetIssueContract";
  }
  TronWebProto.AssetIssueContract.repeatedFields_ = [5];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AssetIssueContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AssetIssueContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.AssetIssueContract.toObject = function(includeInstance, msg) {
      var obj = {
        id: jspb.Message.getFieldWithDefault(msg, 41, ""),
        ownerAddress: msg.getOwnerAddress_asB64(),
        name: msg.getName_asB64(),
        abbr: msg.getAbbr_asB64(),
        totalSupply: jspb.Message.getFieldWithDefault(msg, 4, 0),
        frozenSupplyList: jspb.Message.toObjectList(
          msg.getFrozenSupplyList(),
          TronWebProto.AssetIssueContract.FrozenSupply.toObject,
          includeInstance
        ),
        trxNum: jspb.Message.getFieldWithDefault(msg, 6, 0),
        precision: jspb.Message.getFieldWithDefault(msg, 7, 0),
        num: jspb.Message.getFieldWithDefault(msg, 8, 0),
        startTime: jspb.Message.getFieldWithDefault(msg, 9, 0),
        endTime: jspb.Message.getFieldWithDefault(msg, 10, 0),
        order: jspb.Message.getFieldWithDefault(msg, 11, 0),
        voteScore: jspb.Message.getFieldWithDefault(msg, 16, 0),
        description: msg.getDescription_asB64(),
        url: msg.getUrl_asB64(),
        freeAssetNetLimit: jspb.Message.getFieldWithDefault(msg, 22, 0),
        publicFreeAssetNetLimit: jspb.Message.getFieldWithDefault(msg, 23, 0),
        publicFreeAssetNetUsage: jspb.Message.getFieldWithDefault(msg, 24, 0),
        publicLatestFreeNetTime: jspb.Message.getFieldWithDefault(msg, 25, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AssetIssueContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AssetIssueContract();
    return TronWebProto.AssetIssueContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AssetIssueContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 41:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setId(value);
          break;
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setName(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAbbr(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setTotalSupply(value);
          break;
        case 5:
          var value = new TronWebProto.AssetIssueContract.FrozenSupply();
          reader.readMessage(value, TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader);
          msg.addFrozenSupply(value);
          break;
        case 6:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setTrxNum(value);
          break;
        case 7:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setPrecision(value);
          break;
        case 8:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setNum(value);
          break;
        case 9:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setStartTime(value);
          break;
        case 10:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setEndTime(value);
          break;
        case 11:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setOrder(value);
          break;
        case 16:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setVoteScore(value);
          break;
        case 20:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setDescription(value);
          break;
        case 21:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setUrl(value);
          break;
        case 22:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFreeAssetNetLimit(value);
          break;
        case 23:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setPublicFreeAssetNetLimit(value);
          break;
        case 24:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setPublicFreeAssetNetUsage(value);
          break;
        case 25:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setPublicLatestFreeNetTime(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AssetIssueContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AssetIssueContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AssetIssueContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getId();
    if (f2.length > 0) {
      writer.writeString(
        41,
        f2
      );
    }
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getAbbr_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getTotalSupply();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getFrozenSupplyList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        5,
        f2,
        TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter
      );
    }
    f2 = message2.getTrxNum();
    if (f2 !== 0) {
      writer.writeInt32(
        6,
        f2
      );
    }
    f2 = message2.getPrecision();
    if (f2 !== 0) {
      writer.writeInt32(
        7,
        f2
      );
    }
    f2 = message2.getNum();
    if (f2 !== 0) {
      writer.writeInt32(
        8,
        f2
      );
    }
    f2 = message2.getStartTime();
    if (f2 !== 0) {
      writer.writeInt64(
        9,
        f2
      );
    }
    f2 = message2.getEndTime();
    if (f2 !== 0) {
      writer.writeInt64(
        10,
        f2
      );
    }
    f2 = message2.getOrder();
    if (f2 !== 0) {
      writer.writeInt64(
        11,
        f2
      );
    }
    f2 = message2.getVoteScore();
    if (f2 !== 0) {
      writer.writeInt32(
        16,
        f2
      );
    }
    f2 = message2.getDescription_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        20,
        f2
      );
    }
    f2 = message2.getUrl_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        21,
        f2
      );
    }
    f2 = message2.getFreeAssetNetLimit();
    if (f2 !== 0) {
      writer.writeInt64(
        22,
        f2
      );
    }
    f2 = message2.getPublicFreeAssetNetLimit();
    if (f2 !== 0) {
      writer.writeInt64(
        23,
        f2
      );
    }
    f2 = message2.getPublicFreeAssetNetUsage();
    if (f2 !== 0) {
      writer.writeInt64(
        24,
        f2
      );
    }
    f2 = message2.getPublicLatestFreeNetTime();
    if (f2 !== 0) {
      writer.writeInt64(
        25,
        f2
      );
    }
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AssetIssueContract.FrozenSupply.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AssetIssueContract.FrozenSupply.toObject(opt_includeInstance, this);
    };
    TronWebProto.AssetIssueContract.FrozenSupply.toObject = function(includeInstance, msg) {
      var obj = {
        frozenAmount: jspb.Message.getFieldWithDefault(msg, 1, 0),
        frozenDays: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AssetIssueContract.FrozenSupply();
    return TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenAmount(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFrozenDays(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AssetIssueContract.FrozenSupply.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getFrozenAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        1,
        f2
      );
    }
    f2 = message2.getFrozenDays();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenDays = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenDays = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.AssetIssueContract.prototype.getId = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 41, "")
    );
  };
  TronWebProto.AssetIssueContract.prototype.setId = function(value) {
    return jspb.Message.setProto3StringField(this, 41, value);
  };
  TronWebProto.AssetIssueContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.AssetIssueContract.prototype.getName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.AssetIssueContract.prototype.getName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getName()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.getName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getName()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.setName = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.AssetIssueContract.prototype.getAbbr = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.AssetIssueContract.prototype.getAbbr_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAbbr()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.getAbbr_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAbbr()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.setAbbr = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.AssetIssueContract.prototype.getTotalSupply = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setTotalSupply = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.AssetIssueContract.prototype.getFrozenSupplyList = function() {
    return (
      /** @type{!Array<!TronWebProto.AssetIssueContract.FrozenSupply>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.AssetIssueContract.FrozenSupply, 5)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setFrozenSupplyList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 5, value);
  };
  TronWebProto.AssetIssueContract.prototype.addFrozenSupply = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.AssetIssueContract.FrozenSupply, opt_index);
  };
  TronWebProto.AssetIssueContract.prototype.clearFrozenSupplyList = function() {
    return this.setFrozenSupplyList([]);
  };
  TronWebProto.AssetIssueContract.prototype.getTrxNum = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setTrxNum = function(value) {
    return jspb.Message.setProto3IntField(this, 6, value);
  };
  TronWebProto.AssetIssueContract.prototype.getPrecision = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 7, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setPrecision = function(value) {
    return jspb.Message.setProto3IntField(this, 7, value);
  };
  TronWebProto.AssetIssueContract.prototype.getNum = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 8, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setNum = function(value) {
    return jspb.Message.setProto3IntField(this, 8, value);
  };
  TronWebProto.AssetIssueContract.prototype.getStartTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 9, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setStartTime = function(value) {
    return jspb.Message.setProto3IntField(this, 9, value);
  };
  TronWebProto.AssetIssueContract.prototype.getEndTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 10, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setEndTime = function(value) {
    return jspb.Message.setProto3IntField(this, 10, value);
  };
  TronWebProto.AssetIssueContract.prototype.getOrder = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 11, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setOrder = function(value) {
    return jspb.Message.setProto3IntField(this, 11, value);
  };
  TronWebProto.AssetIssueContract.prototype.getVoteScore = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 16, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setVoteScore = function(value) {
    return jspb.Message.setProto3IntField(this, 16, value);
  };
  TronWebProto.AssetIssueContract.prototype.getDescription = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 20, "")
    );
  };
  TronWebProto.AssetIssueContract.prototype.getDescription_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getDescription()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.getDescription_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getDescription()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.setDescription = function(value) {
    return jspb.Message.setProto3BytesField(this, 20, value);
  };
  TronWebProto.AssetIssueContract.prototype.getUrl = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 21, "")
    );
  };
  TronWebProto.AssetIssueContract.prototype.getUrl_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getUrl()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.getUrl_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getUrl()
      )
    );
  };
  TronWebProto.AssetIssueContract.prototype.setUrl = function(value) {
    return jspb.Message.setProto3BytesField(this, 21, value);
  };
  TronWebProto.AssetIssueContract.prototype.getFreeAssetNetLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 22, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setFreeAssetNetLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 22, value);
  };
  TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 23, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 23, value);
  };
  TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetUsage = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 24, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetUsage = function(value) {
    return jspb.Message.setProto3IntField(this, 24, value);
  };
  TronWebProto.AssetIssueContract.prototype.getPublicLatestFreeNetTime = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 25, 0)
    );
  };
  TronWebProto.AssetIssueContract.prototype.setPublicLatestFreeNetTime = function(value) {
    return jspb.Message.setProto3IntField(this, 25, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.TransferAssetContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.TransferAssetContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.TransferAssetContract.toObject = function(includeInstance, msg) {
      var obj = {
        assetName: msg.getAssetName_asB64(),
        ownerAddress: msg.getOwnerAddress_asB64(),
        toAddress: msg.getToAddress_asB64(),
        amount: jspb.Message.getFieldWithDefault(msg, 4, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.TransferAssetContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.TransferAssetContract();
    return TronWebProto.TransferAssetContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.TransferAssetContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAssetName(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setToAddress(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setAmount(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.TransferAssetContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.TransferAssetContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.TransferAssetContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAssetName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getToAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
  };
  TronWebProto.TransferAssetContract.prototype.getAssetName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.TransferAssetContract.prototype.getAssetName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAssetName()
      )
    );
  };
  TronWebProto.TransferAssetContract.prototype.getAssetName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAssetName()
      )
    );
  };
  TronWebProto.TransferAssetContract.prototype.setAssetName = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.TransferAssetContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.TransferAssetContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.TransferAssetContract.prototype.getToAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.TransferAssetContract.prototype.getToAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getToAddress()
      )
    );
  };
  TronWebProto.TransferAssetContract.prototype.getToAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getToAddress()
      )
    );
  };
  TronWebProto.TransferAssetContract.prototype.setToAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.TransferAssetContract.prototype.getAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.TransferAssetContract.prototype.setAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UnfreezeAssetContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UnfreezeAssetContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UnfreezeAssetContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UnfreezeAssetContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UnfreezeAssetContract();
    return TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UnfreezeAssetContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
  };
  TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.UnfreezeAssetContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UpdateAssetContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UpdateAssetContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UpdateAssetContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        description: msg.getDescription_asB64(),
        url: msg.getUrl_asB64(),
        newLimit: jspb.Message.getFieldWithDefault(msg, 4, 0),
        newPublicLimit: jspb.Message.getFieldWithDefault(msg, 5, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UpdateAssetContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UpdateAssetContract();
    return TronWebProto.UpdateAssetContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UpdateAssetContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setDescription(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setUrl(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setNewLimit(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setNewPublicLimit(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UpdateAssetContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UpdateAssetContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UpdateAssetContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getDescription_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getUrl_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getNewLimit();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getNewPublicLimit();
    if (f2 !== 0) {
      writer.writeInt64(
        5,
        f2
      );
    }
  };
  TronWebProto.UpdateAssetContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.UpdateAssetContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.UpdateAssetContract.prototype.getDescription = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.UpdateAssetContract.prototype.getDescription_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getDescription()
      )
    );
  };
  TronWebProto.UpdateAssetContract.prototype.getDescription_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getDescription()
      )
    );
  };
  TronWebProto.UpdateAssetContract.prototype.setDescription = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.UpdateAssetContract.prototype.getUrl = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.UpdateAssetContract.prototype.getUrl_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getUrl()
      )
    );
  };
  TronWebProto.UpdateAssetContract.prototype.getUrl_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getUrl()
      )
    );
  };
  TronWebProto.UpdateAssetContract.prototype.setUrl = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.UpdateAssetContract.prototype.getNewLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.UpdateAssetContract.prototype.setNewLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.UpdateAssetContract.prototype.getNewPublicLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.UpdateAssetContract.prototype.setNewPublicLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ParticipateAssetIssueContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ParticipateAssetIssueContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ParticipateAssetIssueContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        toAddress: msg.getToAddress_asB64(),
        assetName: msg.getAssetName_asB64(),
        amount: jspb.Message.getFieldWithDefault(msg, 4, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ParticipateAssetIssueContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ParticipateAssetIssueContract();
    return TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setToAddress(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAssetName(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setAmount(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getToAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getAssetName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getAmount();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getToAddress()
      )
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getToAddress()
      )
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.setToAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getAssetName()
      )
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getAssetName()
      )
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.setAssetName = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.getAmount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.ParticipateAssetIssueContract.prototype.setAmount = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  goog.object.extend(exports, TronWebProto);
})(asset_issue_contract_pb);
var smart_contract_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  var core_Tron_pb = Tron_pb;
  goog.object.extend(proto, core_Tron_pb);
  goog.exportSymbol("TronWebProto.ClearABIContract", null, global2);
  goog.exportSymbol("TronWebProto.ContractState", null, global2);
  goog.exportSymbol("TronWebProto.CreateSmartContract", null, global2);
  goog.exportSymbol("TronWebProto.SmartContract", null, global2);
  goog.exportSymbol("TronWebProto.SmartContract.ABI", null, global2);
  goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry", null, global2);
  goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry.EntryType", null, global2);
  goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry.Param", null, global2);
  goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry.StateMutabilityType", null, global2);
  goog.exportSymbol("TronWebProto.SmartContractDataWrapper", null, global2);
  goog.exportSymbol("TronWebProto.TriggerSmartContract", null, global2);
  goog.exportSymbol("TronWebProto.UpdateEnergyLimitContract", null, global2);
  goog.exportSymbol("TronWebProto.UpdateSettingContract", null, global2);
  TronWebProto.SmartContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.SmartContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.SmartContract.displayName = "TronWebProto.SmartContract";
  }
  TronWebProto.SmartContract.ABI = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.SmartContract.ABI.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.SmartContract.ABI, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.SmartContract.ABI.displayName = "TronWebProto.SmartContract.ABI";
  }
  TronWebProto.SmartContract.ABI.Entry = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.SmartContract.ABI.Entry.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.SmartContract.ABI.Entry, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.SmartContract.ABI.Entry.displayName = "TronWebProto.SmartContract.ABI.Entry";
  }
  TronWebProto.SmartContract.ABI.Entry.Param = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.SmartContract.ABI.Entry.Param, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.SmartContract.ABI.Entry.Param.displayName = "TronWebProto.SmartContract.ABI.Entry.Param";
  }
  TronWebProto.ContractState = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ContractState, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ContractState.displayName = "TronWebProto.ContractState";
  }
  TronWebProto.CreateSmartContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.CreateSmartContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.CreateSmartContract.displayName = "TronWebProto.CreateSmartContract";
  }
  TronWebProto.TriggerSmartContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.TriggerSmartContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.TriggerSmartContract.displayName = "TronWebProto.TriggerSmartContract";
  }
  TronWebProto.ClearABIContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ClearABIContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ClearABIContract.displayName = "TronWebProto.ClearABIContract";
  }
  TronWebProto.UpdateSettingContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UpdateSettingContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UpdateSettingContract.displayName = "TronWebProto.UpdateSettingContract";
  }
  TronWebProto.UpdateEnergyLimitContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UpdateEnergyLimitContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UpdateEnergyLimitContract.displayName = "TronWebProto.UpdateEnergyLimitContract";
  }
  TronWebProto.SmartContractDataWrapper = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.SmartContractDataWrapper, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.SmartContractDataWrapper.displayName = "TronWebProto.SmartContractDataWrapper";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.SmartContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.SmartContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.SmartContract.toObject = function(includeInstance, msg) {
      var f2, obj = {
        originAddress: msg.getOriginAddress_asB64(),
        contractAddress: msg.getContractAddress_asB64(),
        abi: (f2 = msg.getAbi()) && TronWebProto.SmartContract.ABI.toObject(includeInstance, f2),
        bytecode: msg.getBytecode_asB64(),
        callValue: jspb.Message.getFieldWithDefault(msg, 5, 0),
        consumeUserResourcePercent: jspb.Message.getFieldWithDefault(msg, 6, 0),
        name: jspb.Message.getFieldWithDefault(msg, 7, ""),
        originEnergyLimit: jspb.Message.getFieldWithDefault(msg, 8, 0),
        codeHash: msg.getCodeHash_asB64(),
        trxHash: msg.getTrxHash_asB64(),
        version: jspb.Message.getFieldWithDefault(msg, 11, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.SmartContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.SmartContract();
    return TronWebProto.SmartContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.SmartContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOriginAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setContractAddress(value);
          break;
        case 3:
          var value = new TronWebProto.SmartContract.ABI();
          reader.readMessage(value, TronWebProto.SmartContract.ABI.deserializeBinaryFromReader);
          msg.setAbi(value);
          break;
        case 4:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setBytecode(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setCallValue(value);
          break;
        case 6:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setConsumeUserResourcePercent(value);
          break;
        case 7:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setName(value);
          break;
        case 8:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setOriginEnergyLimit(value);
          break;
        case 9:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setCodeHash(value);
          break;
        case 10:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setTrxHash(value);
          break;
        case 11:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setVersion(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.SmartContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.SmartContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.SmartContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOriginAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getContractAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getAbi();
    if (f2 != null) {
      writer.writeMessage(3, f2, TronWebProto.SmartContract.ABI.serializeBinaryToWriter);
    }
    f2 = message2.getBytecode_asU8();
    if (f2.length > 0) {
      writer.writeBytes(4, f2);
    }
    f2 = message2.getCallValue();
    if (f2 !== 0) {
      writer.writeInt64(5, f2);
    }
    f2 = message2.getConsumeUserResourcePercent();
    if (f2 !== 0) {
      writer.writeInt64(6, f2);
    }
    f2 = message2.getName();
    if (f2.length > 0) {
      writer.writeString(7, f2);
    }
    f2 = message2.getOriginEnergyLimit();
    if (f2 !== 0) {
      writer.writeInt64(8, f2);
    }
    f2 = message2.getCodeHash_asU8();
    if (f2.length > 0) {
      writer.writeBytes(9, f2);
    }
    f2 = message2.getTrxHash_asU8();
    if (f2.length > 0) {
      writer.writeBytes(10, f2);
    }
    f2 = message2.getVersion();
    if (f2 !== 0) {
      writer.writeInt32(11, f2);
    }
  };
  TronWebProto.SmartContract.ABI.repeatedFields_ = [1];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.SmartContract.ABI.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.SmartContract.ABI.toObject(opt_includeInstance, this);
    };
    TronWebProto.SmartContract.ABI.toObject = function(includeInstance, msg) {
      var obj = {
        entrysList: jspb.Message.toObjectList(
          msg.getEntrysList(),
          TronWebProto.SmartContract.ABI.Entry.toObject,
          includeInstance
        )
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.SmartContract.ABI.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.SmartContract.ABI();
    return TronWebProto.SmartContract.ABI.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.SmartContract.ABI.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = new TronWebProto.SmartContract.ABI.Entry();
          reader.readMessage(value, TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader);
          msg.addEntrys(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.SmartContract.ABI.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.SmartContract.ABI.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.SmartContract.ABI.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getEntrysList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(1, f2, TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter);
    }
  };
  TronWebProto.SmartContract.ABI.Entry.repeatedFields_ = [4, 5];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.SmartContract.ABI.Entry.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.SmartContract.ABI.Entry.toObject(opt_includeInstance, this);
    };
    TronWebProto.SmartContract.ABI.Entry.toObject = function(includeInstance, msg) {
      var obj = {
        anonymous: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
        constant: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
        name: jspb.Message.getFieldWithDefault(msg, 3, ""),
        inputsList: jspb.Message.toObjectList(
          msg.getInputsList(),
          TronWebProto.SmartContract.ABI.Entry.Param.toObject,
          includeInstance
        ),
        outputsList: jspb.Message.toObjectList(
          msg.getOutputsList(),
          TronWebProto.SmartContract.ABI.Entry.Param.toObject,
          includeInstance
        ),
        type: jspb.Message.getFieldWithDefault(msg, 6, 0),
        payable: jspb.Message.getBooleanFieldWithDefault(msg, 7, false),
        statemutability: jspb.Message.getFieldWithDefault(msg, 8, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.SmartContract.ABI.Entry.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.SmartContract.ABI.Entry();
    return TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setAnonymous(value);
          break;
        case 2:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setConstant(value);
          break;
        case 3:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setName(value);
          break;
        case 4:
          var value = new TronWebProto.SmartContract.ABI.Entry.Param();
          reader.readMessage(value, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader);
          msg.addInputs(value);
          break;
        case 5:
          var value = new TronWebProto.SmartContract.ABI.Entry.Param();
          reader.readMessage(value, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader);
          msg.addOutputs(value);
          break;
        case 6:
          var value = (
            /** @type {!TronWebProto.SmartContract.ABI.Entry.EntryType} */
            reader.readEnum()
          );
          msg.setType(value);
          break;
        case 7:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setPayable(value);
          break;
        case 8:
          var value = (
            /** @type {!TronWebProto.SmartContract.ABI.Entry.StateMutabilityType} */
            reader.readEnum()
          );
          msg.setStatemutability(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAnonymous();
    if (f2) {
      writer.writeBool(1, f2);
    }
    f2 = message2.getConstant();
    if (f2) {
      writer.writeBool(2, f2);
    }
    f2 = message2.getName();
    if (f2.length > 0) {
      writer.writeString(3, f2);
    }
    f2 = message2.getInputsList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(4, f2, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter);
    }
    f2 = message2.getOutputsList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(5, f2, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter);
    }
    f2 = message2.getType();
    if (f2 !== 0) {
      writer.writeEnum(6, f2);
    }
    f2 = message2.getPayable();
    if (f2) {
      writer.writeBool(7, f2);
    }
    f2 = message2.getStatemutability();
    if (f2 !== 0) {
      writer.writeEnum(8, f2);
    }
  };
  TronWebProto.SmartContract.ABI.Entry.EntryType = {
    UNKNOWNENTRYTYPE: 0,
    CONSTRUCTOR: 1,
    FUNCTION: 2,
    EVENT: 3,
    FALLBACK: 4,
    RECEIVE: 5,
    ERROR: 6
  };
  TronWebProto.SmartContract.ABI.Entry.StateMutabilityType = {
    UNKNOWNMUTABILITYTYPE: 0,
    PURE: 1,
    VIEW: 2,
    NONPAYABLE: 3,
    PAYABLE: 4
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.SmartContract.ABI.Entry.Param.toObject(opt_includeInstance, this);
    };
    TronWebProto.SmartContract.ABI.Entry.Param.toObject = function(includeInstance, msg) {
      var obj = {
        indexed: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
        name: jspb.Message.getFieldWithDefault(msg, 2, ""),
        type: jspb.Message.getFieldWithDefault(msg, 3, "")
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.SmartContract.ABI.Entry.Param();
    return TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setIndexed(value);
          break;
        case 2:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setName(value);
          break;
        case 3:
          var value = (
            /** @type {string} */
            reader.readString()
          );
          msg.setType(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.SmartContract.ABI.Entry.Param.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getIndexed();
    if (f2) {
      writer.writeBool(1, f2);
    }
    f2 = message2.getName();
    if (f2.length > 0) {
      writer.writeString(2, f2);
    }
    f2 = message2.getType();
    if (f2.length > 0) {
      writer.writeString(3, f2);
    }
  };
  TronWebProto.SmartContract.ABI.Entry.Param.prototype.getIndexed = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 1, false)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.Param.prototype.setIndexed = function(value) {
    return jspb.Message.setProto3BooleanField(this, 1, value);
  };
  TronWebProto.SmartContract.ABI.Entry.Param.prototype.getName = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.SmartContract.ABI.Entry.Param.prototype.setName = function(value) {
    return jspb.Message.setProto3StringField(this, 2, value);
  };
  TronWebProto.SmartContract.ABI.Entry.Param.prototype.getType = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.SmartContract.ABI.Entry.Param.prototype.setType = function(value) {
    return jspb.Message.setProto3StringField(this, 3, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getAnonymous = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 1, false)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setAnonymous = function(value) {
    return jspb.Message.setProto3BooleanField(this, 1, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getConstant = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 2, false)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setConstant = function(value) {
    return jspb.Message.setProto3BooleanField(this, 2, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getName = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setName = function(value) {
    return jspb.Message.setProto3StringField(this, 3, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getInputsList = function() {
    return (
      /** @type{!Array<!TronWebProto.SmartContract.ABI.Entry.Param>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 4)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setInputsList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 4, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.addInputs = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, TronWebProto.SmartContract.ABI.Entry.Param, opt_index);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.clearInputsList = function() {
    return this.setInputsList([]);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getOutputsList = function() {
    return (
      /** @type{!Array<!TronWebProto.SmartContract.ABI.Entry.Param>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 5)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setOutputsList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 5, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.addOutputs = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.SmartContract.ABI.Entry.Param, opt_index);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.clearOutputsList = function() {
    return this.setOutputsList([]);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getType = function() {
    return (
      /** @type {!TronWebProto.SmartContract.ABI.Entry.EntryType} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setType = function(value) {
    return jspb.Message.setProto3EnumField(this, 6, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getPayable = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 7, false)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setPayable = function(value) {
    return jspb.Message.setProto3BooleanField(this, 7, value);
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.getStatemutability = function() {
    return (
      /** @type {!TronWebProto.SmartContract.ABI.Entry.StateMutabilityType} */
      jspb.Message.getFieldWithDefault(this, 8, 0)
    );
  };
  TronWebProto.SmartContract.ABI.Entry.prototype.setStatemutability = function(value) {
    return jspb.Message.setProto3EnumField(this, 8, value);
  };
  TronWebProto.SmartContract.ABI.prototype.getEntrysList = function() {
    return (
      /** @type{!Array<!TronWebProto.SmartContract.ABI.Entry>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry, 1)
    );
  };
  TronWebProto.SmartContract.ABI.prototype.setEntrysList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 1, value);
  };
  TronWebProto.SmartContract.ABI.prototype.addEntrys = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, TronWebProto.SmartContract.ABI.Entry, opt_index);
  };
  TronWebProto.SmartContract.ABI.prototype.clearEntrysList = function() {
    return this.setEntrysList([]);
  };
  TronWebProto.SmartContract.prototype.getOriginAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.SmartContract.prototype.getOriginAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOriginAddress())
    );
  };
  TronWebProto.SmartContract.prototype.getOriginAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOriginAddress())
    );
  };
  TronWebProto.SmartContract.prototype.setOriginAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.SmartContract.prototype.getContractAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.SmartContract.prototype.getContractAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getContractAddress())
    );
  };
  TronWebProto.SmartContract.prototype.getContractAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getContractAddress())
    );
  };
  TronWebProto.SmartContract.prototype.setContractAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.SmartContract.prototype.getAbi = function() {
    return (
      /** @type{?TronWebProto.SmartContract.ABI} */
      jspb.Message.getWrapperField(this, TronWebProto.SmartContract.ABI, 3)
    );
  };
  TronWebProto.SmartContract.prototype.setAbi = function(value) {
    return jspb.Message.setWrapperField(this, 3, value);
  };
  TronWebProto.SmartContract.prototype.clearAbi = function() {
    return this.setAbi(void 0);
  };
  TronWebProto.SmartContract.prototype.hasAbi = function() {
    return jspb.Message.getField(this, 3) != null;
  };
  TronWebProto.SmartContract.prototype.getBytecode = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.SmartContract.prototype.getBytecode_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getBytecode())
    );
  };
  TronWebProto.SmartContract.prototype.getBytecode_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getBytecode())
    );
  };
  TronWebProto.SmartContract.prototype.setBytecode = function(value) {
    return jspb.Message.setProto3BytesField(this, 4, value);
  };
  TronWebProto.SmartContract.prototype.getCallValue = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.SmartContract.prototype.setCallValue = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.SmartContract.prototype.getConsumeUserResourcePercent = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.SmartContract.prototype.setConsumeUserResourcePercent = function(value) {
    return jspb.Message.setProto3IntField(this, 6, value);
  };
  TronWebProto.SmartContract.prototype.getName = function() {
    return (
      /** @type {string} */
      jspb.Message.getFieldWithDefault(this, 7, "")
    );
  };
  TronWebProto.SmartContract.prototype.setName = function(value) {
    return jspb.Message.setProto3StringField(this, 7, value);
  };
  TronWebProto.SmartContract.prototype.getOriginEnergyLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 8, 0)
    );
  };
  TronWebProto.SmartContract.prototype.setOriginEnergyLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 8, value);
  };
  TronWebProto.SmartContract.prototype.getCodeHash = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 9, "")
    );
  };
  TronWebProto.SmartContract.prototype.getCodeHash_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getCodeHash())
    );
  };
  TronWebProto.SmartContract.prototype.getCodeHash_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getCodeHash())
    );
  };
  TronWebProto.SmartContract.prototype.setCodeHash = function(value) {
    return jspb.Message.setProto3BytesField(this, 9, value);
  };
  TronWebProto.SmartContract.prototype.getTrxHash = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 10, "")
    );
  };
  TronWebProto.SmartContract.prototype.getTrxHash_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getTrxHash())
    );
  };
  TronWebProto.SmartContract.prototype.getTrxHash_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getTrxHash())
    );
  };
  TronWebProto.SmartContract.prototype.setTrxHash = function(value) {
    return jspb.Message.setProto3BytesField(this, 10, value);
  };
  TronWebProto.SmartContract.prototype.getVersion = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 11, 0)
    );
  };
  TronWebProto.SmartContract.prototype.setVersion = function(value) {
    return jspb.Message.setProto3IntField(this, 11, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ContractState.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ContractState.toObject(opt_includeInstance, this);
    };
    TronWebProto.ContractState.toObject = function(includeInstance, msg) {
      var obj = {
        energyUsage: jspb.Message.getFieldWithDefault(msg, 1, 0),
        energyFactor: jspb.Message.getFieldWithDefault(msg, 2, 0),
        updateCycle: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ContractState.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ContractState();
    return TronWebProto.ContractState.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ContractState.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setEnergyUsage(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setEnergyFactor(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setUpdateCycle(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ContractState.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ContractState.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ContractState.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getEnergyUsage();
    if (f2 !== 0) {
      writer.writeInt64(1, f2);
    }
    f2 = message2.getEnergyFactor();
    if (f2 !== 0) {
      writer.writeInt64(2, f2);
    }
    f2 = message2.getUpdateCycle();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
  };
  TronWebProto.ContractState.prototype.getEnergyUsage = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 1, 0)
    );
  };
  TronWebProto.ContractState.prototype.setEnergyUsage = function(value) {
    return jspb.Message.setProto3IntField(this, 1, value);
  };
  TronWebProto.ContractState.prototype.getEnergyFactor = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.ContractState.prototype.setEnergyFactor = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.ContractState.prototype.getUpdateCycle = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.ContractState.prototype.setUpdateCycle = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.CreateSmartContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.CreateSmartContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.CreateSmartContract.toObject = function(includeInstance, msg) {
      var f2, obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        newContract: (f2 = msg.getNewContract()) && TronWebProto.SmartContract.toObject(includeInstance, f2),
        callTokenValue: jspb.Message.getFieldWithDefault(msg, 3, 0),
        tokenId: jspb.Message.getFieldWithDefault(msg, 4, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.CreateSmartContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.CreateSmartContract();
    return TronWebProto.CreateSmartContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.CreateSmartContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = new TronWebProto.SmartContract();
          reader.readMessage(value, TronWebProto.SmartContract.deserializeBinaryFromReader);
          msg.setNewContract(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setCallTokenValue(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setTokenId(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.CreateSmartContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.CreateSmartContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.CreateSmartContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getNewContract();
    if (f2 != null) {
      writer.writeMessage(2, f2, TronWebProto.SmartContract.serializeBinaryToWriter);
    }
    f2 = message2.getCallTokenValue();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
    f2 = message2.getTokenId();
    if (f2 !== 0) {
      writer.writeInt64(4, f2);
    }
  };
  TronWebProto.CreateSmartContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.CreateSmartContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.CreateSmartContract.prototype.getNewContract = function() {
    return (
      /** @type{?TronWebProto.SmartContract} */
      jspb.Message.getWrapperField(this, TronWebProto.SmartContract, 2)
    );
  };
  TronWebProto.CreateSmartContract.prototype.setNewContract = function(value) {
    return jspb.Message.setWrapperField(this, 2, value);
  };
  TronWebProto.CreateSmartContract.prototype.clearNewContract = function() {
    return this.setNewContract(void 0);
  };
  TronWebProto.CreateSmartContract.prototype.hasNewContract = function() {
    return jspb.Message.getField(this, 2) != null;
  };
  TronWebProto.CreateSmartContract.prototype.getCallTokenValue = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.CreateSmartContract.prototype.setCallTokenValue = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.CreateSmartContract.prototype.getTokenId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.CreateSmartContract.prototype.setTokenId = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.TriggerSmartContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.TriggerSmartContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.TriggerSmartContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        contractAddress: msg.getContractAddress_asB64(),
        callValue: jspb.Message.getFieldWithDefault(msg, 3, 0),
        data: msg.getData_asB64(),
        callTokenValue: jspb.Message.getFieldWithDefault(msg, 5, 0),
        tokenId: jspb.Message.getFieldWithDefault(msg, 6, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.TriggerSmartContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.TriggerSmartContract();
    return TronWebProto.TriggerSmartContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.TriggerSmartContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setContractAddress(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setCallValue(value);
          break;
        case 4:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setData(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setCallTokenValue(value);
          break;
        case 6:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setTokenId(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.TriggerSmartContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.TriggerSmartContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.TriggerSmartContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getContractAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getCallValue();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
    f2 = message2.getData_asU8();
    if (f2.length > 0) {
      writer.writeBytes(4, f2);
    }
    f2 = message2.getCallTokenValue();
    if (f2 !== 0) {
      writer.writeInt64(5, f2);
    }
    f2 = message2.getTokenId();
    if (f2 !== 0) {
      writer.writeInt64(6, f2);
    }
  };
  TronWebProto.TriggerSmartContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.TriggerSmartContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.TriggerSmartContract.prototype.getContractAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.TriggerSmartContract.prototype.getContractAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getContractAddress())
    );
  };
  TronWebProto.TriggerSmartContract.prototype.getContractAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getContractAddress())
    );
  };
  TronWebProto.TriggerSmartContract.prototype.setContractAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.TriggerSmartContract.prototype.getCallValue = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.TriggerSmartContract.prototype.setCallValue = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.TriggerSmartContract.prototype.getData = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.TriggerSmartContract.prototype.getData_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getData())
    );
  };
  TronWebProto.TriggerSmartContract.prototype.getData_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getData())
    );
  };
  TronWebProto.TriggerSmartContract.prototype.setData = function(value) {
    return jspb.Message.setProto3BytesField(this, 4, value);
  };
  TronWebProto.TriggerSmartContract.prototype.getCallTokenValue = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.TriggerSmartContract.prototype.setCallTokenValue = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  TronWebProto.TriggerSmartContract.prototype.getTokenId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 6, 0)
    );
  };
  TronWebProto.TriggerSmartContract.prototype.setTokenId = function(value) {
    return jspb.Message.setProto3IntField(this, 6, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ClearABIContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ClearABIContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ClearABIContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        contractAddress: msg.getContractAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ClearABIContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ClearABIContract();
    return TronWebProto.ClearABIContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ClearABIContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setContractAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ClearABIContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ClearABIContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ClearABIContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getContractAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
  };
  TronWebProto.ClearABIContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ClearABIContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.ClearABIContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.ClearABIContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ClearABIContract.prototype.getContractAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.ClearABIContract.prototype.getContractAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getContractAddress())
    );
  };
  TronWebProto.ClearABIContract.prototype.getContractAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getContractAddress())
    );
  };
  TronWebProto.ClearABIContract.prototype.setContractAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UpdateSettingContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UpdateSettingContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UpdateSettingContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        contractAddress: msg.getContractAddress_asB64(),
        consumeUserResourcePercent: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UpdateSettingContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UpdateSettingContract();
    return TronWebProto.UpdateSettingContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UpdateSettingContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setContractAddress(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setConsumeUserResourcePercent(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UpdateSettingContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UpdateSettingContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UpdateSettingContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getContractAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getConsumeUserResourcePercent();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
  };
  TronWebProto.UpdateSettingContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.UpdateSettingContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.UpdateSettingContract.prototype.getContractAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.UpdateSettingContract.prototype.getContractAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getContractAddress())
    );
  };
  TronWebProto.UpdateSettingContract.prototype.getContractAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getContractAddress())
    );
  };
  TronWebProto.UpdateSettingContract.prototype.setContractAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.UpdateSettingContract.prototype.getConsumeUserResourcePercent = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.UpdateSettingContract.prototype.setConsumeUserResourcePercent = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UpdateEnergyLimitContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UpdateEnergyLimitContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UpdateEnergyLimitContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        contractAddress: msg.getContractAddress_asB64(),
        originEnergyLimit: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UpdateEnergyLimitContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UpdateEnergyLimitContract();
    return TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setContractAddress(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setOriginEnergyLimit(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getContractAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getOriginEnergyLimit();
    if (f2 !== 0) {
      writer.writeInt64(3, f2);
    }
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getContractAddress())
    );
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getContractAddress())
    );
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.setContractAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.getOriginEnergyLimit = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.UpdateEnergyLimitContract.prototype.setOriginEnergyLimit = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.SmartContractDataWrapper.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.SmartContractDataWrapper.toObject(opt_includeInstance, this);
    };
    TronWebProto.SmartContractDataWrapper.toObject = function(includeInstance, msg) {
      var f2, obj = {
        smartContract: (f2 = msg.getSmartContract()) && TronWebProto.SmartContract.toObject(includeInstance, f2),
        runtimecode: msg.getRuntimecode_asB64(),
        contractState: (f2 = msg.getContractState()) && TronWebProto.ContractState.toObject(includeInstance, f2)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.SmartContractDataWrapper.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.SmartContractDataWrapper();
    return TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = new TronWebProto.SmartContract();
          reader.readMessage(value, TronWebProto.SmartContract.deserializeBinaryFromReader);
          msg.setSmartContract(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setRuntimecode(value);
          break;
        case 3:
          var value = new TronWebProto.ContractState();
          reader.readMessage(value, TronWebProto.ContractState.deserializeBinaryFromReader);
          msg.setContractState(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.SmartContractDataWrapper.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getSmartContract();
    if (f2 != null) {
      writer.writeMessage(1, f2, TronWebProto.SmartContract.serializeBinaryToWriter);
    }
    f2 = message2.getRuntimecode_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getContractState();
    if (f2 != null) {
      writer.writeMessage(3, f2, TronWebProto.ContractState.serializeBinaryToWriter);
    }
  };
  TronWebProto.SmartContractDataWrapper.prototype.getSmartContract = function() {
    return (
      /** @type{?TronWebProto.SmartContract} */
      jspb.Message.getWrapperField(this, TronWebProto.SmartContract, 1)
    );
  };
  TronWebProto.SmartContractDataWrapper.prototype.setSmartContract = function(value) {
    return jspb.Message.setWrapperField(this, 1, value);
  };
  TronWebProto.SmartContractDataWrapper.prototype.clearSmartContract = function() {
    return this.setSmartContract(void 0);
  };
  TronWebProto.SmartContractDataWrapper.prototype.hasSmartContract = function() {
    return jspb.Message.getField(this, 1) != null;
  };
  TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getRuntimecode())
    );
  };
  TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getRuntimecode())
    );
  };
  TronWebProto.SmartContractDataWrapper.prototype.setRuntimecode = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.SmartContractDataWrapper.prototype.getContractState = function() {
    return (
      /** @type{?TronWebProto.ContractState} */
      jspb.Message.getWrapperField(this, TronWebProto.ContractState, 3)
    );
  };
  TronWebProto.SmartContractDataWrapper.prototype.setContractState = function(value) {
    return jspb.Message.setWrapperField(this, 3, value);
  };
  TronWebProto.SmartContractDataWrapper.prototype.clearContractState = function() {
    return this.setContractState(void 0);
  };
  TronWebProto.SmartContractDataWrapper.prototype.hasContractState = function() {
    return jspb.Message.getField(this, 3) != null;
  };
  goog.object.extend(exports, TronWebProto);
})(smart_contract_pb);
var witness_contract_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  goog.exportSymbol("TronWebProto.VoteWitnessContract", null, global2);
  goog.exportSymbol("TronWebProto.VoteWitnessContract.Vote", null, global2);
  goog.exportSymbol("TronWebProto.WitnessCreateContract", null, global2);
  goog.exportSymbol("TronWebProto.WitnessUpdateContract", null, global2);
  TronWebProto.WitnessCreateContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.WitnessCreateContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.WitnessCreateContract.displayName = "TronWebProto.WitnessCreateContract";
  }
  TronWebProto.WitnessUpdateContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.WitnessUpdateContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.WitnessUpdateContract.displayName = "TronWebProto.WitnessUpdateContract";
  }
  TronWebProto.VoteWitnessContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.VoteWitnessContract.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.VoteWitnessContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.VoteWitnessContract.displayName = "TronWebProto.VoteWitnessContract";
  }
  TronWebProto.VoteWitnessContract.Vote = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.VoteWitnessContract.Vote, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.VoteWitnessContract.Vote.displayName = "TronWebProto.VoteWitnessContract.Vote";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.WitnessCreateContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.WitnessCreateContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.WitnessCreateContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        url: msg.getUrl_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.WitnessCreateContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.WitnessCreateContract();
    return TronWebProto.WitnessCreateContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.WitnessCreateContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setUrl(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.WitnessCreateContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.WitnessCreateContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.WitnessCreateContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getUrl_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
  };
  TronWebProto.WitnessCreateContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.WitnessCreateContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.WitnessCreateContract.prototype.getUrl = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.WitnessCreateContract.prototype.getUrl_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getUrl()
      )
    );
  };
  TronWebProto.WitnessCreateContract.prototype.getUrl_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getUrl()
      )
    );
  };
  TronWebProto.WitnessCreateContract.prototype.setUrl = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.WitnessUpdateContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.WitnessUpdateContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.WitnessUpdateContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        updateUrl: msg.getUpdateUrl_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.WitnessUpdateContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.WitnessUpdateContract();
    return TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 12:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setUpdateUrl(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.WitnessUpdateContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.WitnessUpdateContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.WitnessUpdateContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getUpdateUrl_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        12,
        f2
      );
    }
  };
  TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.WitnessUpdateContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 12, "")
    );
  };
  TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getUpdateUrl()
      )
    );
  };
  TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getUpdateUrl()
      )
    );
  };
  TronWebProto.WitnessUpdateContract.prototype.setUpdateUrl = function(value) {
    return jspb.Message.setProto3BytesField(this, 12, value);
  };
  TronWebProto.VoteWitnessContract.repeatedFields_ = [2];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.VoteWitnessContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.VoteWitnessContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.VoteWitnessContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        votesList: jspb.Message.toObjectList(
          msg.getVotesList(),
          TronWebProto.VoteWitnessContract.Vote.toObject,
          includeInstance
        ),
        support: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.VoteWitnessContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.VoteWitnessContract();
    return TronWebProto.VoteWitnessContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.VoteWitnessContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = new TronWebProto.VoteWitnessContract.Vote();
          reader.readMessage(value, TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader);
          msg.addVotes(value);
          break;
        case 3:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setSupport(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.VoteWitnessContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.VoteWitnessContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.VoteWitnessContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getVotesList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(
        2,
        f2,
        TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter
      );
    }
    f2 = message2.getSupport();
    if (f2) {
      writer.writeBool(
        3,
        f2
      );
    }
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.VoteWitnessContract.Vote.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.VoteWitnessContract.Vote.toObject(opt_includeInstance, this);
    };
    TronWebProto.VoteWitnessContract.Vote.toObject = function(includeInstance, msg) {
      var obj = {
        voteAddress: msg.getVoteAddress_asB64(),
        voteCount: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.VoteWitnessContract.Vote.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.VoteWitnessContract.Vote();
    return TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setVoteAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setVoteCount(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.VoteWitnessContract.Vote.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getVoteAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getVoteCount();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getVoteAddress()
      )
    );
  };
  TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getVoteAddress()
      )
    );
  };
  TronWebProto.VoteWitnessContract.Vote.prototype.setVoteAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.VoteWitnessContract.Vote.prototype.getVoteCount = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.VoteWitnessContract.Vote.prototype.setVoteCount = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.VoteWitnessContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.VoteWitnessContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.VoteWitnessContract.prototype.getVotesList = function() {
    return (
      /** @type{!Array<!TronWebProto.VoteWitnessContract.Vote>} */
      jspb.Message.getRepeatedWrapperField(this, TronWebProto.VoteWitnessContract.Vote, 2)
    );
  };
  TronWebProto.VoteWitnessContract.prototype.setVotesList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 2, value);
  };
  TronWebProto.VoteWitnessContract.prototype.addVotes = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, TronWebProto.VoteWitnessContract.Vote, opt_index);
  };
  TronWebProto.VoteWitnessContract.prototype.clearVotesList = function() {
    return this.setVotesList([]);
  };
  TronWebProto.VoteWitnessContract.prototype.getSupport = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 3, false)
    );
  };
  TronWebProto.VoteWitnessContract.prototype.setSupport = function(value) {
    return jspb.Message.setProto3BooleanField(this, 3, value);
  };
  goog.object.extend(exports, TronWebProto);
})(witness_contract_pb);
var storage_contract_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  goog.exportSymbol("TronWebProto.BuyStorageBytesContract", null, global2);
  goog.exportSymbol("TronWebProto.BuyStorageContract", null, global2);
  goog.exportSymbol("TronWebProto.SellStorageContract", null, global2);
  goog.exportSymbol("TronWebProto.UpdateBrokerageContract", null, global2);
  TronWebProto.BuyStorageBytesContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.BuyStorageBytesContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.BuyStorageBytesContract.displayName = "TronWebProto.BuyStorageBytesContract";
  }
  TronWebProto.BuyStorageContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.BuyStorageContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.BuyStorageContract.displayName = "TronWebProto.BuyStorageContract";
  }
  TronWebProto.SellStorageContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.SellStorageContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.SellStorageContract.displayName = "TronWebProto.SellStorageContract";
  }
  TronWebProto.UpdateBrokerageContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.UpdateBrokerageContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.UpdateBrokerageContract.displayName = "TronWebProto.UpdateBrokerageContract";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.BuyStorageBytesContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.BuyStorageBytesContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.BuyStorageBytesContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        bytes: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.BuyStorageBytesContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.BuyStorageBytesContract();
    return TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setBytes(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.BuyStorageBytesContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getBytes();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.BuyStorageBytesContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.BuyStorageBytesContract.prototype.getBytes = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.BuyStorageBytesContract.prototype.setBytes = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.BuyStorageContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.BuyStorageContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.BuyStorageContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        quant: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.BuyStorageContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.BuyStorageContract();
    return TronWebProto.BuyStorageContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.BuyStorageContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setQuant(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.BuyStorageContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.BuyStorageContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.BuyStorageContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getQuant();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.BuyStorageContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.BuyStorageContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.BuyStorageContract.prototype.getQuant = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.BuyStorageContract.prototype.setQuant = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.SellStorageContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.SellStorageContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.SellStorageContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        storageBytes: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.SellStorageContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.SellStorageContract();
    return TronWebProto.SellStorageContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.SellStorageContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setStorageBytes(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.SellStorageContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.SellStorageContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.SellStorageContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getStorageBytes();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.SellStorageContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.SellStorageContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.SellStorageContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.SellStorageContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.SellStorageContract.prototype.getStorageBytes = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.SellStorageContract.prototype.setStorageBytes = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.UpdateBrokerageContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.UpdateBrokerageContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.UpdateBrokerageContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        brokerage: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.UpdateBrokerageContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.UpdateBrokerageContract();
    return TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt32()
          );
          msg.setBrokerage(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.UpdateBrokerageContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getBrokerage();
    if (f2 !== 0) {
      writer.writeInt32(
        2,
        f2
      );
    }
  };
  TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.UpdateBrokerageContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.UpdateBrokerageContract.prototype.getBrokerage = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.UpdateBrokerageContract.prototype.setBrokerage = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  goog.object.extend(exports, TronWebProto);
})(storage_contract_pb);
var account_contract_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  var core_Tron_pb = Tron_pb;
  goog.object.extend(proto, core_Tron_pb);
  goog.exportSymbol("TronWebProto.AccountCreateContract", null, global2);
  goog.exportSymbol("TronWebProto.AccountPermissionUpdateContract", null, global2);
  goog.exportSymbol("TronWebProto.AccountUpdateContract", null, global2);
  goog.exportSymbol("TronWebProto.SetAccountIdContract", null, global2);
  TronWebProto.AccountCreateContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AccountCreateContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountCreateContract.displayName = "TronWebProto.AccountCreateContract";
  }
  TronWebProto.AccountUpdateContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.AccountUpdateContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountUpdateContract.displayName = "TronWebProto.AccountUpdateContract";
  }
  TronWebProto.SetAccountIdContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.SetAccountIdContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.SetAccountIdContract.displayName = "TronWebProto.SetAccountIdContract";
  }
  TronWebProto.AccountPermissionUpdateContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.AccountPermissionUpdateContract.repeatedFields_, null);
  };
  goog.inherits(TronWebProto.AccountPermissionUpdateContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.AccountPermissionUpdateContract.displayName = "TronWebProto.AccountPermissionUpdateContract";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountCreateContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountCreateContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountCreateContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        accountAddress: msg.getAccountAddress_asB64(),
        type: jspb.Message.getFieldWithDefault(msg, 3, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountCreateContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountCreateContract();
    return TronWebProto.AccountCreateContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountCreateContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAccountAddress(value);
          break;
        case 3:
          var value = (
            /** @type {!TronWebProto.AccountType} */
            reader.readEnum()
          );
          msg.setType(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountCreateContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountCreateContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountCreateContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getAccountAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
    f2 = message2.getType();
    if (f2 !== 0) {
      writer.writeEnum(3, f2);
    }
  };
  TronWebProto.AccountCreateContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.AccountCreateContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.AccountCreateContract.prototype.getAccountAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.AccountCreateContract.prototype.getAccountAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getAccountAddress())
    );
  };
  TronWebProto.AccountCreateContract.prototype.getAccountAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getAccountAddress())
    );
  };
  TronWebProto.AccountCreateContract.prototype.setAccountAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.AccountCreateContract.prototype.getType = function() {
    return (
      /** @type {!TronWebProto.AccountType} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.AccountCreateContract.prototype.setType = function(value) {
    return jspb.Message.setProto3EnumField(this, 3, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountUpdateContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountUpdateContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountUpdateContract.toObject = function(includeInstance, msg) {
      var obj = {
        accountName: msg.getAccountName_asB64(),
        ownerAddress: msg.getOwnerAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountUpdateContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountUpdateContract();
    return TronWebProto.AccountUpdateContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountUpdateContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAccountName(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountUpdateContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountUpdateContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountUpdateContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAccountName_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
  };
  TronWebProto.AccountUpdateContract.prototype.getAccountName = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.AccountUpdateContract.prototype.getAccountName_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getAccountName())
    );
  };
  TronWebProto.AccountUpdateContract.prototype.getAccountName_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getAccountName())
    );
  };
  TronWebProto.AccountUpdateContract.prototype.setAccountName = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.AccountUpdateContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.AccountUpdateContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.SetAccountIdContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.SetAccountIdContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.SetAccountIdContract.toObject = function(includeInstance, msg) {
      var obj = {
        accountId: msg.getAccountId_asB64(),
        ownerAddress: msg.getOwnerAddress_asB64()
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.SetAccountIdContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.SetAccountIdContract();
    return TronWebProto.SetAccountIdContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.SetAccountIdContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setAccountId(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.SetAccountIdContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.SetAccountIdContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.SetAccountIdContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getAccountId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(2, f2);
    }
  };
  TronWebProto.SetAccountIdContract.prototype.getAccountId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.SetAccountIdContract.prototype.getAccountId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getAccountId())
    );
  };
  TronWebProto.SetAccountIdContract.prototype.getAccountId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getAccountId())
    );
  };
  TronWebProto.SetAccountIdContract.prototype.setAccountId = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.SetAccountIdContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.SetAccountIdContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.AccountPermissionUpdateContract.repeatedFields_ = [4];
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.AccountPermissionUpdateContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.AccountPermissionUpdateContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.AccountPermissionUpdateContract.toObject = function(includeInstance, msg) {
      var f2, obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        owner: (f2 = msg.getOwner()) && core_Tron_pb.Permission.toObject(includeInstance, f2),
        witness: (f2 = msg.getWitness()) && core_Tron_pb.Permission.toObject(includeInstance, f2),
        activesList: jspb.Message.toObjectList(msg.getActivesList(), core_Tron_pb.Permission.toObject, includeInstance)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.AccountPermissionUpdateContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.AccountPermissionUpdateContract();
    return TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = new core_Tron_pb.Permission();
          reader.readMessage(value, core_Tron_pb.Permission.deserializeBinaryFromReader);
          msg.setOwner(value);
          break;
        case 3:
          var value = new core_Tron_pb.Permission();
          reader.readMessage(value, core_Tron_pb.Permission.deserializeBinaryFromReader);
          msg.setWitness(value);
          break;
        case 4:
          var value = new core_Tron_pb.Permission();
          reader.readMessage(value, core_Tron_pb.Permission.deserializeBinaryFromReader);
          msg.addActives(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(1, f2);
    }
    f2 = message2.getOwner();
    if (f2 != null) {
      writer.writeMessage(2, f2, core_Tron_pb.Permission.serializeBinaryToWriter);
    }
    f2 = message2.getWitness();
    if (f2 != null) {
      writer.writeMessage(3, f2, core_Tron_pb.Permission.serializeBinaryToWriter);
    }
    f2 = message2.getActivesList();
    if (f2.length > 0) {
      writer.writeRepeatedMessage(4, f2, core_Tron_pb.Permission.serializeBinaryToWriter);
    }
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(this.getOwnerAddress())
    );
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(this.getOwnerAddress())
    );
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.getOwner = function() {
    return (
      /** @type{?TronWebProto.Permission} */
      jspb.Message.getWrapperField(this, core_Tron_pb.Permission, 2)
    );
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.setOwner = function(value) {
    return jspb.Message.setWrapperField(this, 2, value);
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.clearOwner = function() {
    return this.setOwner(void 0);
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.hasOwner = function() {
    return jspb.Message.getField(this, 2) != null;
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.getWitness = function() {
    return (
      /** @type{?TronWebProto.Permission} */
      jspb.Message.getWrapperField(this, core_Tron_pb.Permission, 3)
    );
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.setWitness = function(value) {
    return jspb.Message.setWrapperField(this, 3, value);
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.clearWitness = function() {
    return this.setWitness(void 0);
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.hasWitness = function() {
    return jspb.Message.getField(this, 3) != null;
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.getActivesList = function() {
    return (
      /** @type{!Array<!TronWebProto.Permission>} */
      jspb.Message.getRepeatedWrapperField(this, core_Tron_pb.Permission, 4)
    );
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.setActivesList = function(value) {
    return jspb.Message.setRepeatedWrapperField(this, 4, value);
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.addActives = function(opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, TronWebProto.Permission, opt_index);
  };
  TronWebProto.AccountPermissionUpdateContract.prototype.clearActivesList = function() {
    return this.setActivesList([]);
  };
  goog.object.extend(exports, TronWebProto);
})(account_contract_pb);
var proposal_contract_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  goog.exportSymbol("TronWebProto.ProposalApproveContract", null, global2);
  goog.exportSymbol("TronWebProto.ProposalCreateContract", null, global2);
  goog.exportSymbol("TronWebProto.ProposalDeleteContract", null, global2);
  TronWebProto.ProposalApproveContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ProposalApproveContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ProposalApproveContract.displayName = "TronWebProto.ProposalApproveContract";
  }
  TronWebProto.ProposalCreateContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ProposalCreateContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ProposalCreateContract.displayName = "TronWebProto.ProposalCreateContract";
  }
  TronWebProto.ProposalDeleteContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ProposalDeleteContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ProposalDeleteContract.displayName = "TronWebProto.ProposalDeleteContract";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ProposalApproveContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ProposalApproveContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ProposalApproveContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        proposalId: jspb.Message.getFieldWithDefault(msg, 2, 0),
        isAddApproval: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ProposalApproveContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ProposalApproveContract();
    return TronWebProto.ProposalApproveContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ProposalApproveContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setProposalId(value);
          break;
        case 3:
          var value = (
            /** @type {boolean} */
            reader.readBool()
          );
          msg.setIsAddApproval(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ProposalApproveContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ProposalApproveContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ProposalApproveContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getProposalId();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
    f2 = message2.getIsAddApproval();
    if (f2) {
      writer.writeBool(
        3,
        f2
      );
    }
  };
  TronWebProto.ProposalApproveContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ProposalApproveContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ProposalApproveContract.prototype.getProposalId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.ProposalApproveContract.prototype.setProposalId = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.ProposalApproveContract.prototype.getIsAddApproval = function() {
    return (
      /** @type {boolean} */
      jspb.Message.getBooleanFieldWithDefault(this, 3, false)
    );
  };
  TronWebProto.ProposalApproveContract.prototype.setIsAddApproval = function(value) {
    return jspb.Message.setProto3BooleanField(this, 3, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ProposalCreateContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ProposalCreateContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ProposalCreateContract.toObject = function(includeInstance, msg) {
      var f2, obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        parametersMap: (f2 = msg.getParametersMap()) ? f2.toObject(includeInstance, void 0) : []
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ProposalCreateContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ProposalCreateContract();
    return TronWebProto.ProposalCreateContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ProposalCreateContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = msg.getParametersMap();
          reader.readMessage(value, function(message2, reader2) {
            jspb.Map.deserializeBinary(message2, reader2, jspb.BinaryReader.prototype.readInt64, jspb.BinaryReader.prototype.readInt64, null, 0, 0);
          });
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ProposalCreateContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ProposalCreateContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ProposalCreateContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getParametersMap(true);
    if (f2 && f2.getLength() > 0) {
      f2.serializeBinary(2, writer, jspb.BinaryWriter.prototype.writeInt64, jspb.BinaryWriter.prototype.writeInt64);
    }
  };
  TronWebProto.ProposalCreateContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ProposalCreateContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ProposalCreateContract.prototype.getParametersMap = function(opt_noLazyCreate) {
    return (
      /** @type {!jspb.Map<number,number>} */
      jspb.Message.getMapField(
        this,
        2,
        opt_noLazyCreate,
        null
      )
    );
  };
  TronWebProto.ProposalCreateContract.prototype.clearParametersMap = function() {
    this.getParametersMap().clear();
    return this;
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ProposalDeleteContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ProposalDeleteContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ProposalDeleteContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        proposalId: jspb.Message.getFieldWithDefault(msg, 2, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ProposalDeleteContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ProposalDeleteContract();
    return TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setProposalId(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ProposalDeleteContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ProposalDeleteContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ProposalDeleteContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getProposalId();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
  };
  TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ProposalDeleteContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ProposalDeleteContract.prototype.getProposalId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.ProposalDeleteContract.prototype.setProposalId = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  goog.object.extend(exports, TronWebProto);
})(proposal_contract_pb);
var exchange_contract_pb = {};
(function(exports) {
  var jspb = googleProtobuf;
  var goog = jspb;
  var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  goog.exportSymbol("TronWebProto.ExchangeCreateContract", null, global2);
  goog.exportSymbol("TronWebProto.ExchangeInjectContract", null, global2);
  goog.exportSymbol("TronWebProto.ExchangeTransactionContract", null, global2);
  goog.exportSymbol("TronWebProto.ExchangeWithdrawContract", null, global2);
  TronWebProto.ExchangeCreateContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ExchangeCreateContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ExchangeCreateContract.displayName = "TronWebProto.ExchangeCreateContract";
  }
  TronWebProto.ExchangeInjectContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ExchangeInjectContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ExchangeInjectContract.displayName = "TronWebProto.ExchangeInjectContract";
  }
  TronWebProto.ExchangeWithdrawContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ExchangeWithdrawContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ExchangeWithdrawContract.displayName = "TronWebProto.ExchangeWithdrawContract";
  }
  TronWebProto.ExchangeTransactionContract = function(opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
  };
  goog.inherits(TronWebProto.ExchangeTransactionContract, jspb.Message);
  if (goog.DEBUG && !COMPILED) {
    TronWebProto.ExchangeTransactionContract.displayName = "TronWebProto.ExchangeTransactionContract";
  }
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ExchangeCreateContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ExchangeCreateContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ExchangeCreateContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        firstTokenId: msg.getFirstTokenId_asB64(),
        firstTokenBalance: jspb.Message.getFieldWithDefault(msg, 3, 0),
        secondTokenId: msg.getSecondTokenId_asB64(),
        secondTokenBalance: jspb.Message.getFieldWithDefault(msg, 5, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ExchangeCreateContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ExchangeCreateContract();
    return TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setFirstTokenId(value);
          break;
        case 3:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setFirstTokenBalance(value);
          break;
        case 4:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setSecondTokenId(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setSecondTokenBalance(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ExchangeCreateContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ExchangeCreateContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ExchangeCreateContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getFirstTokenId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        2,
        f2
      );
    }
    f2 = message2.getFirstTokenBalance();
    if (f2 !== 0) {
      writer.writeInt64(
        3,
        f2
      );
    }
    f2 = message2.getSecondTokenId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        4,
        f2
      );
    }
    f2 = message2.getSecondTokenBalance();
    if (f2 !== 0) {
      writer.writeInt64(
        5,
        f2
      );
    }
  };
  TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 2, "")
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getFirstTokenId()
      )
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getFirstTokenId()
      )
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.setFirstTokenId = function(value) {
    return jspb.Message.setProto3BytesField(this, 2, value);
  };
  TronWebProto.ExchangeCreateContract.prototype.getFirstTokenBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 3, 0)
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.setFirstTokenBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 3, value);
  };
  TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 4, "")
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getSecondTokenId()
      )
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getSecondTokenId()
      )
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.setSecondTokenId = function(value) {
    return jspb.Message.setProto3BytesField(this, 4, value);
  };
  TronWebProto.ExchangeCreateContract.prototype.getSecondTokenBalance = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.ExchangeCreateContract.prototype.setSecondTokenBalance = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ExchangeInjectContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ExchangeInjectContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ExchangeInjectContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        exchangeId: jspb.Message.getFieldWithDefault(msg, 2, 0),
        tokenId: msg.getTokenId_asB64(),
        quant: jspb.Message.getFieldWithDefault(msg, 4, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ExchangeInjectContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ExchangeInjectContract();
    return TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeId(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setTokenId(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setQuant(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ExchangeInjectContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ExchangeInjectContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ExchangeInjectContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getExchangeId();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
    f2 = message2.getTokenId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getQuant();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
  };
  TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ExchangeInjectContract.prototype.getExchangeId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.setExchangeId = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.ExchangeInjectContract.prototype.getTokenId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.getTokenId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getTokenId()
      )
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.getTokenId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getTokenId()
      )
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.setTokenId = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.ExchangeInjectContract.prototype.getQuant = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.ExchangeInjectContract.prototype.setQuant = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ExchangeWithdrawContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ExchangeWithdrawContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ExchangeWithdrawContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        exchangeId: jspb.Message.getFieldWithDefault(msg, 2, 0),
        tokenId: msg.getTokenId_asB64(),
        quant: jspb.Message.getFieldWithDefault(msg, 4, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ExchangeWithdrawContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ExchangeWithdrawContract();
    return TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeId(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setTokenId(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setQuant(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ExchangeWithdrawContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getExchangeId();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
    f2 = message2.getTokenId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getQuant();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getExchangeId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.setExchangeId = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getTokenId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getTokenId()
      )
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getTokenId()
      )
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.setTokenId = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.ExchangeWithdrawContract.prototype.getQuant = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.ExchangeWithdrawContract.prototype.setQuant = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  if (jspb.Message.GENERATE_TO_OBJECT) {
    TronWebProto.ExchangeTransactionContract.prototype.toObject = function(opt_includeInstance) {
      return TronWebProto.ExchangeTransactionContract.toObject(opt_includeInstance, this);
    };
    TronWebProto.ExchangeTransactionContract.toObject = function(includeInstance, msg) {
      var obj = {
        ownerAddress: msg.getOwnerAddress_asB64(),
        exchangeId: jspb.Message.getFieldWithDefault(msg, 2, 0),
        tokenId: msg.getTokenId_asB64(),
        quant: jspb.Message.getFieldWithDefault(msg, 4, 0),
        expected: jspb.Message.getFieldWithDefault(msg, 5, 0)
      };
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
  }
  TronWebProto.ExchangeTransactionContract.deserializeBinary = function(bytes2) {
    var reader = new jspb.BinaryReader(bytes2);
    var msg = new TronWebProto.ExchangeTransactionContract();
    return TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader(msg, reader);
  };
  TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader = function(msg, reader) {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      var field = reader.getFieldNumber();
      switch (field) {
        case 1:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setOwnerAddress(value);
          break;
        case 2:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExchangeId(value);
          break;
        case 3:
          var value = (
            /** @type {!Uint8Array} */
            reader.readBytes()
          );
          msg.setTokenId(value);
          break;
        case 4:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setQuant(value);
          break;
        case 5:
          var value = (
            /** @type {number} */
            reader.readInt64()
          );
          msg.setExpected(value);
          break;
        default:
          reader.skipField();
          break;
      }
    }
    return msg;
  };
  TronWebProto.ExchangeTransactionContract.prototype.serializeBinary = function() {
    var writer = new jspb.BinaryWriter();
    TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  };
  TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter = function(message2, writer) {
    var f2 = void 0;
    f2 = message2.getOwnerAddress_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        1,
        f2
      );
    }
    f2 = message2.getExchangeId();
    if (f2 !== 0) {
      writer.writeInt64(
        2,
        f2
      );
    }
    f2 = message2.getTokenId_asU8();
    if (f2.length > 0) {
      writer.writeBytes(
        3,
        f2
      );
    }
    f2 = message2.getQuant();
    if (f2 !== 0) {
      writer.writeInt64(
        4,
        f2
      );
    }
    f2 = message2.getExpected();
    if (f2 !== 0) {
      writer.writeInt64(
        5,
        f2
      );
    }
  };
  TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 1, "")
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getOwnerAddress()
      )
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.setOwnerAddress = function(value) {
    return jspb.Message.setProto3BytesField(this, 1, value);
  };
  TronWebProto.ExchangeTransactionContract.prototype.getExchangeId = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 2, 0)
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.setExchangeId = function(value) {
    return jspb.Message.setProto3IntField(this, 2, value);
  };
  TronWebProto.ExchangeTransactionContract.prototype.getTokenId = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      jspb.Message.getFieldWithDefault(this, 3, "")
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asB64 = function() {
    return (
      /** @type {string} */
      jspb.Message.bytesAsB64(
        this.getTokenId()
      )
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      jspb.Message.bytesAsU8(
        this.getTokenId()
      )
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.setTokenId = function(value) {
    return jspb.Message.setProto3BytesField(this, 3, value);
  };
  TronWebProto.ExchangeTransactionContract.prototype.getQuant = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 4, 0)
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.setQuant = function(value) {
    return jspb.Message.setProto3IntField(this, 4, value);
  };
  TronWebProto.ExchangeTransactionContract.prototype.getExpected = function() {
    return (
      /** @type {number} */
      jspb.Message.getFieldWithDefault(this, 5, 0)
    );
  };
  TronWebProto.ExchangeTransactionContract.prototype.setExpected = function(value) {
    return jspb.Message.setProto3IntField(this, 5, value);
  };
  goog.object.extend(exports, TronWebProto);
})(exchange_contract_pb);
const { Transaction: Transaction2, Permission, Key } = globalThis.TronWebProto;
const { TransferContract, FreezeBalanceContract, UnfreezeBalanceContract, WithdrawBalanceContract, FreezeBalanceV2Contract, UnfreezeBalanceV2Contract, WithdrawExpireUnfreezeContract, DelegateResourceContract, UnDelegateResourceContract } = globalThis.TronWebProto;
const { TransferAssetContract, ParticipateAssetIssueContract, AssetIssueContract, UpdateAssetContract } = globalThis.TronWebProto;
const { TriggerSmartContract, ClearABIContract, UpdateEnergyLimitContract, UpdateSettingContract, CreateSmartContract, SmartContract } = globalThis.TronWebProto;
const { ResourceCode: ResourceCode$1 } = globalThis.TronWebProto;
const { WitnessCreateContract, VoteWitnessContract } = globalThis.TronWebProto;
const { UpdateBrokerageContract } = globalThis.TronWebProto;
const { AccountCreateContract, AccountUpdateContract, SetAccountIdContract, AccountPermissionUpdateContract } = globalThis.TronWebProto;
const { ProposalCreateContract, ProposalDeleteContract, ProposalApproveContract } = globalThis.TronWebProto;
const { ExchangeCreateContract, ExchangeInjectContract, ExchangeWithdrawContract, ExchangeTransactionContract } = globalThis.TronWebProto;
const fromHexString = (hexString) => {
  if (!hexString || hexString.length === 0)
    return new Uint8Array([]);
  return new Uint8Array(TronWeb.address.toHex(hexString).match(/.{1,2}/g).map((byte2) => parseInt(byte2, 16)));
};
const stringToUint8Array = (hexString) => {
  if (!hexString || hexString.length === 0)
    return new Uint8Array([]);
  return new Uint8Array((isHex(hexString) ? hexString : TronWeb.toHex(hexString)).replace(/^0x/, "").match(/.{1,2}/g).map((byte2) => parseInt(byte2, 16)));
};
const flexToUint8Array = (str, visible) => {
  if (!visible)
    return stringToUint8Array(str.replace(/^0x/, ""));
  return stringToUint8Array(TronWeb.fromUtf8(str).replace(/^0x/, ""));
};
const sha3$1 = (string2, prefix = true) => {
  return (prefix ? "0x" : "") + keccak256(Buffer.from(string2, "utf-8")).toString().substring(2);
};
const buildCommonTransaction = (message2, contractType, typeName, permissionId) => {
  const anyValue = new google_protobuf_any_pb.Any();
  anyValue.pack(message2.serializeBinary(), "protocol." + typeName);
  const contract = new Transaction2.Contract();
  contract.setType(contractType);
  contract.setParameter(anyValue);
  if (permissionId) {
    contract.setPermissionId(permissionId);
  }
  const raw = new Transaction2.raw();
  raw.addContract(contract);
  const transaction2 = new Transaction2();
  transaction2.setRawData(raw);
  return transaction2;
};
const buildTransferContract = (value, options) => {
  const { to_address, owner_address, amount } = value;
  const transferContract = new TransferContract();
  transferContract.setToAddress(fromHexString(to_address));
  transferContract.setOwnerAddress(fromHexString(owner_address));
  transferContract.setAmount(amount);
  return buildCommonTransaction(transferContract, Transaction2.Contract.ContractType.TRANSFERCONTRACT, "TransferContract", options.Permission_id);
};
const buildTransferAssetContract = (value, options) => {
  const { to_address, owner_address, amount, asset_name } = value;
  const transferContract = new TransferAssetContract();
  transferContract.setToAddress(fromHexString(to_address));
  transferContract.setOwnerAddress(fromHexString(owner_address));
  transferContract.setAssetName(flexToUint8Array(asset_name, options.visible));
  transferContract.setAmount(amount);
  return buildCommonTransaction(transferContract, Transaction2.Contract.ContractType.TRANSFERASSETCONTRACT, "TransferAssetContract", options.Permission_id);
};
const buildParticipateAssetIssueContract = (value, options) => {
  const pbObj = new ParticipateAssetIssueContract();
  pbObj.setToAddress(fromHexString(value.to_address));
  pbObj.setOwnerAddress(fromHexString(value.owner_address));
  pbObj.setAssetName(flexToUint8Array(value.asset_name, options.visible));
  pbObj.setAmount(value.amount);
  return buildCommonTransaction(pbObj, Transaction2.Contract.ContractType.PARTICIPATEASSETISSUECONTRACT, "ParticipateAssetIssueContract", options.Permission_id);
};
const buildTriggerSmartContract = (value, options) => {
  const triggerSmartContract = new TriggerSmartContract();
  const { owner_address, contract_address, parameter = "", function_selector, call_value, call_token_value, token_id, data } = value;
  triggerSmartContract.setOwnerAddress(fromHexString(owner_address));
  triggerSmartContract.setContractAddress(fromHexString(contract_address));
  triggerSmartContract.setCallValue(call_value);
  if (data) {
    triggerSmartContract.setData(stringToUint8Array(data));
  } else if (function_selector) {
    const contractData = sha3$1(function_selector).substring(2, 10) + parameter;
    triggerSmartContract.setData(stringToUint8Array(contractData));
  }
  if (token_id) {
    triggerSmartContract.setTokenId(token_id);
  }
  if (call_token_value) {
    triggerSmartContract.setCallTokenValue(call_token_value);
  }
  return buildCommonTransaction(triggerSmartContract, Transaction2.Contract.ContractType.TRIGGERSMARTCONTRACT, "TriggerSmartContract", options.Permission_id);
};
const buildFreezeBalanceContract = (value, options) => {
  const freezeBalanceContract = new FreezeBalanceContract();
  const { owner_address, frozen_balance, frozen_duration, resource, receiver_address } = value;
  freezeBalanceContract.setOwnerAddress(fromHexString(owner_address));
  freezeBalanceContract.setFrozenBalance(frozen_balance);
  freezeBalanceContract.setFrozenDuration(frozen_duration);
  if (resource) {
    freezeBalanceContract.setResource(ResourceCode$1[resource]);
  }
  if (receiver_address) {
    freezeBalanceContract.setReceiverAddress(fromHexString(receiver_address));
  }
  return buildCommonTransaction(freezeBalanceContract, Transaction2.Contract.ContractType.FREEZEBALANCECONTRACT, "FreezeBalanceContract", options.Permission_id);
};
const buildUnfreezeBalanceContract = (value, options) => {
  const unfreezeBalanceContract = new UnfreezeBalanceContract();
  const { owner_address, resource, receiver_address } = value;
  unfreezeBalanceContract.setOwnerAddress(fromHexString(owner_address));
  if (resource) {
    unfreezeBalanceContract.setResource(ResourceCode$1[resource]);
  }
  if (receiver_address) {
    unfreezeBalanceContract.setReceiverAddress(fromHexString(receiver_address));
  }
  return buildCommonTransaction(unfreezeBalanceContract, Transaction2.Contract.ContractType.UNFREEZEBALANCECONTRACT, "UnfreezeBalanceContract", options.Permission_id);
};
const buildWithdrawBalanceContract = (value, options) => {
  const withdrawbalanceContract = new WithdrawBalanceContract();
  const { owner_address } = value;
  withdrawbalanceContract.setOwnerAddress(fromHexString(owner_address));
  return buildCommonTransaction(withdrawbalanceContract, Transaction2.Contract.ContractType.WITHDRAWBALANCECONTRACT, "WithdrawBalanceContract", options.Permission_id);
};
const buildFreezeBalanceV2Contract = (value, options) => {
  const freezeBalanceV2Contract = new FreezeBalanceV2Contract();
  const { owner_address, frozen_balance, resource } = value;
  freezeBalanceV2Contract.setOwnerAddress(fromHexString(owner_address));
  freezeBalanceV2Contract.setFrozenBalance(frozen_balance);
  freezeBalanceV2Contract.setResource(ResourceCode$1[resource]);
  return buildCommonTransaction(freezeBalanceV2Contract, Transaction2.Contract.ContractType.FREEZEBALANCEV2CONTRACT, "FreezeBalanceV2Contract", options.Permission_id);
};
const buildCancelFreezeBalanceV2Contract = (value, options) => {
  const withdrawExpireUnfreeze = new WithdrawExpireUnfreezeContract();
  const { owner_address } = value;
  withdrawExpireUnfreeze.setOwnerAddress(fromHexString(owner_address));
  return buildCommonTransaction(withdrawExpireUnfreeze, Transaction2.Contract.ContractType.CANCELALLUNFREEZEV2CONTRACT, "CancelAllUnfreezeV2Contract", options.Permission_id);
};
const buildUnfreezeBalanceV2Contract = (value, options) => {
  const unfreezeBalanceV2Contract = new UnfreezeBalanceV2Contract();
  const { owner_address, unfreeze_balance, resource } = value;
  unfreezeBalanceV2Contract.setOwnerAddress(fromHexString(owner_address));
  unfreezeBalanceV2Contract.setUnfreezeBalance(unfreeze_balance);
  unfreezeBalanceV2Contract.setResource(ResourceCode$1[resource]);
  return buildCommonTransaction(unfreezeBalanceV2Contract, Transaction2.Contract.ContractType.UNFREEZEBALANCEV2CONTRACT, "UnfreezeBalanceV2Contract", options.Permission_id);
};
const buildDelegateResourceContract = (value, options) => {
  const delegateResourceContract = new DelegateResourceContract();
  const { owner_address, receiver_address, balance, resource, lock = false, lock_period } = value;
  delegateResourceContract.setOwnerAddress(fromHexString(owner_address));
  delegateResourceContract.setBalance(balance);
  delegateResourceContract.setResource(ResourceCode$1[resource]);
  delegateResourceContract.setLock(lock);
  delegateResourceContract.setLockPeriod(lock_period);
  delegateResourceContract.setReceiverAddress(fromHexString(receiver_address));
  return buildCommonTransaction(delegateResourceContract, Transaction2.Contract.ContractType.DELEGATERESOURCECONTRACT, "DelegateResourceContract", options.Permission_id);
};
const buildUnDelegateResourceContract = (value, options) => {
  const unDelegateResourceContract = new UnDelegateResourceContract();
  const { owner_address, receiver_address, balance, resource } = value;
  unDelegateResourceContract.setOwnerAddress(fromHexString(owner_address));
  unDelegateResourceContract.setBalance(balance);
  unDelegateResourceContract.setResource(ResourceCode$1[resource]);
  unDelegateResourceContract.setReceiverAddress(fromHexString(receiver_address));
  return buildCommonTransaction(unDelegateResourceContract, Transaction2.Contract.ContractType.UNDELEGATERESOURCECONTRACT, "UnDelegateResourceContract", options.Permission_id);
};
const buildWithdrawExpireUnfreezeContract = (value, options) => {
  const withdrawExpireUnfreeze = new WithdrawExpireUnfreezeContract();
  const { owner_address } = value;
  withdrawExpireUnfreeze.setOwnerAddress(fromHexString(owner_address));
  return buildCommonTransaction(withdrawExpireUnfreeze, Transaction2.Contract.ContractType.WITHDRAWEXPIREUNFREEZECONTRACT, "WithdrawExpireUnfreezeContract", options.Permission_id);
};
const buildCreateWitness = (value, options) => {
  const createWitnessContract = new WitnessCreateContract();
  const { owner_address, url } = value;
  createWitnessContract.setOwnerAddress(fromHexString(owner_address));
  createWitnessContract.setUrl(stringToUint8Array(url.replace(/^0x/, "")));
  return buildCommonTransaction(createWitnessContract, Transaction2.Contract.ContractType.WITNESSCREATECONTRACT, "WitnessCreateContract", options.Permission_id);
};
const buildVoteWitnessAccount = (value, options) => {
  const voteWitnessContract = new VoteWitnessContract();
  const { owner_address, votes } = value;
  voteWitnessContract.setOwnerAddress(fromHexString(owner_address));
  votes.forEach((voteItem) => {
    const vote = new VoteWitnessContract.Vote();
    const { vote_address, vote_count } = voteItem;
    vote.setVoteAddress(fromHexString(vote_address));
    const numberOfVotes = parseInt(vote_count);
    vote.setVoteCount(numberOfVotes);
    voteWitnessContract.addVotes(vote);
  });
  return buildCommonTransaction(voteWitnessContract, Transaction2.Contract.ContractType.VOTEWITNESSCONTRACT, "VoteWitnessContract", options.Permission_id);
};
const buildCreateSmartContract = (value, options) => {
  const params = (value == null ? void 0 : value.new_contract) ? {
    ...{
      owner_address: value.owner_address,
      call_token_value: value.call_token_value,
      token_id: value.token_id
    },
    ...value.new_contract
  } : value;
  const { owner_address, consume_user_resource_percent, origin_energy_limit, abi: abi2, bytecode = "", parameter = "", call_value, call_token_value, token_id, name: contracName } = params;
  let { origin_address } = params;
  const createSmartContract = new CreateSmartContract();
  createSmartContract.setOwnerAddress(fromHexString(owner_address));
  if (token_id) {
    createSmartContract.setTokenId(token_id);
  }
  if (call_token_value) {
    createSmartContract.setCallTokenValue(call_token_value);
  }
  const smartContractBuilder = new SmartContract();
  if (abi2) {
    let abiJson;
    if (typeof abi2 === "string") {
      abiJson = JSON.parse(abi2);
    } else {
      abiJson = (abi2 == null ? void 0 : abi2.entrys) || [];
    }
    const abiBuilder = new SmartContract.ABI();
    const buildEntryParam = (data) => {
      const param = new SmartContract.ABI.Entry.Param();
      const { indexed, name, type: type2 } = data;
      if (indexed === true) {
        param.setIndexed(true);
      }
      param.setName(name);
      param.setType(type2);
      return param;
    };
    const entryBuilders = abiJson.map((entry) => {
      const { anonymous, constant, name, inputs, outputs, type: type2, payable, stateMutability } = entry;
      const entryBuilder = new SmartContract.ABI.Entry();
      entryBuilder.setAnonymous(anonymous);
      entryBuilder.setConstant(constant);
      entryBuilder.setName(name);
      if (inputs) {
        entryBuilder.setInputsList(inputs.map((input) => buildEntryParam(input)));
      }
      if (outputs) {
        entryBuilder.setOutputsList(outputs.map((output2) => buildEntryParam(output2)));
      }
      if (type2) {
        entryBuilder.setType(SmartContract.ABI.Entry.EntryType[type2.toUpperCase()]);
      }
      entryBuilder.setPayable(payable);
      if (stateMutability) {
        entryBuilder.setStatemutability(SmartContract.ABI.Entry.StateMutabilityType[stateMutability.toUpperCase()]);
      }
      return entryBuilder;
    });
    abiBuilder.setEntrysList(entryBuilders);
    smartContractBuilder.setAbi(abiBuilder);
  }
  if (call_value) {
    smartContractBuilder.setCallValue(call_value);
  }
  smartContractBuilder.setConsumeUserResourcePercent(consume_user_resource_percent);
  smartContractBuilder.setOriginEnergyLimit(origin_energy_limit);
  if (!origin_address) {
    origin_address = owner_address;
  }
  smartContractBuilder.setOriginAddress(fromHexString(origin_address));
  if (bytecode) {
    const bytecodeParameter = bytecode.replace(/^0x/, "") + parameter.replace(/^0x/, "");
    smartContractBuilder.setBytecode(stringToUint8Array(bytecodeParameter));
  }
  smartContractBuilder.setName(contracName);
  createSmartContract.setNewContract(smartContractBuilder);
  return buildCommonTransaction(createSmartContract, Transaction2.Contract.ContractType.CREATESMARTCONTRACT, "CreateSmartContract", options.Permission_id);
};
const buildClearABIContract = (value, options) => {
  const { contract_address, owner_address } = value;
  const clearABIContract = new ClearABIContract();
  clearABIContract.setOwnerAddress(fromHexString(owner_address));
  clearABIContract.setContractAddress(fromHexString(contract_address));
  return buildCommonTransaction(clearABIContract, Transaction2.Contract.ContractType.CLEARABICONTRACT, "ClearABIContract", options.Permission_id);
};
const buildUpdateBrokerageContract = (value, options) => {
  const { brokerage, owner_address } = value;
  const updateBrokerageContract = new UpdateBrokerageContract();
  updateBrokerageContract.setOwnerAddress(fromHexString(owner_address));
  updateBrokerageContract.setBrokerage(brokerage);
  return buildCommonTransaction(updateBrokerageContract, Transaction2.Contract.ContractType.UPDATEBROKERAGECONTRACT, "UpdateBrokerageContract", options.Permission_id);
};
const buildAssetIssueContract = (value, options) => {
  const { owner_address, name, abbr, description, url, total_supply, trx_num, num, start_time, end_time, precision, free_asset_net_limit, public_free_asset_net_limit, public_free_asset_net_usage = 0, public_latest_free_net_time = 0, vote_score = 0, frozen_supply } = value;
  const assetIssueContract = new AssetIssueContract();
  assetIssueContract.setOwnerAddress(fromHexString(owner_address));
  if (name) {
    assetIssueContract.setName(stringToUint8Array(name.replace(/^0x/, "")));
  }
  if (abbr) {
    assetIssueContract.setAbbr(stringToUint8Array(abbr.replace(/^0x/, "")));
  }
  assetIssueContract.setTotalSupply(total_supply);
  assetIssueContract.setNum(num);
  assetIssueContract.setEndTime(end_time);
  assetIssueContract.setStartTime(start_time);
  assetIssueContract.setTrxNum(trx_num);
  assetIssueContract.setVoteScore(vote_score);
  if (precision) {
    assetIssueContract.setPrecision(precision);
  }
  if (public_latest_free_net_time) {
    assetIssueContract.setPublicLatestFreeNetTime(public_latest_free_net_time);
  }
  if (description) {
    assetIssueContract.setDescription(stringToUint8Array(description.replace(/^0x/, "")));
  }
  if (url) {
    assetIssueContract.setUrl(stringToUint8Array(url.replace(/^0x/, "")));
  }
  assetIssueContract.setPublicFreeAssetNetUsage(public_free_asset_net_usage);
  assetIssueContract.setFreeAssetNetLimit(free_asset_net_limit);
  assetIssueContract.setPublicFreeAssetNetLimit(public_free_asset_net_limit);
  if (frozen_supply) {
    const frozenSupplyContract = new AssetIssueContract.FrozenSupply();
    frozenSupplyContract.setFrozenAmount(frozen_supply.length ? frozen_supply[0].frozen_amount : frozen_supply.frozen_amount);
    frozenSupplyContract.setFrozenDays(frozen_supply.length ? frozen_supply[0].frozen_days : frozen_supply.frozen_days);
    assetIssueContract.addFrozenSupply(frozenSupplyContract);
  }
  return buildCommonTransaction(assetIssueContract, Transaction2.Contract.ContractType.ASSETISSUECONTRACT, "AssetIssueContract", options.Permission_id);
};
const buildAccountCreateContract = (value, options) => {
  const accountCreateContract = new AccountCreateContract();
  const { account_address, owner_address } = value;
  accountCreateContract.setOwnerAddress(fromHexString(owner_address));
  accountCreateContract.setAccountAddress(fromHexString(account_address.replace(/^0x/, "")));
  return buildCommonTransaction(accountCreateContract, Transaction2.Contract.ContractType.ACCOUNTCREATECONTRACT, "AccountCreateContract", options.Permission_id);
};
const buildAccountUpdateContract = (value, options) => {
  const accountUpdateContract = new AccountUpdateContract();
  const { account_name, owner_address } = value;
  accountUpdateContract.setOwnerAddress(fromHexString(owner_address));
  accountUpdateContract.setAccountName(stringToUint8Array(account_name.replace(/^0x/, "")));
  return buildCommonTransaction(accountUpdateContract, Transaction2.Contract.ContractType.ACCOUNTUPDATECONTRACT, "AccountUpdateContract", options.Permission_id);
};
const buildSetAccountIdContract = (value, options) => {
  const setAccountIdContract = new SetAccountIdContract();
  const { account_id, owner_address } = value;
  setAccountIdContract.setOwnerAddress(fromHexString(owner_address));
  setAccountIdContract.setAccountId(stringToUint8Array(account_id.replace(/^0x/, "")));
  return buildCommonTransaction(setAccountIdContract, Transaction2.Contract.ContractType.SETACCOUNTIDCONTRACT, "SetAccountIdContract", options.Permission_id);
};
const buildProposalCreateContract = (value, options) => {
  const proposalCreateContract = new ProposalCreateContract();
  const { owner_address, parameters } = value;
  proposalCreateContract.setOwnerAddress(fromHexString(owner_address));
  parameters.forEach((parameter) => {
    proposalCreateContract.getParametersMap().set(parameter.key, parameter.value);
  });
  return buildCommonTransaction(proposalCreateContract, Transaction2.Contract.ContractType.PROPOSALCREATECONTRACT, "ProposalCreateContract", options.Permission_id);
};
const buildProposalDeleteContract = (value, options) => {
  const proposalDeleteContract = new ProposalDeleteContract();
  const { owner_address, proposal_id } = value;
  proposalDeleteContract.setOwnerAddress(fromHexString(owner_address));
  proposalDeleteContract.setProposalId(proposal_id);
  return buildCommonTransaction(proposalDeleteContract, Transaction2.Contract.ContractType.PROPOSALDELETECONTRACT, "ProposalDeleteContract", options.Permission_id);
};
const buildVoteProposalContract = (value, options) => {
  const proposalVoteContract = new ProposalApproveContract();
  const { owner_address, proposal_id, is_add_approval } = value;
  proposalVoteContract.setOwnerAddress(fromHexString(owner_address));
  proposalVoteContract.setProposalId(proposal_id);
  proposalVoteContract.setIsAddApproval(is_add_approval);
  return buildCommonTransaction(proposalVoteContract, Transaction2.Contract.ContractType.PROPOSALAPPROVECONTRACT, "ProposalApproveContract", options.Permission_id);
};
const buildExchangeCreateContract = (value, options) => {
  const exchangeCreateContract = new ExchangeCreateContract();
  const { owner_address, first_token_id, first_token_balance, second_token_id, second_token_balance } = value;
  exchangeCreateContract.setOwnerAddress(fromHexString(owner_address));
  exchangeCreateContract.setFirstTokenId(flexToUint8Array(first_token_id, options.visible));
  exchangeCreateContract.setFirstTokenBalance(first_token_balance);
  exchangeCreateContract.setSecondTokenId(flexToUint8Array(second_token_id, options.visible));
  exchangeCreateContract.setSecondTokenBalance(second_token_balance);
  return buildCommonTransaction(exchangeCreateContract, Transaction2.Contract.ContractType.EXCHANGECREATECONTRACT, "ExchangeCreateContract", options.Permission_id);
};
const buildExchangeInjectContract = (value, options) => {
  const exchangeInjectContract = new ExchangeInjectContract();
  const { owner_address, exchange_id, token_id, quant } = value;
  exchangeInjectContract.setOwnerAddress(fromHexString(owner_address));
  exchangeInjectContract.setExchangeId(exchange_id);
  exchangeInjectContract.setTokenId(flexToUint8Array(token_id, options.visible));
  exchangeInjectContract.setQuant(quant);
  return buildCommonTransaction(exchangeInjectContract, Transaction2.Contract.ContractType.EXCHANGEINJECTCONTRACT, "ExchangeInjectContract", options.Permission_id);
};
const buildExchangeWithdrawContract = (value, options) => {
  const exchangeWithdrawContract = new ExchangeWithdrawContract();
  const { owner_address, exchange_id, token_id, quant } = value;
  exchangeWithdrawContract.setOwnerAddress(fromHexString(owner_address));
  exchangeWithdrawContract.setExchangeId(exchange_id);
  exchangeWithdrawContract.setTokenId(flexToUint8Array(token_id, options.visible));
  exchangeWithdrawContract.setQuant(quant);
  return buildCommonTransaction(exchangeWithdrawContract, Transaction2.Contract.ContractType.EXCHANGEWITHDRAWCONTRACT, "ExchangeWithdrawContract", options.Permission_id);
};
const buildExchangeTransactionContract = (value, options) => {
  const exchangeTransactionContract = new ExchangeTransactionContract();
  const { owner_address, exchange_id, token_id, quant, expected } = value;
  exchangeTransactionContract.setOwnerAddress(fromHexString(owner_address));
  exchangeTransactionContract.setExchangeId(exchange_id);
  exchangeTransactionContract.setTokenId(flexToUint8Array(token_id, options.visible));
  exchangeTransactionContract.setQuant(quant);
  exchangeTransactionContract.setExpected(expected);
  return buildCommonTransaction(exchangeTransactionContract, Transaction2.Contract.ContractType.EXCHANGETRANSACTIONCONTRACT, "ExchangeTransactionContract", options.Permission_id);
};
const buildUpdateSettingContract = (value, options) => {
  const updateSettingContract = new UpdateSettingContract();
  const { owner_address, contract_address, consume_user_resource_percent } = value;
  updateSettingContract.setOwnerAddress(fromHexString(owner_address));
  updateSettingContract.setContractAddress(fromHexString(contract_address));
  updateSettingContract.setConsumeUserResourcePercent(consume_user_resource_percent);
  return buildCommonTransaction(updateSettingContract, Transaction2.Contract.ContractType.UPDATESETTINGCONTRACT, "UpdateSettingContract", options.Permission_id);
};
const buildUpdateEnergyLimitContract = (value, options) => {
  const updateEnergyLimitContract = new UpdateEnergyLimitContract();
  const { owner_address, contract_address, origin_energy_limit } = value;
  updateEnergyLimitContract.setOwnerAddress(fromHexString(owner_address));
  updateEnergyLimitContract.setContractAddress(fromHexString(contract_address));
  updateEnergyLimitContract.setOriginEnergyLimit(origin_energy_limit);
  return buildCommonTransaction(updateEnergyLimitContract, Transaction2.Contract.ContractType.UPDATEENERGYLIMITCONTRACT, "UpdateEnergyLimitContract", options.Permission_id);
};
const buildAccountPermissionUpdateContract = (value, options) => {
  const accountPermissionUpdateContract = new AccountPermissionUpdateContract();
  const { owner_address, owner, witness, actives } = value;
  accountPermissionUpdateContract.setOwnerAddress(fromHexString(owner_address));
  const getType = (type2) => {
    if (isNaN(type2))
      return type2 === "Active" ? 2 : type2 === "Witness" ? 1 : 0;
    return type2;
  };
  const buildPermission = (data) => {
    const permission = new Permission();
    const { type: type2, id: id2, permission_name, threshold, parentId, operations, keys } = data;
    permission.setType(getType(type2));
    permission.setId(id2);
    permission.setPermissionName(permission_name);
    permission.setThreshold(threshold);
    if (parentId) {
      permission.setParentId(parentId);
    }
    if (operations) {
      permission.setOperations(stringToUint8Array(operations));
    }
    if (keys) {
      permission.setKeysList(keys.map((key) => {
        const keyBuilder = new Key();
        keyBuilder.setAddress(fromHexString(key.address));
        keyBuilder.setWeight(key.weight);
        return keyBuilder;
      }));
    }
    return permission;
  };
  if (owner) {
    accountPermissionUpdateContract.setOwner(buildPermission(owner));
  }
  if (witness) {
    accountPermissionUpdateContract.setWitness(buildPermission(witness));
  }
  if (actives) {
    if (Array.isArray(actives)) {
      accountPermissionUpdateContract.setActivesList(actives.map((active) => buildPermission(active)));
    } else {
      accountPermissionUpdateContract.setActivesList([buildPermission(actives)]);
    }
  }
  return buildCommonTransaction(accountPermissionUpdateContract, Transaction2.Contract.ContractType.ACCOUNTPERMISSIONUPDATECONTRACT, "AccountPermissionUpdateContract", options.Permission_id);
};
const buildUpdateAssetContract = (value, options) => {
  const updateAssetContract = new UpdateAssetContract();
  const { owner_address, description, url, new_limit, new_public_limit } = value;
  updateAssetContract.setOwnerAddress(fromHexString(owner_address));
  if (description) {
    updateAssetContract.setDescription(stringToUint8Array(description.replace(/^0x/, "")));
  }
  if (url) {
    updateAssetContract.setUrl(stringToUint8Array(url.replace(/^0x/, "")));
  }
  if (new_limit) {
    updateAssetContract.setNewLimit(new_limit);
  }
  if (new_public_limit) {
    updateAssetContract.setNewPublicLimit(new_public_limit);
  }
  return buildCommonTransaction(updateAssetContract, Transaction2.Contract.ContractType.UPDATEASSETCONTRACT, "UpdateAssetContract", options.Permission_id);
};
const contractJsonToProtobuf = (contract, value, options) => {
  switch (contract.type) {
    case "TransferContract":
      return buildTransferContract(value, options);
    case "TransferAssetContract":
      return buildTransferAssetContract(value, options);
    case "ParticipateAssetIssueContract":
      return buildParticipateAssetIssueContract(value, options);
    case "TriggerSmartContract":
      return buildTriggerSmartContract(value, options);
    case "FreezeBalanceContract":
      return buildFreezeBalanceContract(value, options);
    case "UnfreezeBalanceContract":
      return buildUnfreezeBalanceContract(value, options);
    case "WithdrawBalanceContract":
      return buildWithdrawBalanceContract(value, options);
    case "FreezeBalanceV2Contract":
      return buildFreezeBalanceV2Contract(value, options);
    case "CancelAllUnfreezeV2Contract":
      return buildCancelFreezeBalanceV2Contract(value, options);
    case "UnfreezeBalanceV2Contract":
      return buildUnfreezeBalanceV2Contract(value, options);
    case "DelegateResourceContract":
      return buildDelegateResourceContract(value, options);
    case "UnDelegateResourceContract":
      return buildUnDelegateResourceContract(value, options);
    case "WithdrawExpireUnfreezeContract":
      return buildWithdrawExpireUnfreezeContract(value, options);
    case "WitnessCreateContract":
      return buildCreateWitness(value, options);
    case "VoteWitnessContract":
      return buildVoteWitnessAccount(value, options);
    case "CreateSmartContract":
      return buildCreateSmartContract(value, options);
    case "ClearABIContract":
      return buildClearABIContract(value, options);
    case "UpdateBrokerageContract":
      return buildUpdateBrokerageContract(value, options);
    case "AssetIssueContract":
      return buildAssetIssueContract(value, options);
    case "AccountCreateContract":
      return buildAccountCreateContract(value, options);
    case "AccountUpdateContract":
      return buildAccountUpdateContract(value, options);
    case "SetAccountIdContract":
      return buildSetAccountIdContract(value, options);
    case "ProposalCreateContract":
      return buildProposalCreateContract(value, options);
    case "ProposalDeleteContract":
      return buildProposalDeleteContract(value, options);
    case "ProposalApproveContract":
      return buildVoteProposalContract(value, options);
    case "ExchangeCreateContract":
      return buildExchangeCreateContract(value, options);
    case "ExchangeInjectContract":
      return buildExchangeInjectContract(value, options);
    case "ExchangeWithdrawContract":
      return buildExchangeWithdrawContract(value, options);
    case "ExchangeTransactionContract":
      return buildExchangeTransactionContract(value, options);
    case "UpdateSettingContract":
      return buildUpdateSettingContract(value, options);
    case "UpdateEnergyLimitContract":
      return buildUpdateEnergyLimitContract(value, options);
    case "AccountPermissionUpdateContract":
      return buildAccountPermissionUpdateContract(value, options);
    case "UpdateAssetContract":
      return buildUpdateAssetContract(value, options);
  }
};
const txJsonToPb = (transaction2) => {
  const rawData = transaction2["raw_data"];
  const contractJson = rawData.contract[0];
  const data = contractJson.parameter.value;
  const options = { Permission_id: contractJson.Permission_id, visible: transaction2.visible };
  const transactionObj = contractJsonToProtobuf(contractJson, data, options);
  const rawDataObj = transactionObj.getRawData();
  rawDataObj.setRefBlockBytes(stringToUint8Array(rawData.ref_block_bytes));
  rawDataObj.setRefBlockHash(stringToUint8Array(rawData.ref_block_hash));
  if (rawData.data) {
    rawDataObj.setData(stringToUint8Array(rawData.data));
  }
  if (rawData.fee_limit) {
    rawDataObj.setFeeLimit(rawData.fee_limit);
  }
  if (rawData.expiration) {
    rawDataObj.setExpiration(rawData.expiration);
  }
  if (rawData.timestamp) {
    rawDataObj.setTimestamp(rawData.timestamp);
  }
  transactionObj.setRawData(rawDataObj);
  return transactionObj;
};
const txJsonToPbWithArgs = (transaction2, args = {}, options = {}) => {
  const rawData = transaction2["raw_data"];
  const contractJson = rawData.contract[0];
  const transactionObj = contractJsonToProtobuf(contractJson, args, {
    Permission_id: args == null ? void 0 : args.Permission_id
  });
  const rawDataObj = transactionObj.getRawData();
  rawDataObj.setRefBlockBytes(stringToUint8Array(rawData.ref_block_bytes));
  rawDataObj.setRefBlockHash(stringToUint8Array(rawData.ref_block_hash));
  if (options.data) {
    rawDataObj.setData(stringToUint8Array(options.data.replace(/^0x/, "")));
  }
  if (options.fee_limit || args.fee_limit) {
    rawDataObj.setFeeLimit(options.fee_limit || args.fee_limit);
  }
  if (rawData.expiration) {
    rawDataObj.setExpiration(rawData.expiration);
  }
  if (rawData.timestamp) {
    rawDataObj.setTimestamp(rawData.timestamp);
  }
  transactionObj.setRawData(rawDataObj);
  return transactionObj;
};
const compareTransaction = (transaction2, transactionPb) => {
  const rawDataBytes = transactionPb.getRawData().serializeBinary();
  const rawDataHex = byteArray2hexStr(rawDataBytes);
  const txID = sha256$1(rawDataBytes);
  return rawDataHex.toLowerCase() === transaction2.raw_data_hex.toLowerCase() && txID.replace(/^0x/, "").toLowerCase() === transaction2.txID.replace(/^0x/, "").toLowerCase();
};
const txPbToRawDataHex = (pb2) => {
  return byteArray2hexStr(pb2.getRawData().serializeBinary());
};
const txCheck = (transaction2) => {
  const transactionPb = txJsonToPb(transaction2);
  return compareTransaction(transaction2, transactionPb);
};
const txCheckWithArgs = (transaction2, args, options) => {
  const transactionPb = txJsonToPbWithArgs(transaction2, args, options);
  return compareTransaction(transaction2, transactionPb);
};
const txPbToTxID = (transactionPb) => {
  const rawDataBytes = transactionPb.getRawData().serializeBinary();
  const txID = sha256$1(rawDataBytes);
  return txID;
};
const transaction = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  txCheck,
  txCheckWithArgs,
  txJsonToPb,
  txJsonToPbWithArgs,
  txPbToRawDataHex,
  txPbToTxID
}, Symbol.toStringTag, { value: "Module" }));
function fromUtf8(value) {
  return TronWeb.fromUtf8(value).replace(/^0x/, "");
}
function deepCopyJson(json) {
  return JSON.parse(JSON.stringify(json));
}
function resultManager(transaction2, data, options) {
  if (transaction2.Error)
    throw new Error(transaction2.Error);
  if (transaction2.result && transaction2.result.message) {
    throw new Error(TronWeb.toUtf8(transaction2.result.message));
  }
  const authResult = txCheckWithArgs(transaction2, data, options);
  if (authResult) {
    return transaction2;
  }
  throw new Error("Invalid transaction");
}
function resultManagerTriggerSmartContract(transaction2, data, options) {
  if (transaction2.Error)
    throw new Error(transaction2.Error);
  if (transaction2.result && transaction2.result.message) {
    throw new Error(TronWeb.toUtf8(transaction2.result.message));
  }
  if (!(options._isConstant || options.estimateEnergy)) {
    const authResult = txCheckWithArgs(transaction2.transaction, data, options);
    if (authResult) {
      return transaction2;
    }
    throw new Error("Invalid transaction");
  }
  return transaction2;
}
function genContractAddress(ownerAddress, txID) {
  return "41" + keccak256(Buffer.from(txID + ownerAddress, "hex")).toString().substring(2).slice(24);
}
function getHeaderInfo(node) {
  return node.request("wallet/getblock", { detail: false }, "post").then((data) => {
    return {
      ref_block_bytes: data.block_header.raw_data.number.toString(16).slice(-4).padStart(4, "0"),
      ref_block_hash: data.blockID.slice(16, 32),
      expiration: data.block_header.raw_data.timestamp + 60 * 1e3,
      timestamp: data.block_header.raw_data.timestamp
    };
  });
}
function checkBlockHeader(options = {}) {
  if (typeof options["ref_block_bytes"] === "undefined" && typeof options["ref_block_hash"] === "undefined" && typeof options["expiration"] === "undefined" && typeof options["timestamp"] === "undefined") {
    return false;
  }
  if (typeof options["ref_block_bytes"] !== "string") {
    throw new Error("Invalid ref_block_bytes provided.");
  }
  if (typeof options["ref_block_hash"] !== "string") {
    throw new Error("Invalid ref_block_hash provided.");
  }
  if (typeof options["expiration"] !== "number") {
    throw new Error("Invalid expiration provided.");
  }
  if (typeof options["timestamp"] !== "number") {
    throw new Error("Invalid timestamp provided.");
  }
  return true;
}
async function createTransaction(tronWeb, type2, value, Permission_id, options = {}) {
  const tx = {
    visible: false,
    txID: "",
    raw_data_hex: "",
    raw_data: {
      contract: [
        {
          parameter: {
            value,
            type_url: `type.googleapis.com/protocol.${type2}`
          },
          type: type2
        }
      ],
      ...checkBlockHeader(options) ? {} : await getHeaderInfo(tronWeb.fullNode),
      ...options
    }
  };
  if (Permission_id) {
    tx.raw_data.contract[0].Permission_id = Permission_id;
  }
  const pb2 = txJsonToPb(tx);
  tx.txID = txPbToTxID(pb2).replace(/^0x/, "");
  tx.raw_data_hex = txPbToRawDataHex(pb2).toLowerCase();
  return tx;
}
function getTransactionOptions(options = {}) {
  const ret = {};
  if (checkBlockHeader(options.blockHeader)) {
    ret["ref_block_bytes"] = options.blockHeader["ref_block_bytes"];
    ret["ref_block_hash"] = options.blockHeader["ref_block_hash"];
    ret["expiration"] = options.blockHeader["expiration"];
    ret["timestamp"] = options.blockHeader["timestamp"];
  }
  return ret;
}
class TransactionBuilder {
  constructor(tronWeb) {
    __publicField(this, "tronWeb");
    __publicField(this, "validator");
    if (!tronWeb || !(tronWeb instanceof TronWeb)) {
      throw new Error("Expected instance of TronWeb");
    }
    this.tronWeb = tronWeb;
    this.validator = new Validator();
  }
  async sendTrx(to, amount = 0, from = this.tronWeb.defaultAddress.hex, options = {}) {
    amount = parseInt(amount);
    this.validator.notValid([
      {
        name: "recipient",
        type: "address",
        value: to
      },
      {
        name: "origin",
        type: "address",
        value: from
      },
      {
        names: ["recipient", "origin"],
        type: "notEqual",
        msg: "Cannot transfer TRX to the same account"
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      }
    ]);
    const data = {
      to_address: toHex$1(to),
      owner_address: toHex$1(from),
      amount
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.TransferContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async sendToken(to, amount = 0, tokenId, from = this.tronWeb.defaultAddress.hex, options = {}) {
    amount = parseInt(amount);
    this.validator.notValid([
      {
        name: "recipient",
        type: "address",
        value: to
      },
      {
        name: "origin",
        type: "address",
        value: from
      },
      {
        names: ["recipient", "origin"],
        type: "notEqual",
        msg: "Cannot transfer tokens to the same account"
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "token ID",
        type: "tokenId",
        value: tokenId
      }
    ]);
    const data = {
      to_address: toHex$1(to),
      owner_address: toHex$1(from),
      asset_name: fromUtf8(tokenId),
      amount
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.TransferAssetContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async purchaseToken(issuerAddress, tokenId, amount = 0, buyer = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "buyer",
        type: "address",
        value: buyer
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        names: ["buyer", "issuer"],
        type: "notEqual",
        msg: "Cannot purchase tokens from same account"
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "token ID",
        type: "tokenId",
        value: tokenId
      }
    ]);
    const data = {
      to_address: toHex$1(issuerAddress),
      owner_address: toHex$1(buyer),
      asset_name: fromUtf8(tokenId),
      amount: parseInt(amount)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ParticipateAssetIssueContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async freezeBalance(amount = 0, duration = 3, resource = "BANDWIDTH", ownerAddress = this.tronWeb.defaultAddress.hex, receiverAddress, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: ownerAddress
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress,
        optional: true
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "duration",
        type: "integer",
        gte: 3,
        value: duration
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      frozen_balance: parseInt(amount),
      frozen_duration: parseInt(String(duration))
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    if (isNotNullOrUndefined(receiverAddress) && toHex$1(receiverAddress) !== toHex$1(ownerAddress)) {
      data.receiver_address = toHex$1(receiverAddress);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.FreezeBalanceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async unfreezeBalance(resource = "BANDWIDTH", address2 = this.tronWeb.defaultAddress.hex, receiverAddress, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress,
        optional: true
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex$1(address2)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    if (isNotNullOrUndefined(receiverAddress) && toHex$1(receiverAddress) !== toHex$1(address2)) {
      data.receiver_address = toHex$1(receiverAddress);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UnfreezeBalanceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async freezeBalanceV2(amount = 0, resource = "BANDWIDTH", address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex$1(address2),
      frozen_balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.FreezeBalanceV2Contract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async unfreezeBalanceV2(amount = 0, resource = "BANDWIDTH", address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex$1(address2),
      unfreeze_balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UnfreezeBalanceV2Contract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async cancelUnfreezeBalanceV2(address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      owner_address: toHex$1(address2)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.CancelAllUnfreezeV2Contract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async delegateResource(amount = 0, receiverAddress, resource = "BANDWIDTH", address2 = this.tronWeb.defaultAddress.hex, lock = false, lockPeriod, options = {}) {
    this.validator.notValid([
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress
      },
      {
        name: "origin",
        type: "address",
        value: address2
      },
      {
        name: "lock",
        type: "boolean",
        value: lock
      },
      {
        name: "lock period",
        type: "integer",
        gte: 0,
        value: lockPeriod,
        optional: true
      }
    ]);
    if (toHex$1(receiverAddress) === toHex$1(address2)) {
      throw new Error("Receiver address must not be the same as owner address");
    }
    const data = {
      owner_address: toHex$1(address2),
      receiver_address: toHex$1(receiverAddress),
      balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    if (lock) {
      data.lock = lock;
      if (isNotNullOrUndefined(lockPeriod)) {
        data.lock_period = lockPeriod;
      }
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.DelegateResourceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async undelegateResource(amount = 0, receiverAddress, resource = "BANDWIDTH", address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    if (toHex$1(receiverAddress) === toHex$1(address2)) {
      throw new Error("Receiver address must not be the same as owner address");
    }
    const data = {
      owner_address: toHex$1(address2),
      receiver_address: toHex$1(receiverAddress),
      balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UnDelegateResourceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async withdrawExpireUnfreeze(address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      owner_address: toHex$1(address2)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.WithdrawExpireUnfreezeContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async withdrawBlockRewards(address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      owner_address: toHex$1(address2)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.WithdrawBalanceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async applyForSR(address2 = this.tronWeb.defaultAddress.hex, url = "", options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      },
      {
        name: "url",
        type: "url",
        value: url,
        msg: "Invalid url provided"
      },
      {
        name: "url",
        type: "string",
        value: url,
        lte: 256,
        msg: "Invalid url provided"
      }
    ]);
    const data = {
      owner_address: toHex$1(address2),
      url: fromUtf8(url)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.WitnessCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async vote(votes = {}, voterAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "voter",
        type: "address",
        value: voterAddress
      },
      {
        name: "votes",
        type: "notEmptyObject",
        value: votes
      }
    ]);
    const entries = Object.entries(votes);
    for (const [srAddress, voteCount] of entries) {
      this.validator.notValid([
        {
          name: "SR",
          type: "address",
          value: srAddress
        },
        {
          name: "vote count",
          type: "integer",
          gt: 0,
          value: voteCount,
          msg: "Invalid vote count provided for SR: " + srAddress
        }
      ]);
    }
    const voteList = entries.map(([srAddress, voteCount]) => {
      return {
        vote_address: toHex$1(srAddress),
        vote_count: parseInt(voteCount)
      };
    });
    const data = {
      owner_address: toHex$1(voterAddress),
      votes: voteList
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.VoteWitnessContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async createSmartContract(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    var _a3;
    const feeLimit = options.feeLimit || this.tronWeb.feeLimit;
    let userFeePercentage = options.userFeePercentage;
    if (typeof userFeePercentage !== "number" && !userFeePercentage) {
      userFeePercentage = 100;
    }
    const originEnergyLimit = options.originEnergyLimit || 1e7;
    const callValue = options.callValue || 0;
    const tokenValue = options.tokenValue;
    const tokenId = options.tokenId || options.token_id;
    let { abi: abi2 } = options;
    const { parameters = [] } = options;
    let parameter = "";
    const { bytecode = false, name = "" } = options;
    if (abi2 && isString$1(abi2)) {
      try {
        abi2 = JSON.parse(abi2);
      } catch {
        throw new Error("Invalid options.abi provided");
      }
    }
    const newAbi = abi2;
    let entries = newAbi;
    if (newAbi.entrys) {
      entries = newAbi.entrys;
    }
    if (!isArray$1(entries))
      throw new Error("Invalid options.abi provided");
    const payable = entries.some((func) => {
      return func.type === "constructor" && "payable" === func.stateMutability.toLowerCase();
    });
    this.validator.notValid([
      {
        name: "bytecode",
        type: "hex",
        value: bytecode
      },
      {
        name: "feeLimit",
        type: "integer",
        value: feeLimit,
        gt: 0
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "userFeePercentage",
        type: "integer",
        value: userFeePercentage,
        gte: 0,
        lte: 100
      },
      {
        name: "originEnergyLimit",
        type: "integer",
        value: originEnergyLimit,
        gte: 0,
        lte: 1e7
      },
      {
        name: "parameters",
        type: "array",
        value: parameters
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    if (!payable && (callValue > 0 || tokenValue > 0))
      throw new Error("When contract is not payable, options.callValue and options.tokenValue must be 0");
    const { rawParameter, funcABIV2, parametersV2 } = options;
    if (rawParameter && isString$1(rawParameter)) {
      parameter = rawParameter.replace(/^(0x)/, "");
    } else if (funcABIV2) {
      parameter = encodeParamsV2ByABI(funcABIV2, parametersV2).replace(/^(0x)/, "");
    } else {
      let constructorParams = entries.find((it) => {
        return it.type === "constructor";
      });
      if (typeof constructorParams !== "undefined" && constructorParams) {
        const abiCoder2 = new AbiCoder();
        const types = [];
        const values = [];
        constructorParams = constructorParams.inputs;
        if (parameters.length != constructorParams.length)
          throw new Error(`constructor needs ${constructorParams.length} but ${parameters.length} provided`);
        for (let i = 0; i < parameters.length; i++) {
          let type2 = constructorParams[i].type;
          let value = parameters[i];
          if (!type2 || !isString$1(type2) || !type2.length)
            throw new Error("Invalid parameter type provided: " + type2);
          const replaceAddressPrefix = (value2) => {
            if (isArray$1(value2)) {
              return value2.map((v2) => replaceAddressPrefix(v2));
            }
            return toHex$1(value2).replace(ADDRESS_PREFIX_REGEX, "0x");
          };
          if (type2 === "address")
            value = replaceAddressPrefix(value);
          else if (((_a3 = type2.match(/^([^\x5b]*)(\x5b|$)/)) == null ? void 0 : _a3[0]) === "address[")
            value = replaceAddressPrefix(value);
          else if (/trcToken/.test(type2)) {
            type2 = type2.replace(/trcToken/, "uint256");
          }
          types.push(type2);
          values.push(value);
        }
        try {
          parameter = abiCoder2.encode(types, values).replace(/^(0x)/, "");
        } catch (ex) {
          throw new Error(ex);
        }
      } else {
        parameter = "";
      }
    }
    const args = {
      owner_address: toHex$1(issuerAddress),
      fee_limit: parseInt(feeLimit),
      call_value: parseInt(callValue),
      consume_user_resource_percent: userFeePercentage,
      origin_energy_limit: originEnergyLimit,
      abi: JSON.stringify(abi2),
      bytecode,
      parameter,
      name
    };
    if (isNotNullOrUndefined(tokenValue)) {
      args.call_token_value = parseInt(tokenValue);
    }
    if (isNotNullOrUndefined(tokenId)) {
      args.token_id = parseInt(tokenId);
    }
    const contract = {};
    contract.owner_address = args.owner_address;
    if (isNotNullOrUndefined(args.call_token_value)) {
      contract.call_token_value = args.call_token_value;
    }
    if (isNotNullOrUndefined(args.token_id)) {
      contract.token_id = args.token_id;
    }
    const new_contract = contract.new_contract = {};
    if (args.abi) {
      new_contract.abi = {
        entrys: JSON.parse(args.abi)
      };
    } else {
      new_contract.abi = {};
    }
    if (args.call_value) {
      new_contract.call_value = args.call_value;
    }
    new_contract.consume_user_resource_percent = args.consume_user_resource_percent;
    new_contract.origin_energy_limit = args.origin_energy_limit;
    new_contract.origin_address = args.origin_address ?? args.owner_address;
    if (args.bytecode + args.parameter) {
      new_contract.bytecode = (args.bytecode + args.parameter).replace(/^0x/, "");
    }
    if (isNotNullOrUndefined(args.name)) {
      new_contract.name = args.name;
    }
    const transactionOptions = getTransactionOptions(options);
    const tx = await createTransaction(this.tronWeb, ContractType.CreateSmartContract, contract, options == null ? void 0 : options.permissionId, {
      ...transactionOptions,
      fee_limit: args.fee_limit
    });
    tx.contract_address = genContractAddress(args.owner_address, tx.txID);
    return tx;
  }
  async triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress) {
    var _a3;
    const params = [
      contractAddress,
      functionSelector,
      options,
      parameters,
      issuerAddress
    ];
    if (typeof params[2] !== "object") {
      params[2] = {
        feeLimit: params[2],
        callValue: params[3]
      };
      params.splice(3, 1);
    }
    if ((_a3 = params[2]) == null ? void 0 : _a3.txLocal) {
      return this._triggerSmartContractLocal(...params);
    }
    return this._triggerSmartContract(...params);
  }
  async triggerConstantContract(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    options._isConstant = true;
    return this._triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress);
  }
  async triggerConfirmedConstantContract(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    options._isConstant = true;
    options.confirmed = true;
    return this._triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress);
  }
  async estimateEnergy(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    options.estimateEnergy = true;
    const result = await this._triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress);
    return result;
  }
  async deployConstantContract(options = { input: "", ownerAddress: "" }) {
    const { input, ownerAddress, tokenId, tokenValue, callValue = 0 } = options;
    this.validator.notValid([
      {
        name: "input",
        type: "not-empty-string",
        value: input
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    const args = {
      data: input,
      owner_address: toHex$1(ownerAddress),
      call_value: callValue
    };
    if (tokenId) {
      args.token_id = tokenId;
    }
    if (tokenValue) {
      args.call_token_value = tokenValue;
    }
    const pathInfo = `wallet${options.confirmed ? "solidity" : ""}/estimateenergy`;
    const transaction2 = await this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(pathInfo, args, "post");
    if (transaction2.Error)
      throw new Error(transaction2.Error);
    if (transaction2.result && transaction2.result.message) {
      throw new Error(this.tronWeb.toUtf8(transaction2.result.message));
    }
    return transaction2;
  }
  _getTriggerSmartContractArgs(contractAddress, functionSelector, options, parameters, issuerAddress, tokenValue, tokenId, callValue, feeLimit) {
    var _a3;
    const args = {
      contract_address: toHex$1(contractAddress),
      owner_address: toHex$1(issuerAddress)
    };
    if (functionSelector && isString$1(functionSelector)) {
      functionSelector = functionSelector.replace(/\s*/g, "");
      let parameterStr;
      if (parameters.length) {
        const abiCoder2 = new AbiCoder();
        let types = [];
        const values = [];
        for (let i = 0; i < parameters.length; i++) {
          let { value } = parameters[i];
          const { type: type2 } = parameters[i];
          if (!type2 || !isString$1(type2) || !type2.length)
            throw new Error("Invalid parameter type provided: " + type2);
          const replaceAddressPrefix = (value2) => {
            if (isArray$1(value2)) {
              return value2.map((v2) => replaceAddressPrefix(v2));
            }
            return toHex$1(value2).replace(ADDRESS_PREFIX_REGEX, "0x");
          };
          if (type2 === "address")
            value = replaceAddressPrefix(value);
          else if (((_a3 = type2.match(/^([^\x5b]*)(\x5b|$)/)) == null ? void 0 : _a3[0]) === "address[")
            value = replaceAddressPrefix(value);
          types.push(type2);
          values.push(value);
        }
        try {
          types = types.map((type2) => {
            if (/trcToken/.test(type2)) {
              type2 = type2.replace(/trcToken/, "uint256");
            }
            return type2;
          });
          parameterStr = abiCoder2.encode(types, values).replace(/^(0x)/, "");
        } catch (ex) {
          throw new Error(ex);
        }
      } else
        parameterStr = "";
      if (options.funcABIV2) {
        parameterStr = encodeParamsV2ByABI(options.funcABIV2, options.parametersV2).replace(/^(0x)/, "");
      }
      if (options.shieldedParameter && isString$1(options.shieldedParameter)) {
        parameterStr = options.shieldedParameter.replace(/^(0x)/, "");
      }
      if (options.rawParameter && isString$1(options.rawParameter)) {
        parameterStr = options.rawParameter.replace(/^(0x)/, "");
      }
      args.function_selector = functionSelector;
      args.parameter = parameterStr;
    } else if (options.input) {
      args.data = options.input;
    }
    args.call_value = parseInt(callValue);
    if (isNotNullOrUndefined(tokenValue))
      args.call_token_value = parseInt(tokenValue);
    if (isNotNullOrUndefined(tokenId))
      args.token_id = parseInt(tokenId);
    if (!(options._isConstant || options.estimateEnergy)) {
      args.fee_limit = parseInt(feeLimit);
    }
    if (options.permissionId) {
      args.Permission_id = options.permissionId;
    }
    return args;
  }
  async _triggerSmartContractLocal(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    const { tokenValue, tokenId, callValue, feeLimit } = Object.assign({
      callValue: 0,
      feeLimit: this.tronWeb.feeLimit
    }, options);
    this.validator.notValid([
      {
        name: "feeLimit",
        type: "integer",
        value: feeLimit,
        gt: 0
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "parameters",
        type: "array",
        value: parameters
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress,
        optional: true
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    const args = this._getTriggerSmartContractArgs(contractAddress, functionSelector, options, parameters, issuerAddress, tokenValue, tokenId, callValue, feeLimit);
    if (args.function_selector) {
      args.data = keccak256(Buffer.from(args.function_selector, "utf-8")).toString().substring(2, 10) + args.parameter;
    }
    const value = {
      data: args.data,
      owner_address: args.owner_address,
      contract_address: args.contract_address
    };
    if (args.call_value) {
      value.call_value = args.call_value;
    }
    if (args.call_token_value) {
      value.call_token_value = args.call_token_value;
    }
    if (args.token_id) {
      value.token_id = args.token_id;
    }
    const transactionOptions = getTransactionOptions(options);
    const transaction2 = await createTransaction(this.tronWeb, ContractType.TriggerSmartContract, value, options.permissionId, {
      ...transactionOptions,
      fee_limit: args.fee_limit
    });
    return {
      result: {
        result: true
      },
      transaction: transaction2
    };
  }
  async _triggerSmartContract(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    const { tokenValue, tokenId, callValue, feeLimit } = Object.assign({
      callValue: 0,
      feeLimit: this.tronWeb.feeLimit
    }, options);
    this.validator.notValid([
      {
        name: "feeLimit",
        type: "integer",
        value: feeLimit,
        gt: 0
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "parameters",
        type: "array",
        value: parameters
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress,
        optional: true
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    const args = this._getTriggerSmartContractArgs(contractAddress, functionSelector, options, parameters, issuerAddress, tokenValue, tokenId, callValue, feeLimit);
    let pathInfo = "triggersmartcontract";
    if (options._isConstant) {
      pathInfo = "triggerconstantcontract";
    } else if (options.estimateEnergy) {
      pathInfo = "estimateenergy";
    }
    pathInfo = `wallet${options.confirmed ? "solidity" : ""}/${pathInfo}`;
    const transaction2 = await this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(pathInfo, args, "post");
    return resultManagerTriggerSmartContract(transaction2, args, options);
  }
  async clearABI(contractAddress, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    if (!TronWeb.isAddress(contractAddress))
      throw new Error("Invalid contract address provided");
    if (!TronWeb.isAddress(ownerAddress))
      throw new Error("Invalid owner address provided");
    const data = {
      contract_address: toHex$1(contractAddress),
      owner_address: toHex$1(ownerAddress)
    };
    if (this.tronWeb.trx.cache.contracts[contractAddress]) {
      delete this.tronWeb.trx.cache.contracts[contractAddress];
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ClearABIContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async updateBrokerage(brokerage, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    if (!isNotNullOrUndefined(brokerage))
      throw new Error("Invalid brokerage provided");
    if (!isInteger(brokerage) || brokerage < 0 || brokerage > 100)
      throw new Error("Brokerage must be an integer between 0 and 100");
    if (!TronWeb.isAddress(ownerAddress))
      throw new Error("Invalid owner address provided");
    const data = {
      brokerage: parseInt(brokerage),
      owner_address: toHex$1(ownerAddress)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateBrokerageContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async createToken(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    const {
      name = false,
      abbreviation = false,
      description = "",
      url = false,
      totalSupply = 0,
      trxRatio = 1,
      // How much TRX will `tokenRatio` cost
      tokenRatio = 1,
      // How many tokens will `trxRatio` afford
      saleStart = Date.now(),
      saleEnd = false,
      freeBandwidth = 0,
      // The creator's "donated" bandwidth for use by token holders
      freeBandwidthLimit = 0,
      // Out of `totalFreeBandwidth`, the amount each token holder get
      frozenAmount = 0,
      frozenDuration = 0,
      // for now there is no default for the following values
      voteScore,
      precision
    } = options;
    this.validator.notValid([
      {
        name: "Supply amount",
        type: "positive-integer",
        value: totalSupply
      },
      {
        name: "TRX ratio",
        type: "positive-integer",
        value: trxRatio
      },
      {
        name: "Token ratio",
        type: "positive-integer",
        value: tokenRatio
      },
      {
        name: "token abbreviation",
        type: "string",
        value: abbreviation,
        lte: 32,
        gt: 0
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: name
      },
      {
        name: "token description",
        type: "string",
        value: description,
        lte: 200
      },
      {
        name: "token url",
        type: "url",
        value: url
      },
      {
        name: "token url",
        type: "string",
        value: url,
        lte: 256
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        name: "sale start timestamp",
        type: "integer",
        value: saleStart,
        gte: Date.now()
      },
      {
        name: "sale end timestamp",
        type: "integer",
        value: saleEnd,
        gt: saleStart
      },
      {
        name: "Frozen supply",
        type: "integer",
        value: frozenAmount,
        gte: 0
      },
      {
        name: "Frozen duration",
        type: "integer",
        value: frozenDuration,
        gte: 0
      }
    ]);
    if (isNotNullOrUndefined(voteScore) && (!isInteger(voteScore) || voteScore <= 0))
      throw new Error("voteScore must be a positive integer greater than 0");
    if (isNotNullOrUndefined(precision) && (!isInteger(precision) || precision < 0 || precision > 6))
      throw new Error("precision must be a positive integer >= 0 and <= 6");
    const data = {
      owner_address: toHex$1(issuerAddress),
      name: fromUtf8(name),
      abbr: fromUtf8(abbreviation),
      description: fromUtf8(description),
      url: fromUtf8(url),
      total_supply: parseInt(totalSupply),
      trx_num: parseInt(trxRatio),
      num: parseInt(tokenRatio),
      start_time: parseInt(saleStart),
      end_time: parseInt(saleEnd),
      frozen_supply: [
        {
          frozen_amount: parseInt(frozenAmount),
          frozen_days: parseInt(frozenDuration)
        }
      ]
    };
    ["name", "abbr", "description", "url"].forEach((key) => {
      if (!data[key]) {
        delete data[key];
      }
    });
    if (!(parseInt(frozenAmount) > 0)) {
      delete data.frozen_supply;
    }
    if (freeBandwidth && !isNaN(parseInt(freeBandwidth)) && parseInt(freeBandwidth) >= 0) {
      data.free_asset_net_limit = parseInt(freeBandwidth);
    }
    if (freeBandwidthLimit && !isNaN(parseInt(freeBandwidthLimit)) && parseInt(freeBandwidthLimit) >= 0) {
      data.public_free_asset_net_limit = parseInt(freeBandwidthLimit);
    }
    if (precision && !isNaN(parseInt(precision))) {
      data.precision = parseInt(precision);
    }
    if (voteScore && !isNaN(parseInt(voteScore))) {
      data.vote_score = parseInt(voteScore);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AssetIssueContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async createAccount(accountAddress, address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "account",
        type: "address",
        value: accountAddress
      },
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      owner_address: toHex$1(address2),
      account_address: toHex$1(accountAddress)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AccountCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async updateAccount(accountName, address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "Name",
        type: "string",
        lte: 200,
        gt: 0,
        value: accountName,
        msg: "Invalid accountName"
      },
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      account_name: fromUtf8(accountName),
      owner_address: toHex$1(address2)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AccountUpdateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async setAccountId(accountId, address2 = this.tronWeb.defaultAddress.hex, options = {}) {
    if (accountId && isString$1(accountId) && accountId.startsWith("0x")) {
      accountId = accountId.slice(2);
    }
    this.validator.notValid([
      {
        name: "accountId",
        type: "hex",
        value: accountId
      },
      {
        name: "accountId",
        type: "string",
        lte: 32,
        gte: 8,
        value: accountId
      },
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      account_id: accountId,
      owner_address: toHex$1(address2)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.SetAccountIdContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async updateToken(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    const {
      description = "",
      url = false,
      freeBandwidth = 0,
      // The creator's "donated" bandwidth for use by token holders
      freeBandwidthLimit = 0
      // Out of `totalFreeBandwidth`, the amount each token holder get
    } = options;
    this.validator.notValid([
      {
        name: "token description",
        type: "string",
        value: description,
        lte: 200
      },
      {
        name: "token url",
        type: "url",
        value: url
      },
      {
        name: "token url",
        type: "string",
        value: url,
        lte: 256
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      }
    ]);
    const data = {
      owner_address: toHex$1(issuerAddress),
      description: fromUtf8(description),
      url: fromUtf8(url)
    };
    if (freeBandwidth && !isNaN(parseInt(freeBandwidth)) && parseInt(freeBandwidth) >= 0) {
      data.new_limit = parseInt(freeBandwidth);
    }
    if (freeBandwidthLimit && !isNaN(parseInt(freeBandwidthLimit)) && parseInt(freeBandwidthLimit) >= 0) {
      data.new_public_limit = parseInt(freeBandwidthLimit);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateAssetContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async sendAsset(to, amount = 0, tokenId, from = this.tronWeb.defaultAddress.hex, options = {}) {
    return this.sendToken(to, amount, tokenId, from, options);
  }
  async purchaseAsset(issuerAddress, tokenId, amount = 0, buyer = this.tronWeb.defaultAddress.hex, options = {}) {
    return this.purchaseToken(issuerAddress, tokenId, amount, buyer, options);
  }
  async createAsset(options, issuerAddress) {
    return this.createToken(options, issuerAddress);
  }
  async updateAsset(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    return this.updateToken(options, issuerAddress);
  }
  /**
   * Creates a proposal to modify the network.
   * Can only be created by a current Super Representative.
   */
  async createProposal(parameters, issuerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      }
    ]);
    const invalid = "Invalid proposal parameters provided";
    if (!parameters)
      throw new Error(invalid);
    const newParams = isArray$1(parameters) ? parameters : [parameters];
    for (const parameter of newParams) {
      if (!isObject$2(parameter))
        throw new Error(invalid);
    }
    const data = {
      owner_address: toHex$1(issuerAddress),
      parameters: newParams
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ProposalCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Deletes a network modification proposal that the owner issued.
   * Only current Super Representative can vote on a proposal.
   */
  async deleteProposal(proposalID, issuerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        name: "proposalID",
        type: "integer",
        value: proposalID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex$1(issuerAddress),
      proposal_id: parseInt(proposalID)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ProposalDeleteContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Adds a vote to an issued network modification proposal.
   * Only current Super Representative can vote on a proposal.
   */
  async voteProposal(proposalID, isApproval = false, voterAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "voter",
        type: "address",
        value: voterAddress
      },
      {
        name: "proposalID",
        type: "integer",
        value: proposalID,
        gte: 0
      },
      {
        name: "has approval",
        type: "boolean",
        value: isApproval
      }
    ]);
    const data = {
      owner_address: toHex$1(voterAddress),
      proposal_id: parseInt(proposalID),
      is_add_approval: isApproval
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ProposalApproveContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Create an exchange between a token and TRX.
   * Token Name should be a CASE SENSITIVE string.
   * PLEASE VERIFY THIS ON TRONSCAN.
   */
  async createTRXExchange(tokenName, tokenBalance, trxBalance, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "token balance",
        type: "positive-integer",
        value: tokenBalance
      },
      {
        name: "trx balance",
        type: "positive-integer",
        value: trxBalance
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      first_token_id: fromUtf8(tokenName),
      first_token_balance: tokenBalance,
      second_token_id: "5f",
      // Constant for TRX.
      second_token_balance: trxBalance
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Create an exchange between a token and another token.
   * DO NOT USE THIS FOR TRX.
   * Token Names should be a CASE SENSITIVE string.
   * PLEASE VERIFY THIS ON TRONSCAN.
   */
  async createTokenExchange(firstTokenName, firstTokenBalance, secondTokenName, secondTokenBalance, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "first token name",
        type: "not-empty-string",
        value: firstTokenName
      },
      {
        name: "second token name",
        type: "not-empty-string",
        value: secondTokenName
      },
      {
        name: "first token balance",
        type: "positive-integer",
        value: firstTokenBalance
      },
      {
        name: "second token balance",
        type: "positive-integer",
        value: secondTokenBalance
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      first_token_id: fromUtf8(firstTokenName),
      first_token_balance: firstTokenBalance,
      second_token_id: fromUtf8(secondTokenName),
      second_token_balance: secondTokenBalance
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Adds tokens into a bancor style exchange.
   * Will add both tokens at market rate.
   * Use "_" for the constant value for TRX.
   */
  async injectExchangeTokens(exchangeID, tokenName, tokenAmount, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "token amount",
        type: "integer",
        value: tokenAmount,
        gte: 1
      },
      {
        name: "exchangeID",
        type: "integer",
        value: exchangeID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      exchange_id: parseInt(exchangeID),
      token_id: fromUtf8(tokenName),
      quant: parseInt(tokenAmount)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeInjectContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Withdraws tokens from a bancor style exchange.
   * Will withdraw at market rate both tokens.
   * Use "_" for the constant value for TRX.
   */
  async withdrawExchangeTokens(exchangeID, tokenName, tokenAmount, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "token amount",
        type: "integer",
        value: tokenAmount,
        gte: 1
      },
      {
        name: "exchangeID",
        type: "integer",
        value: exchangeID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      exchange_id: parseInt(exchangeID),
      token_id: fromUtf8(tokenName),
      quant: parseInt(tokenAmount)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeWithdrawContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Trade tokens on a bancor style exchange.
   * Expected value is a validation and used to cap the total amt of token 2 spent.
   * Use "_" for the constant value for TRX.
   */
  async tradeExchangeTokens(exchangeID, tokenName, tokenAmountSold, tokenAmountExpected, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "tokenAmountSold",
        type: "integer",
        value: tokenAmountSold,
        gte: 1
      },
      {
        name: "tokenAmountExpected",
        type: "integer",
        value: tokenAmountExpected,
        gte: 1
      },
      {
        name: "exchangeID",
        type: "integer",
        value: exchangeID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      exchange_id: parseInt(exchangeID),
      token_id: TronWeb.fromAscii(tokenName).replace(/^0x/, ""),
      quant: parseInt(tokenAmountSold),
      expected: parseInt(tokenAmountExpected)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeTransactionContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Update userFeePercentage.
   */
  async updateSetting(contractAddress, userFeePercentage, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "userFeePercentage",
        type: "integer",
        value: userFeePercentage,
        gte: 0,
        lte: 100
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      contract_address: toHex$1(contractAddress),
      consume_user_resource_percent: userFeePercentage
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateSettingContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Update energy limit.
   */
  async updateEnergyLimit(contractAddress, originEnergyLimit = 0, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "originEnergyLimit",
        type: "integer",
        value: originEnergyLimit,
        gte: 0,
        lte: 1e7
      }
    ]);
    const data = {
      owner_address: toHex$1(ownerAddress),
      contract_address: toHex$1(contractAddress),
      origin_energy_limit: originEnergyLimit
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateEnergyLimitContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  checkPermissions(permissions, type2) {
    if (permissions) {
      if (permissions.type !== type2 || !permissions.permission_name || !isString$1(permissions.permission_name) || !isInteger(permissions.threshold) || permissions.threshold < 1 || !permissions.keys) {
        return false;
      }
      for (const key of permissions.keys) {
        if (!TronWeb.isAddress(key.address) || !isInteger(key.weight) || key.weight > permissions.threshold || key.weight < 1 || type2 === 2 && !permissions.operations) {
          return false;
        }
      }
    }
    return true;
  }
  async updateAccountPermissions(ownerAddress = this.tronWeb.defaultAddress.hex, ownerPermission, witnessPermission, activesPermissions, options = {}) {
    var _a3;
    if (!TronWeb.isAddress(ownerAddress))
      throw new Error("Invalid ownerAddress provided");
    if (!this.checkPermissions(ownerPermission, 0)) {
      throw new Error("Invalid ownerPermissions provided");
    }
    if (!this.checkPermissions(witnessPermission, 1)) {
      throw new Error("Invalid witnessPermissions provided");
    }
    if (!Array.isArray(activesPermissions)) {
      activesPermissions = [activesPermissions];
    }
    for (const activesPermission of activesPermissions) {
      if (!this.checkPermissions(activesPermission, 2)) {
        throw new Error("Invalid activesPermissions provided");
      }
    }
    const data = {
      owner_address: toHex$1(ownerAddress)
    };
    if (ownerPermission) {
      const _ownerPermissions = deepCopyJson(ownerPermission);
      if ("type" in _ownerPermissions) {
        delete _ownerPermissions.type;
      }
      _ownerPermissions.keys = (_a3 = _ownerPermissions.keys) == null ? void 0 : _a3.map(({ address: address2, weight }) => ({
        address: this.tronWeb.address.toHex(address2),
        weight
      }));
      data.owner = _ownerPermissions;
    }
    if (witnessPermission) {
      const _witnessPermissions = deepCopyJson(witnessPermission);
      _witnessPermissions.type = "Witness";
      _witnessPermissions.keys = _witnessPermissions.keys.map(({ address: address2, weight }) => ({
        address: this.tronWeb.address.toHex(address2),
        weight
      }));
      data.witness = _witnessPermissions;
    }
    if (activesPermissions) {
      const _activesPermissions = deepCopyJson(activesPermissions);
      _activesPermissions.forEach((activePermissions) => {
        activePermissions.type = "Active";
      });
      _activesPermissions.forEach((_activesPermission) => {
        _activesPermission.keys = _activesPermission.keys.map(({ address: address2, weight }) => ({
          address: this.tronWeb.address.toHex(address2),
          weight
        }));
      });
      data.actives = _activesPermissions;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AccountPermissionUpdateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async newTxID(transaction2, options = {}) {
    if (options == null ? void 0 : options.txLocal) {
      const contract = transaction2.raw_data.contract[0];
      try {
        const tx = await createTransaction(this.tronWeb, contract.type, contract.parameter.value, contract.Permission_id, {
          fee_limit: transaction2.raw_data.fee_limit,
          data: transaction2.raw_data.data,
          ref_block_bytes: transaction2.raw_data.ref_block_bytes,
          ref_block_hash: transaction2.raw_data.ref_block_hash,
          expiration: transaction2.raw_data.expiration,
          timestamp: transaction2.raw_data.timestamp
        });
        tx.signature = transaction2.signature;
        tx.visible = transaction2.visible;
        return tx;
      } catch (e2) {
        throw new Error("Error generating a new transaction id.");
      }
    }
    try {
      const res = await this.tronWeb.fullNode.request("wallet/getsignweight", transaction2, "post");
      if (typeof transaction2.visible === "boolean") {
        res.transaction.transaction.visible = transaction2.visible;
      }
      return resultManager(
        res.transaction.transaction,
        {
          ...transaction2.raw_data.contract[0].parameter.value,
          Permission_id: transaction2.raw_data.contract[0].Permission_id
        },
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        /* @ts-ignore */
        { data: transaction2.raw_data.data, fee_limit: transaction2.raw_data.fee_limit }
      );
    } catch (e2) {
      throw new Error("Error generating a new transaction id.");
    }
  }
  async alterTransaction(transaction2, options = {}) {
    if (Reflect.has(transaction2, "signature"))
      throw new Error("You can not extend the expiration of a signed transaction.");
    if (options.data) {
      if (options.dataFormat !== "hex")
        options.data = TronWeb.toHex(options.data);
      options.data = options.data.replace(/^0x/, "");
      if (options.data.length === 0)
        throw new Error("Invalid data provided");
      transaction2.raw_data.data = options.data;
    }
    if (options.extension) {
      options.extension = parseInt(options.extension * 1e3);
      if (isNaN(options.extension) || transaction2.raw_data.expiration + options.extension <= Date.now() + 3e3)
        throw new Error("Invalid extension provided");
      transaction2.raw_data.expiration += options.extension;
    }
    return await this.newTxID(transaction2, { txLocal: options.txLocal });
  }
  async extendExpiration(transaction2, extension, options = {}) {
    return await this.alterTransaction(transaction2, { extension, txLocal: options == null ? void 0 : options.txLocal });
  }
  async addUpdateData(transaction2, data, dataFormat = "utf8", options = {}) {
    return this.alterTransaction(transaction2, { data, dataFormat, txLocal: options == null ? void 0 : options.txLocal });
  }
}
const TRX_MESSAGE_HEADER = "TRON Signed Message:\n32";
const ETH_MESSAGE_HEADER = "Ethereum Signed Message:\n32";
function toHex(value) {
  return TronWeb.address.toHex(value);
}
class Trx {
  constructor(tronWeb) {
    __publicField(this, "tronWeb");
    __publicField(this, "cache");
    __publicField(this, "validator");
    __publicField(this, "signMessage");
    __publicField(this, "sendAsset");
    __publicField(this, "send");
    __publicField(this, "sendTrx");
    __publicField(this, "broadcast");
    __publicField(this, "broadcastHex");
    __publicField(this, "signTransaction");
    this.tronWeb = tronWeb;
    this.cache = {
      contracts: {}
    };
    this.validator = new Validator();
    this.signMessage = this.sign;
    this.sendAsset = this.sendToken;
    this.send = this.sendTransaction;
    this.sendTrx = this.sendTransaction;
    this.broadcast = this.sendRawTransaction;
    this.broadcastHex = this.sendHexTransaction;
    this.signTransaction = this.sign;
  }
  _parseToken(token) {
    return {
      ...token,
      name: this.tronWeb.toUtf8(token.name),
      abbr: token.abbr && this.tronWeb.toUtf8(token.abbr),
      description: token.description && this.tronWeb.toUtf8(token.description),
      url: token.url && this.tronWeb.toUtf8(token.url)
    };
  }
  getCurrentBlock() {
    return this.tronWeb.fullNode.request("wallet/getnowblock");
  }
  getConfirmedCurrentBlock() {
    return this.tronWeb.solidityNode.request("walletsolidity/getnowblock");
  }
  async getBlock(block = this.tronWeb.defaultBlock) {
    if (block === false) {
      throw new Error("No block identifier provided");
    }
    if (block == "earliest")
      block = 0;
    if (block == "latest")
      return this.getCurrentBlock();
    if (isNaN(+block) && utils$1.isHex(block.toString()))
      return this.getBlockByHash(block);
    return this.getBlockByNumber(block);
  }
  async getBlockByHash(blockHash) {
    const block = await this.tronWeb.fullNode.request("wallet/getblockbyid", {
      value: blockHash
    }, "post");
    if (!Object.keys(block).length) {
      throw new Error("Block not found");
    }
    return block;
  }
  async getBlockByNumber(blockID) {
    if (!utils$1.isInteger(blockID) || blockID < 0) {
      throw new Error("Invalid block number provided");
    }
    return this.tronWeb.fullNode.request("wallet/getblockbynum", {
      num: parseInt(blockID)
    }, "post").then((block) => {
      if (!Object.keys(block).length) {
        throw new Error("Block not found");
      }
      return block;
    });
  }
  async getBlockTransactionCount(block = this.tronWeb.defaultBlock) {
    const { transactions = [] } = await this.getBlock(block);
    return transactions.length;
  }
  async getTransactionFromBlock(block = this.tronWeb.defaultBlock, index2) {
    const { transactions } = await this.getBlock(block);
    if (!transactions) {
      throw new Error("Transaction not found in block");
    }
    if (index2 >= 0 && index2 < transactions.length)
      return transactions[index2];
    else
      throw new Error("Invalid transaction index provided");
  }
  async getTransactionsFromBlock(block = this.tronWeb.defaultBlock) {
    const { transactions } = await this.getBlock(block);
    if (!transactions) {
      throw new Error("Transaction not found in block");
    }
    return transactions;
  }
  async getTransaction(transactionID) {
    const transaction2 = await this.tronWeb.fullNode.request("wallet/gettransactionbyid", {
      value: transactionID
    }, "post");
    if (!Object.keys(transaction2).length) {
      throw new Error("Transaction not found");
    }
    return transaction2;
  }
  async getConfirmedTransaction(transactionID) {
    const transaction2 = await this.tronWeb.solidityNode.request("walletsolidity/gettransactionbyid", {
      value: transactionID
    }, "post");
    if (!Object.keys(transaction2).length) {
      throw new Error("Transaction not found");
    }
    return transaction2;
  }
  getUnconfirmedTransactionInfo(transactionID) {
    return this.tronWeb.fullNode.request("wallet/gettransactioninfobyid", { value: transactionID }, "post");
  }
  getTransactionInfo(transactionID) {
    return this.tronWeb.solidityNode.request("walletsolidity/gettransactioninfobyid", { value: transactionID }, "post");
  }
  getTransactionsToAddress(address2 = this.tronWeb.defaultAddress.hex, limit = 30, offset2 = 0) {
    return this.getTransactionsRelated(this.tronWeb.address.toHex(address2), "to", limit, offset2);
  }
  getTransactionsFromAddress(address2 = this.tronWeb.defaultAddress.hex, limit = 30, offset2 = 0) {
    return this.getTransactionsRelated(this.tronWeb.address.toHex(address2), "from", limit, offset2);
  }
  async getTransactionsRelated(address2 = this.tronWeb.defaultAddress.hex, direction = "all", limit = 30, offset2 = 0) {
    if (!["to", "from", "all"].includes(direction)) {
      throw new Error('Invalid direction provided: Expected "to", "from" or "all"');
    }
    if (direction == "all") {
      const [from, to] = await Promise.all([
        this.getTransactionsRelated(address2, "from", limit, offset2),
        this.getTransactionsRelated(address2, "to", limit, offset2)
      ]);
      return [
        ...from.map((tx) => (tx.direction = "from", tx)),
        ...to.map((tx) => (tx.direction = "to", tx))
      ].sort((a, b2) => {
        return b2.raw_data.timestamp - a.raw_data.timestamp;
      });
    }
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    if (!utils$1.isInteger(limit) || limit < 0 || offset2 && limit < 1) {
      throw new Error("Invalid limit provided");
    }
    if (!utils$1.isInteger(offset2) || offset2 < 0) {
      throw new Error("Invalid offset provided");
    }
    address2 = this.tronWeb.address.toHex(address2);
    return this.tronWeb.solidityNode.request(`walletextension/gettransactions${direction}this`, {
      account: {
        address: address2
      },
      offset: offset2,
      limit
    }, "post").then(({ transaction: transaction2 }) => {
      return transaction2;
    });
  }
  async getAccount(address2 = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    address2 = this.tronWeb.address.toHex(address2);
    return this.tronWeb.solidityNode.request("walletsolidity/getaccount", {
      address: address2
    }, "post");
  }
  getAccountById(id2) {
    return this.getAccountInfoById(id2, { confirmed: true });
  }
  async getAccountInfoById(id2, options) {
    this.validator.notValid([
      {
        name: "accountId",
        type: "hex",
        value: id2
      },
      {
        name: "accountId",
        type: "string",
        lte: 32,
        gte: 8,
        value: id2
      }
    ]);
    if (id2.startsWith("0x")) {
      id2 = id2.slice(2);
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getaccountbyid`, {
      account_id: id2
    }, "post");
  }
  async getBalance(address2 = this.tronWeb.defaultAddress.hex) {
    const { balance = 0 } = await this.getAccount(address2);
    return balance;
  }
  async getUnconfirmedAccount(address2 = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    address2 = this.tronWeb.address.toHex(address2);
    return this.tronWeb.fullNode.request("wallet/getaccount", {
      address: address2
    }, "post");
  }
  getUnconfirmedAccountById(id2) {
    return this.getAccountInfoById(id2, { confirmed: false });
  }
  async getUnconfirmedBalance(address2 = this.tronWeb.defaultAddress.hex) {
    const { balance = 0 } = await this.getUnconfirmedAccount(address2);
    return balance;
  }
  async getBandwidth(address2 = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    address2 = this.tronWeb.address.toHex(address2);
    return this.tronWeb.fullNode.request("wallet/getaccountnet", {
      address: address2
    }, "post").then(({ freeNetUsed = 0, freeNetLimit = 0, NetUsed = 0, NetLimit = 0 }) => {
      return freeNetLimit - freeNetUsed + (NetLimit - NetUsed);
    });
  }
  async getTokensIssuedByAddress(address2 = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    address2 = this.tronWeb.address.toHex(address2);
    return this.tronWeb.fullNode.request("wallet/getassetissuebyaccount", {
      address: address2
    }, "post").then(({ assetIssue }) => {
      if (!assetIssue)
        return {};
      const tokens = assetIssue.map((token) => {
        return this._parseToken(token);
      }).reduce((tokens2, token) => {
        return tokens2[token.name] = token, tokens2;
      }, {});
      return tokens;
    });
  }
  async getTokenFromID(tokenID) {
    if (utils$1.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils$1.isString(tokenID) || !tokenID.length) {
      throw new Error("Invalid token ID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getassetissuebyname", {
      value: this.tronWeb.fromUtf8(tokenID)
    }, "post").then((token) => {
      if (!token.name) {
        throw new Error("Token does not exist");
      }
      return this._parseToken(token);
    });
  }
  async listNodes() {
    const { nodes = [] } = await this.tronWeb.fullNode.request("wallet/listnodes");
    return nodes.map(({ address: { host, port } }) => `${this.tronWeb.toUtf8(host)}:${port}`);
  }
  async getBlockRange(start = 0, end = 30) {
    if (!utils$1.isInteger(start) || start < 0) {
      throw new Error("Invalid start of range provided");
    }
    if (!utils$1.isInteger(end) || end < start) {
      throw new Error("Invalid end of range provided");
    }
    if (end + 1 - start > 100) {
      throw new Error("Invalid range size, which should be no more than 100.");
    }
    return this.tronWeb.fullNode.request("wallet/getblockbylimitnext", {
      startNum: parseInt(start),
      endNum: parseInt(end) + 1
    }, "post").then(({ block = [] }) => block);
  }
  async listSuperRepresentatives() {
    const { witnesses = [] } = await this.tronWeb.fullNode.request("wallet/listwitnesses");
    return witnesses;
  }
  async listTokens(limit = 0, offset2 = 0) {
    if (!utils$1.isInteger(limit) || limit < 0 || offset2 && limit < 1) {
      throw new Error("Invalid limit provided");
    }
    if (!utils$1.isInteger(offset2) || offset2 < 0) {
      throw new Error("Invalid offset provided");
    }
    if (!limit) {
      return this.tronWeb.fullNode.request("wallet/getassetissuelist").then(({ assetIssue = [] }) => assetIssue.map((token) => this._parseToken(token)));
    }
    return this.tronWeb.fullNode.request("wallet/getpaginatedassetissuelist", {
      offset: parseInt(offset2),
      limit: parseInt(limit)
    }, "post").then(({ assetIssue = [] }) => assetIssue.map((token) => this._parseToken(token)));
  }
  async timeUntilNextVoteCycle() {
    const { num = -1 } = await this.tronWeb.fullNode.request("wallet/getnextmaintenancetime");
    if (num == -1) {
      throw new Error("Failed to get time until next vote cycle");
    }
    return Math.floor(num / 1e3);
  }
  async getContract(contractAddress) {
    if (!this.tronWeb.isAddress(contractAddress)) {
      throw new Error("Invalid contract address provided");
    }
    if (this.cache.contracts[contractAddress]) {
      return this.cache.contracts[contractAddress];
    }
    contractAddress = this.tronWeb.address.toHex(contractAddress);
    const contract = await this.tronWeb.fullNode.request("wallet/getcontract", {
      value: contractAddress
    });
    if (contract.Error) {
      throw new Error("Contract does not exist");
    }
    this.cache.contracts[contractAddress] = contract;
    return contract;
  }
  ecRecover(transaction2) {
    return Trx.ecRecover(transaction2);
  }
  static ecRecover(transaction2) {
    var _a3;
    if (!txCheck(transaction2)) {
      throw new Error("Invalid transaction");
    }
    if (!((_a3 = transaction2.signature) == null ? void 0 : _a3.length)) {
      throw new Error("Transaction is not signed");
    }
    if (transaction2.signature.length === 1) {
      const tronAddress = ecRecover(transaction2.txID, transaction2.signature[0]);
      return TronWeb.address.fromHex(tronAddress);
    }
    return transaction2.signature.map((sig) => {
      const tronAddress = ecRecover(transaction2.txID, sig);
      return TronWeb.address.fromHex(tronAddress);
    });
  }
  async verifyMessage(message2, signature2, address2 = this.tronWeb.defaultAddress.base58, useTronHeader = true) {
    if (!utils$1.isHex(message2)) {
      throw new Error("Expected hex message input");
    }
    if (Trx.verifySignature(message2, address2, signature2, useTronHeader)) {
      return true;
    }
    throw new Error("Signature does not match");
  }
  static verifySignature(message2, address2, signature2, useTronHeader = true) {
    message2 = message2.replace(/^0x/, "");
    const messageBytes = [
      ...toUtf8Bytes(useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER),
      ...utils$1.code.hexStr2byteArray(message2)
    ];
    const messageDigest = keccak256(new Uint8Array(messageBytes));
    const recovered = recoverAddress(messageDigest, Signature.from(`0x${signature2.replace(/^0x/, "")}`));
    const tronAddress = ADDRESS_PREFIX + recovered.substr(2);
    const base58Address = TronWeb.address.fromHex(tronAddress);
    return base58Address == TronWeb.address.fromHex(address2);
  }
  async verifyMessageV2(message2, signature2) {
    return Trx.verifyMessageV2(message2, signature2);
  }
  static verifyMessageV2(message2, signature2) {
    return utils$1.message.verifyMessage(message2, signature2);
  }
  verifyTypedData(domain, types, value, signature2, address2 = this.tronWeb.defaultAddress.base58) {
    if (Trx.verifyTypedData(domain, types, value, signature2, address2))
      return true;
    throw new Error("Signature does not match");
  }
  static verifyTypedData(domain, types, value, signature2, address2) {
    const messageDigest = utils$1._TypedDataEncoder.hash(domain, types, value);
    const recovered = recoverAddress(messageDigest, Signature.from(`0x${signature2.replace(/^0x/, "")}`));
    const tronAddress = ADDRESS_PREFIX + recovered.substr(2);
    const base58Address = TronWeb.address.fromHex(tronAddress);
    return base58Address == TronWeb.address.fromHex(address2);
  }
  async sign(transaction2, privateKey = this.tronWeb.defaultPrivateKey, useTronHeader = true, multisig = false) {
    if (utils$1.isString(transaction2)) {
      if (!utils$1.isHex(transaction2)) {
        throw new Error("Expected hex message input");
      }
      return Trx.signString(transaction2, privateKey, useTronHeader);
    }
    if (!utils$1.isObject(transaction2)) {
      throw new Error("Invalid transaction provided");
    }
    if (!multisig && transaction2.signature) {
      throw new Error("Transaction is already signed");
    }
    if (!multisig) {
      const address2 = this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(privateKey)).toLowerCase();
      if (address2 !== this.tronWeb.address.toHex(transaction2.raw_data.contract[0].parameter.value.owner_address)) {
        throw new Error("Private key does not match address in transaction");
      }
      if (!txCheck(transaction2)) {
        throw new Error("Invalid transaction");
      }
    }
    return utils$1.crypto.signTransaction(privateKey, transaction2);
  }
  static signString(message2, privateKey, useTronHeader = true) {
    message2 = message2.replace(/^0x/, "");
    const value = `0x${privateKey.replace(/^0x/, "")}`;
    const signingKey = new SigningKey(value);
    const messageBytes = [
      ...toUtf8Bytes(useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER),
      ...utils$1.code.hexStr2byteArray(message2)
    ];
    const messageDigest = keccak256(new Uint8Array(messageBytes));
    const signature2 = signingKey.sign(messageDigest);
    const signatureHex = ["0x", signature2.r.substring(2), signature2.s.substring(2), Number(signature2.v).toString(16)].join("");
    return signatureHex;
  }
  /**
   * sign message v2 for verified header length
   *
   * @param {message to be signed, should be Bytes or string} message
   * @param {privateKey for signature} privateKey
   * @param {reserved} options
   */
  signMessageV2(message2, privateKey = this.tronWeb.defaultPrivateKey) {
    return Trx.signMessageV2(message2, privateKey);
  }
  static signMessageV2(message2, privateKey) {
    return utils$1.message.signMessage(message2, privateKey);
  }
  _signTypedData(domain, types, value, privateKey = this.tronWeb.defaultPrivateKey) {
    return Trx._signTypedData(domain, types, value, privateKey);
  }
  static _signTypedData(domain, types, value, privateKey) {
    return utils$1.crypto._signTypedData(domain, types, value, privateKey);
  }
  async multiSign(transaction2, privateKey = this.tronWeb.defaultPrivateKey, permissionId = 0) {
    if (!utils$1.isObject(transaction2) || !transaction2.raw_data || !transaction2.raw_data.contract) {
      throw new Error("Invalid transaction provided");
    }
    if (!transaction2.raw_data.contract[0].Permission_id && permissionId > 0) {
      transaction2.raw_data.contract[0].Permission_id = permissionId;
      const address2 = this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(privateKey)).toLowerCase();
      const signWeight = await this.getSignWeight(transaction2, permissionId);
      if (signWeight.result.code === "PERMISSION_ERROR") {
        throw new Error(signWeight.result.message);
      }
      let foundKey = false;
      signWeight.permission.keys.map((key) => {
        if (key.address === address2)
          foundKey = true;
      });
      if (!foundKey) {
        throw new Error(privateKey + " has no permission to sign");
      }
      if (signWeight.approved_list && signWeight.approved_list.indexOf(address2) != -1) {
        throw new Error(privateKey + " already sign transaction");
      }
      if (signWeight.transaction && signWeight.transaction.transaction) {
        transaction2 = signWeight.transaction.transaction;
        if (permissionId > 0) {
          transaction2.raw_data.contract[0].Permission_id = permissionId;
        }
      } else {
        throw new Error("Invalid transaction provided");
      }
    }
    if (!txCheck(transaction2)) {
      throw new Error("Invalid transaction");
    }
    return utils$1.crypto.signTransaction(privateKey, transaction2);
  }
  async getApprovedList(transaction2) {
    if (!utils$1.isObject(transaction2)) {
      throw new Error("Invalid transaction provided");
    }
    return this.tronWeb.fullNode.request("wallet/getapprovedlist", transaction2, "post");
  }
  async getSignWeight(transaction2, permissionId) {
    if (!utils$1.isObject(transaction2) || !transaction2.raw_data || !transaction2.raw_data.contract)
      throw new Error("Invalid transaction provided");
    if (utils$1.isInteger(permissionId)) {
      transaction2.raw_data.contract[0].Permission_id = parseInt(permissionId);
    } else if (typeof transaction2.raw_data.contract[0].Permission_id !== "number") {
      transaction2.raw_data.contract[0].Permission_id = 0;
    }
    return this.tronWeb.fullNode.request("wallet/getsignweight", transaction2, "post");
  }
  async sendRawTransaction(signedTransaction) {
    if (!utils$1.isObject(signedTransaction)) {
      throw new Error("Invalid transaction provided");
    }
    if (!signedTransaction.signature || !utils$1.isArray(signedTransaction.signature)) {
      throw new Error("Transaction is not signed");
    }
    const result = await this.tronWeb.fullNode.request("wallet/broadcasttransaction", signedTransaction, "post");
    return {
      ...result,
      transaction: signedTransaction
    };
  }
  async sendHexTransaction(signedHexTransaction) {
    if (!utils$1.isHex(signedHexTransaction)) {
      throw new Error("Invalid hex transaction provided");
    }
    const params = {
      transaction: signedHexTransaction
    };
    const result = await this.tronWeb.fullNode.request("wallet/broadcasthex", params, "post");
    if (result.result) {
      return {
        ...result,
        transaction: JSON.parse(result.transaction),
        hexTransaction: signedHexTransaction
      };
    }
    return result;
  }
  async sendTransaction(to, amount, options = {}) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!this.tronWeb.isAddress(to)) {
      throw new Error("Invalid recipient provided");
    }
    if (!utils$1.isInteger(amount) || amount <= 0) {
      throw new Error("Invalid amount provided");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address2 = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const transaction2 = await this.tronWeb.transactionBuilder.sendTrx(to, amount, address2);
    const signedTransaction = await this.sign(transaction2, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  async sendToken(to, amount, tokenID, options = {}) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!this.tronWeb.isAddress(to)) {
      throw new Error("Invalid recipient provided");
    }
    if (!utils$1.isInteger(amount) || amount <= 0) {
      throw new Error("Invalid amount provided");
    }
    if (utils$1.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils$1.isString(tokenID)) {
      throw new Error("Invalid token ID provided");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address2 = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const transaction2 = await this.tronWeb.transactionBuilder.sendToken(to, amount, tokenID, address2);
    const signedTransaction = await this.sign(transaction2, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Freezes an amount of TRX.
   * Will give bandwidth OR Energy and TRON Power(voting rights)
   * to the owner of the frozen tokens.
   *
   * @param amount - is the number of frozen trx
   * @param duration - is the duration in days to be frozen
   * @param resource - is the type, must be either "ENERGY" or "BANDWIDTH"
   * @param options
   */
  async freezeBalance(amount = 0, duration = 3, resource = "BANDWIDTH", options = {}, receiverAddress) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!["BANDWIDTH", "ENERGY"].includes(resource)) {
      throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
    }
    if (!utils$1.isInteger(amount) || amount <= 0) {
      throw new Error("Invalid amount provided");
    }
    if (!utils$1.isInteger(duration) || duration < 3) {
      throw new Error("Invalid duration provided, minimum of 3 days");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address2 = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const freezeBalance = await this.tronWeb.transactionBuilder.freezeBalance(amount, duration, resource, address2, receiverAddress);
    const signedTransaction = await this.sign(freezeBalance, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Unfreeze TRX that has passed the minimum freeze duration.
   * Unfreezing will remove bandwidth and TRON Power.
   *
   * @param resource - is the type, must be either "ENERGY" or "BANDWIDTH"
   * @param options
   */
  async unfreezeBalance(resource = "BANDWIDTH", options = {}, receiverAddress) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!["BANDWIDTH", "ENERGY"].includes(resource)) {
      throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address2 = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const unfreezeBalance = await this.tronWeb.transactionBuilder.unfreezeBalance(resource, address2, receiverAddress);
    const signedTransaction = await this.sign(unfreezeBalance, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Modify account name
   * Note: Username is allowed to edit only once.
   *
   * @param privateKey - Account private Key
   * @param accountName - name of the account
   *
   * @return modified Transaction Object
   */
  async updateAccount(accountName, options = {}) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!utils$1.isString(accountName) || !accountName.length) {
      throw new Error("Name must be a string");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address)
      throw Error("Function requires either a private key or address to be set");
    const address2 = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const updateAccount = await this.tronWeb.transactionBuilder.updateAccount(accountName, address2);
    const signedTransaction = await this.sign(updateAccount, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Gets a network modification proposal by ID.
   */
  async getProposal(proposalID) {
    if (!utils$1.isInteger(proposalID) || proposalID < 0) {
      throw new Error("Invalid proposalID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getproposalbyid", {
      id: parseInt(proposalID)
    }, "post");
  }
  /**
   * Lists all network modification proposals.
   */
  async listProposals() {
    const { proposals = [] } = await this.tronWeb.fullNode.request("wallet/listproposals", {}, "post");
    return proposals;
  }
  /**
   * Lists all parameters available for network modification proposals.
   */
  async getChainParameters() {
    const { chainParameter = [] } = await this.tronWeb.fullNode.request("wallet/getchainparameters", {}, "post");
    return chainParameter;
  }
  /**
   * Get the account resources
   */
  async getAccountResources(address2 = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb.fullNode.request("wallet/getaccountresource", {
      address: this.tronWeb.address.toHex(address2)
    }, "post");
  }
  /**
   * Query the amount of resources of a specific resourceType delegated by fromAddress to toAddress
   */
  async getDelegatedResourceV2(fromAddress = this.tronWeb.defaultAddress.hex, toAddress = this.tronWeb.defaultAddress.hex, options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(fromAddress)) {
      throw new Error("Invalid address provided");
    }
    if (!this.tronWeb.isAddress(toAddress)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getdelegatedresourcev2`, {
      fromAddress: toHex(fromAddress),
      toAddress: toHex(toAddress)
    }, "post");
  }
  /**
   * Query the resource delegation index by an account
   */
  async getDelegatedResourceAccountIndexV2(address2 = this.tronWeb.defaultAddress.hex, options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getdelegatedresourceaccountindexv2`, {
      value: toHex(address2)
    }, "post");
  }
  /**
   * Query the amount of delegatable resources of the specified resource Type for target address, unit is sun.
   */
  async getCanDelegatedMaxSize(address2 = this.tronWeb.defaultAddress.hex, resource = "BANDWIDTH", options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    this.validator.notValid([
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getcandelegatedmaxsize`, {
      owner_address: toHex(address2),
      type: resource === "ENERGY" ? 1 : 0
    }, "post");
  }
  /**
   * Remaining times of available unstaking API
   */
  async getAvailableUnfreezeCount(address2 = this.tronWeb.defaultAddress.hex, options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getavailableunfreezecount`, {
      owner_address: toHex(address2)
    }, "post");
  }
  /**
   * Query the withdrawable balance at the specified timestamp
   */
  async getCanWithdrawUnfreezeAmount(address2 = this.tronWeb.defaultAddress.hex, timestamp = Date.now(), options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address2)) {
      throw new Error("Invalid address provided");
    }
    if (!utils$1.isInteger(timestamp) || timestamp < 0) {
      throw new Error("Invalid timestamp provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getcanwithdrawunfreezeamount`, {
      owner_address: toHex(address2),
      timestamp
    }, "post");
  }
  /**
   * Get the exchange ID.
   */
  async getExchangeByID(exchangeID) {
    if (!utils$1.isInteger(exchangeID) || exchangeID < 0) {
      throw new Error("Invalid exchangeID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getexchangebyid", {
      id: exchangeID
    }, "post");
  }
  /**
   * Lists the exchanges
   */
  async listExchanges() {
    return this.tronWeb.fullNode.request("wallet/listexchanges", {}, "post").then(({ exchanges = [] }) => exchanges);
  }
  /**
   * Lists all network modification proposals.
   */
  async listExchangesPaginated(limit = 10, offset2 = 0) {
    return this.tronWeb.fullNode.request("wallet/getpaginatedexchangelist", {
      limit,
      offset: offset2
    }, "post").then(({ exchanges = [] }) => exchanges);
  }
  /**
   * Get info about thre node
   */
  async getNodeInfo() {
    return this.tronWeb.fullNode.request("wallet/getnodeinfo", {}, "post");
  }
  async getTokenListByName(tokenID) {
    if (utils$1.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils$1.isString(tokenID) || !tokenID.length) {
      throw new Error("Invalid token ID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getassetissuelistbyname", {
      value: this.tronWeb.fromUtf8(tokenID)
    }, "post").then((token) => {
      if (Array.isArray(token.assetIssue)) {
        return token.assetIssue.map((t2) => this._parseToken(t2));
      } else if (!token.name) {
        throw new Error("Token does not exist");
      }
      return this._parseToken(token);
    });
  }
  getTokenByID(tokenID) {
    if (utils$1.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils$1.isString(tokenID) || !tokenID.length) {
      throw new Error("Invalid token ID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getassetissuebyid", {
      value: tokenID
    }, "post").then((token) => {
      if (!token.name) {
        throw new Error("Token does not exist");
      }
      return this._parseToken(token);
    });
  }
  async getReward(address2, options = {}) {
    options.confirmed = true;
    return this._getReward(address2, options);
  }
  async getUnconfirmedReward(address2, options = {}) {
    options.confirmed = false;
    return this._getReward(address2, options);
  }
  async getBrokerage(address2, options = {}) {
    options.confirmed = true;
    return this._getBrokerage(address2, options);
  }
  async getUnconfirmedBrokerage(address2, options = {}) {
    options.confirmed = false;
    return this._getBrokerage(address2, options);
  }
  async _getReward(address2 = this.tronWeb.defaultAddress.hex, options) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      address: toHex(address2)
    };
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getReward`, data, "post").then((result = { reward: void 0 }) => {
      if (typeof result.reward === "undefined") {
        throw new Error("Not found.");
      }
      return result.reward;
    });
  }
  async _getBrokerage(address2 = this.tronWeb.defaultAddress.hex, options) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address2
      }
    ]);
    const data = {
      address: toHex(address2)
    };
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getBrokerage`, data, "post").then((result = {}) => {
      if (typeof result.brokerage === "undefined") {
        throw new Error("Not found.");
      }
      return result.brokerage;
    });
  }
  async getBandwidthPrices() {
    return this.tronWeb.fullNode.request("wallet/getbandwidthprices", {}, "post").then((result = {}) => {
      if (typeof result.prices === "undefined") {
        throw new Error("Not found.");
      }
      return result.prices;
    });
  }
  async getEnergyPrices() {
    return this.tronWeb.fullNode.request("wallet/getenergyprices", {}, "post").then((result = {}) => {
      if (typeof result.prices === "undefined") {
        throw new Error("Not found.");
      }
      return result.prices;
    });
  }
}
const getFunctionSelector = (abi2) => {
  if ("stateMutability" in abi2) {
    abi2.stateMutability = abi2.stateMutability ? abi2.stateMutability.toLowerCase() : "nonpayable";
  }
  abi2.type = abi2.type ? abi2.type.toLowerCase() : "";
  if (abi2.type === "fallback" || abi2.type === "receive")
    return "0x";
  const iface = new utils$1.ethersUtils.Interface([abi2]);
  let obj;
  if (abi2.type === "event") {
    obj = iface.getEvent(abi2.name);
  } else {
    obj = iface.getFunction(abi2.name);
  }
  if (obj) {
    return obj.format("sighash");
  }
  throw new Error("unknown function");
};
const decodeOutput = (abi2, output2) => {
  return decodeParamsV2ByABI(abi2, output2);
};
class Method {
  constructor(contract, abi2) {
    __publicField(this, "tronWeb");
    __publicField(this, "contract");
    __publicField(this, "abi");
    __publicField(this, "name");
    __publicField(this, "inputs");
    __publicField(this, "outputs");
    __publicField(this, "functionSelector");
    __publicField(this, "signature");
    __publicField(this, "defaultOptions");
    this.tronWeb = contract.tronWeb;
    this.contract = contract;
    this.abi = abi2;
    this.name = abi2.name || abi2.type;
    this.inputs = abi2.inputs || [];
    this.outputs = [];
    if ("outputs" in abi2 && abi2.outputs) {
      this.outputs = abi2.outputs;
    }
    this.functionSelector = getFunctionSelector(abi2);
    this.signature = sha3(this.functionSelector, false).slice(0, 8);
    this.defaultOptions = {
      feeLimit: this.tronWeb.feeLimit,
      callValue: 0,
      userFeePercentage: 100,
      shouldPollResponse: false
      // Only used for sign()
    };
  }
  decodeInput(data) {
    const abi2 = JSON.parse(JSON.stringify(this.abi));
    abi2.outputs = abi2.inputs;
    return decodeOutput(abi2, "0x" + data);
  }
  onMethod(...args) {
    let rawParameter = "";
    if (this.abi && !/event/i.test(this.abi.type)) {
      rawParameter = encodeParamsV2ByABI(this.abi, args);
    }
    return {
      call: async (options = {}) => {
        options = {
          ...options,
          rawParameter
        };
        return await this._call([], [], options);
      },
      send: async (options = {}, privateKey = this.tronWeb.defaultPrivateKey) => {
        options = {
          ...options,
          rawParameter
        };
        return await this._send([], [], options, privateKey);
      }
    };
  }
  async _call(types, args, options = {}) {
    if (types.length !== args.length) {
      throw new Error("Invalid argument count provided");
    }
    if (!this.contract.address) {
      throw new Error("Smart contract is missing address");
    }
    if (!this.contract.deployed) {
      throw new Error("Calling smart contracts requires you to load the contract first");
    }
    if ("stateMutability" in this.abi) {
      const { stateMutability } = this.abi;
      if (stateMutability && !["pure", "view"].includes(stateMutability.toLowerCase())) {
        throw new Error(`Methods with state mutability "${stateMutability}" must use send()`);
      }
    }
    options = {
      ...this.defaultOptions,
      from: this.tronWeb.defaultAddress.hex,
      ...options,
      _isConstant: true
    };
    const parameters = args.map((value, index2) => ({
      type: types[index2],
      value
    }));
    const transaction2 = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, options, parameters, options.from ? this.tronWeb.address.toHex(options.from) : void 0);
    if (!utils$1.hasProperty(transaction2, "constant_result")) {
      throw new Error("Failed to execute");
    }
    const len = transaction2.constant_result[0].length;
    if (len === 0 || len % 64 === 8) {
      let msg = "The call has been reverted or has thrown an error.";
      if (len !== 0) {
        msg += " Error message: ";
        let msg2 = "";
        const chunk = transaction2.constant_result[0].substring(8);
        for (let i = 0; i < len - 8; i += 64) {
          msg2 += this.tronWeb.toUtf8(chunk.substring(i, i + 64));
        }
        msg += msg2.replace(/(\u0000|\u000b|\f)+/g, " ").replace(/ +/g, " ").replace(/\s+$/g, "");
      }
      throw new Error(msg);
    }
    let output2 = decodeOutput(this.abi, "0x" + transaction2.constant_result[0]);
    if (output2.length === 1 && Object.keys(output2).length === 1) {
      output2 = output2[0];
    }
    return output2;
  }
  async _send(types, args, options = {}, privateKey = this.tronWeb.defaultPrivateKey) {
    if (types.length !== args.length) {
      throw new Error("Invalid argument count provided");
    }
    if (!this.contract.address) {
      throw new Error("Smart contract is missing address");
    }
    if (!this.contract.deployed) {
      throw new Error("Calling smart contracts requires you to load the contract first");
    }
    const { stateMutability } = this.abi;
    if (["pure", "view"].includes(stateMutability.toLowerCase())) {
      throw new Error(`Methods with state mutability "${stateMutability}" must use call()`);
    }
    if (!["payable"].includes(stateMutability.toLowerCase())) {
      options.callValue = 0;
    }
    options = {
      ...this.defaultOptions,
      from: this.tronWeb.defaultAddress.hex,
      ...options
    };
    const parameters = args.map((value, index2) => ({
      type: types[index2],
      value
    }));
    const address2 = privateKey ? this.tronWeb.address.fromPrivateKey(privateKey) : this.tronWeb.defaultAddress.base58;
    const transaction2 = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, options, parameters, this.tronWeb.address.toHex(address2));
    if (!transaction2.result || !transaction2.result.result) {
      throw new Error("Unknown error: " + JSON.stringify(transaction2, null, 2));
    }
    const signedTransaction = await this.tronWeb.trx.sign(transaction2.transaction, privateKey);
    if (!signedTransaction.signature) {
      if (!privateKey) {
        throw new Error("Transaction was not signed properly");
      }
      throw new Error("Invalid private key provided");
    }
    const broadcast = await this.tronWeb.trx.sendRawTransaction(signedTransaction);
    if (broadcast.code) {
      const err = {
        error: broadcast.code,
        message: broadcast.code
      };
      if (broadcast.message)
        err.message = this.tronWeb.toUtf8(broadcast.message);
      const error = new Error(err.message);
      error.error = broadcast.code;
      throw error;
    }
    if (!options.shouldPollResponse) {
      return signedTransaction.txID;
    }
    const checkResult = async (index2) => {
      if (index2 === (options.pollTimes || 20)) {
        const error = new Error("Cannot find result in solidity node");
        error.error = "Cannot find result in solidity node";
        error.transaction = signedTransaction;
        throw error;
      }
      const output2 = await this.tronWeb.trx.getTransactionInfo(signedTransaction.txID);
      if (!Object.keys(output2).length) {
        await new Promise((r2) => setTimeout(r2, 3e3));
        return checkResult(index2 + 1);
      }
      if (output2.result && output2.result === "FAILED") {
        const error = new Error(this.tronWeb.toUtf8(output2.resMessage));
        error.error = this.tronWeb.toUtf8(output2.resMessage);
        error.transaction = signedTransaction;
        error.output = output2;
        throw error;
      }
      if (!utils$1.hasProperty(output2, "contractResult")) {
        const error = new Error("Failed to execute: " + JSON.stringify(output2, null, 2));
        error.error = "Failed to execute: " + JSON.stringify(output2, null, 2);
        error.transaction = signedTransaction;
        error.output = output2;
        throw error;
      }
      if (options.rawResponse) {
        return output2;
      }
      let decoded = decodeOutput(this.abi, "0x" + output2.contractResult[0]);
      if (decoded.length === 1 && Object.keys(decoded).length === 1) {
        decoded = decoded[0];
      }
      if (options.keepTxID) {
        return [signedTransaction.txID, decoded];
      }
      return decoded;
    };
    return checkResult(0);
  }
}
class Contract {
  constructor(tronWeb, abi2 = [], address2) {
    __publicField(this, "tronWeb");
    __publicField(this, "abi");
    __publicField(this, "address");
    __publicField(this, "eventListener");
    __publicField(this, "bytecode");
    __publicField(this, "deployed");
    __publicField(this, "lastBlock");
    __publicField(this, "methods");
    __publicField(this, "methodInstances");
    __publicField(this, "props");
    if (!tronWeb || !(tronWeb instanceof TronWeb))
      throw new Error("Expected instance of TronWeb");
    this.tronWeb = tronWeb;
    this.address = address2;
    this.abi = abi2;
    this.eventListener = false;
    this.bytecode = false;
    this.deployed = false;
    this.lastBlock = false;
    this.methods = {};
    this.methodInstances = {};
    this.props = [];
    if (utils$1.address.isAddress(address2)) {
      this.deployed = true;
    } else {
      this.address = false;
    }
    this.loadAbi(abi2);
  }
  hasProperty(property) {
    return this.hasOwnProperty(property) || this.__proto__.hasOwnProperty(property);
  }
  loadAbi(abi2) {
    this.abi = abi2;
    this.methods = {};
    this.props.forEach((prop) => delete this[prop]);
    abi2.forEach((func) => {
      if (!func.type || /constructor|error/i.test(func.type))
        return;
      const method = new Method(this, func);
      const methodCall = method.onMethod.bind(method);
      const { name, functionSelector, signature: signature2 } = method;
      this.methods[name] = methodCall;
      this.methods[functionSelector] = methodCall;
      this.methods[signature2] = methodCall;
      this.methodInstances[name] = method;
      this.methodInstances[functionSelector] = method;
      this.methodInstances[signature2] = method;
      if (!this.hasProperty(name)) {
        this[name] = methodCall;
        this.props.push(name);
      }
      if (!this.hasProperty(functionSelector)) {
        this[functionSelector] = methodCall;
        this.props.push(functionSelector);
      }
      if (!this.hasProperty(signature2)) {
        this[signature2] = methodCall;
        this.props.push(signature2);
      }
    });
  }
  decodeInput(data) {
    const methodName = data.substring(0, 8);
    const inputData = data.substring(8);
    if (!this.methodInstances[methodName])
      throw new Error("Contract method " + methodName + " not found");
    const methodInstance = this.methodInstances[methodName];
    return {
      name: methodInstance.name,
      params: this.methodInstances[methodName].decodeInput(inputData)
    };
  }
  async new(options, privateKey = this.tronWeb.defaultPrivateKey) {
    const address2 = this.tronWeb.address.fromPrivateKey(privateKey);
    const transaction2 = await this.tronWeb.transactionBuilder.createSmartContract(options, address2);
    const signedTransaction = await this.tronWeb.trx.sign(transaction2, privateKey);
    const contract = await this.tronWeb.trx.sendRawTransaction(signedTransaction);
    if (contract.code) {
      throw {
        error: contract.code,
        message: this.tronWeb.toUtf8(contract.message)
      };
    }
    await utils$1.sleep(3e3);
    return this.at(signedTransaction.contract_address);
  }
  async at(contractAddress) {
    try {
      const contract = await this.tronWeb.trx.getContract(contractAddress);
      if (!contract.contract_address) {
        throw new Error("Unknown error: " + JSON.stringify(contract, null, 2));
      }
      this.address = contract.contract_address;
      this.bytecode = contract.bytecode;
      this.deployed = true;
      this.loadAbi(contract.abi ? contract.abi.entrys ? contract.abi.entrys : [] : []);
      return this;
    } catch (ex) {
      if (ex.toString().includes("does not exist")) {
        throw new Error("Contract has not been deployed on the network");
      }
      throw new Error(ex);
    }
  }
}
class Plugin {
  constructor(tronWeb, options = {}) {
    __publicField(this, "tronWeb");
    __publicField(this, "pluginNoOverride");
    __publicField(this, "disablePlugins");
    if (!tronWeb || !(tronWeb instanceof TronWeb))
      throw new Error("Expected instance of TronWeb");
    this.tronWeb = tronWeb;
    this.pluginNoOverride = ["register"];
    this.disablePlugins = !!options.disablePlugins;
  }
  register(Plugin2, options) {
    let pluginInterface = {
      requires: "0.0.0",
      components: {}
    };
    const result = {
      libs: [],
      plugged: [],
      skipped: [],
      error: void 0
    };
    if (this.disablePlugins) {
      result.error = "This instance of TronWeb has plugins disabled.";
      return result;
    }
    const plugin = new Plugin2(this.tronWeb);
    if (utils$1.isFunction(plugin.pluginInterface)) {
      pluginInterface = plugin.pluginInterface(options);
    }
    if (semver.satisfies(TronWeb.version, pluginInterface.requires)) {
      if (pluginInterface.fullClass) {
        const className = plugin.constructor.name;
        const classInstanceName = className.substring(0, 1).toLowerCase() + className.substring(1);
        if (className !== classInstanceName) {
          Object.assign(TronWeb, {
            [className]: Plugin2
          });
          Object.assign(this.tronWeb, {
            [classInstanceName]: plugin
          });
          result.libs.push(className);
        }
      } else {
        for (const component in pluginInterface.components) {
          if (!this.tronWeb.hasOwnProperty(component)) {
            continue;
          }
          const methods = pluginInterface.components[component];
          const pluginNoOverride = this.tronWeb[component].pluginNoOverride || [];
          for (const method in methods) {
            if (method === "constructor" || this.tronWeb[component][method] && (pluginNoOverride.includes(method) || // blacklisted methods
            /^_/.test(method))) {
              result.skipped.push(method);
              continue;
            }
            this.tronWeb[component][method] = methods[method].bind(this.tronWeb[component]);
            result.plugged.push(method);
          }
        }
      }
    } else {
      throw new Error("The plugin is not compatible with this version of TronWeb");
    }
    return result;
  }
}
let Event$1 = class Event2 {
  constructor(tronWeb) {
    __publicField(this, "tronWeb");
    if (!tronWeb || !(tronWeb instanceof TronWeb))
      throw new Error("Expected instance of TronWeb");
    this.tronWeb = tronWeb;
  }
  setServer(eventServer, healthcheck = "healthcheck") {
    if (!eventServer)
      return this.tronWeb.eventServer = void 0;
    if (utils$1.isString(eventServer))
      eventServer = new HttpProvider(eventServer);
    if (!this.tronWeb.isValidProvider(eventServer))
      throw new Error("Invalid event server provided");
    this.tronWeb.eventServer = eventServer;
    this.tronWeb.eventServer.isConnected = () => this.tronWeb.eventServer.request(healthcheck).then(() => true).catch(() => false);
  }
  async getEventsByContractAddress(contractAddress, options = {}) {
    const newOptions = Object.assign({
      limit: 20
    }, options);
    const { eventName, blockNumber, onlyUnconfirmed, onlyConfirmed, minBlockTimestamp, maxBlockTimestamp, orderBy, fingerprint } = newOptions;
    let { limit } = newOptions;
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    if (!this.tronWeb.isAddress(contractAddress)) {
      throw new Error("Invalid contract address provided");
    }
    if (typeof minBlockTimestamp !== "undefined" && !utils$1.isInteger(minBlockTimestamp)) {
      throw new Error("Invalid minBlockTimestamp provided");
    }
    if (typeof maxBlockTimestamp !== "undefined" && !utils$1.isInteger(maxBlockTimestamp)) {
      throw new Error("Invalid maxBlockTimestamp provided");
    }
    if (utils$1.isInteger(limit) && limit > 200) {
      console.warn("Defaulting to maximum accepted limit: 200");
      limit = 200;
    }
    const qs = {};
    if (eventName)
      qs.event_name = eventName;
    if (blockNumber)
      qs.block_number = blockNumber;
    if (typeof onlyUnconfirmed === "boolean")
      qs.only_unconfirmed = onlyUnconfirmed;
    if (typeof onlyConfirmed === "boolean")
      qs.only_confirmed = onlyConfirmed;
    if (minBlockTimestamp)
      qs.min_block_timestamp = minBlockTimestamp;
    if (maxBlockTimestamp)
      qs.max_block_timestamp = maxBlockTimestamp;
    if (orderBy)
      qs.order_by = orderBy;
    if (fingerprint)
      qs.fingerprint = fingerprint;
    if (utils$1.isInteger(limit))
      qs.limit = limit;
    const res = await this.tronWeb.eventServer.request(`v1/contracts/${this.tronWeb.address.fromHex(contractAddress)}/events?${new URLSearchParams(qs).toString()}`);
    if (res.success) {
      return res;
    }
    throw new Error(res.error);
  }
  async getEventsByTransactionID(transactionID, options = {}) {
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    const qs = {};
    if (typeof options.only_unconfirmed === "boolean") {
      qs.only_unconfirmed = options.only_unconfirmed;
    }
    if (typeof options.only_confirmed === "boolean") {
      qs.only_confirmed = options.only_confirmed;
    }
    return this.tronWeb.eventServer.request(`v1/transactions/${transactionID}/events?${new URLSearchParams(qs).toString()}`).then((res) => {
      if (res.success) {
        return res;
      }
      throw new Error(JSON.parse(res.error).message);
    });
  }
  async getEventsByBlockNumber(blockNumber, options = {}) {
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    const qs = {};
    if (typeof options.only_confirmed === "boolean") {
      qs.only_confirmed = options.only_confirmed;
    }
    if (options.limit) {
      qs.limit = options.limit;
    }
    if (options.fingerprint) {
      qs.fingerprint = options.fingerprint;
    }
    return this.tronWeb.eventServer.request(`v1/blocks/${blockNumber}/events?${new URLSearchParams(qs).toString()}`).then((res) => {
      if (res.success) {
        return res;
      }
      throw new Error(res.error);
    });
  }
  async getEventsOfLatestBlock(options = {}) {
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    const qs = {};
    if (typeof options.only_confirmed === "boolean") {
      qs.only_confirmed = options.only_confirmed;
    }
    return this.tronWeb.eventServer.request(`v1/blocks/latest/events?${new URLSearchParams(qs).toString()}`).then((res) => {
      if (res.success) {
        return res;
      }
      throw new Error(res.error);
    });
  }
};
const DEFAULT_VERSION = "4.7.1";
const FEE_LIMIT = 15e7;
const version = "6.0.0";
function isValidOptions(options) {
  return !!options && typeof options === "object" && (!!options.fullNode || !!options.fullHost);
}
const _TronWeb = class _TronWeb extends EventEmitter$1 {
  constructor(options, solidityNode = "", eventServer, privateKey = "") {
    super();
    __publicField(this, "providers");
    __publicField(this, "BigNumber");
    __publicField(this, "transactionBuilder");
    __publicField(this, "trx");
    __publicField(this, "plugin");
    __publicField(this, "event");
    __publicField(this, "version");
    __publicField(this, "utils");
    __publicField(this, "defaultBlock");
    __publicField(this, "defaultPrivateKey");
    __publicField(this, "defaultAddress");
    __publicField(this, "fullnodeVersion");
    __publicField(this, "feeLimit");
    __publicField(this, "fullNode");
    __publicField(this, "solidityNode");
    __publicField(this, "eventServer");
    __publicField(this, "address");
    __publicField(this, "sha3");
    __publicField(this, "toHex");
    __publicField(this, "toUtf8");
    __publicField(this, "fromUtf8");
    __publicField(this, "toAscii");
    __publicField(this, "fromAscii");
    __publicField(this, "toDecimal");
    __publicField(this, "fromDecimal");
    __publicField(this, "fromSun");
    __publicField(this, "toSun");
    __publicField(this, "toBigNumber");
    __publicField(this, "isAddress");
    __publicField(this, "createAccount");
    __publicField(this, "createRandom");
    __publicField(this, "fromMnemonic");
    let fullNode;
    let headers = false;
    let eventHeaders = false;
    if (isValidOptions(options)) {
      fullNode = options.fullNode || options.fullHost;
      solidityNode = options.solidityNode || options.fullHost;
      eventServer = options.eventServer || options.fullHost;
      headers = options.headers || false;
      eventHeaders = options.eventHeaders || headers;
      privateKey = options.privateKey;
    } else {
      fullNode = options;
    }
    if (utils$1.isString(fullNode))
      fullNode = new providers.HttpProvider(fullNode);
    if (utils$1.isString(solidityNode))
      solidityNode = new providers.HttpProvider(solidityNode);
    if (utils$1.isString(eventServer))
      eventServer = new providers.HttpProvider(eventServer);
    this.event = new Event$1(this);
    this.transactionBuilder = new TransactionBuilder(this);
    this.trx = new Trx(this);
    this.plugin = new Plugin(this, {
      disablePlugins: isValidOptions(options) ? options.disablePlugins : false
    });
    this.utils = utils$1;
    this.setFullNode(fullNode);
    this.setSolidityNode(solidityNode);
    this.setEventServer(eventServer);
    this.providers = providers;
    this.BigNumber = BigNumber;
    this.defaultBlock = false;
    this.defaultPrivateKey = false;
    this.defaultAddress = {
      hex: false,
      base58: false
    };
    this.version = _TronWeb.version;
    this.sha3 = _TronWeb.sha3;
    this.fromUtf8 = _TronWeb.fromUtf8;
    this.address = _TronWeb.address;
    this.toAscii = _TronWeb.toAscii;
    this.toUtf8 = _TronWeb.toUtf8;
    this.isAddress = _TronWeb.isAddress;
    this.fromAscii = _TronWeb.fromAscii;
    this.toHex = _TronWeb.toHex;
    this.toBigNumber = _TronWeb.toBigNumber;
    this.toDecimal = _TronWeb.toDecimal;
    this.fromDecimal = _TronWeb.fromDecimal;
    this.toSun = _TronWeb.toSun;
    this.fromSun = _TronWeb.fromSun;
    this.createAccount = _TronWeb.createAccount;
    this.createRandom = _TronWeb.createRandom;
    this.fromMnemonic = _TronWeb.fromMnemonic;
    if (privateKey)
      this.setPrivateKey(privateKey);
    this.fullnodeVersion = DEFAULT_VERSION;
    this.feeLimit = FEE_LIMIT;
    if (headers) {
      this.setFullNodeHeader(headers);
    }
    if (eventHeaders) {
      this.setEventHeader(eventHeaders);
    }
  }
  async getFullnodeVersion() {
    try {
      const nodeInfo = await this.trx.getNodeInfo();
      this.fullnodeVersion = nodeInfo.configNodeInfo.codeVersion;
      if (this.fullnodeVersion.split(".").length === 2) {
        this.fullnodeVersion += ".0";
      }
    } catch (err) {
      this.fullnodeVersion = DEFAULT_VERSION;
    }
  }
  setDefaultBlock(blockID = false) {
    if ([false, "latest", "earliest", 0].includes(blockID)) {
      return this.defaultBlock = blockID;
    }
    if (!utils$1.isInteger(blockID) || !blockID)
      throw new Error("Invalid block ID provided");
    return this.defaultBlock = Math.abs(blockID);
  }
  setPrivateKey(privateKey) {
    try {
      this.setAddress(_TronWeb.address.fromPrivateKey(privateKey));
    } catch {
      throw new Error("Invalid private key provided");
    }
    this.defaultPrivateKey = privateKey;
    this.emit("privateKeyChanged", privateKey);
  }
  setAddress(address2) {
    if (!_TronWeb.isAddress(address2))
      throw new Error("Invalid address provided");
    const hex = _TronWeb.address.toHex(address2);
    const base582 = _TronWeb.address.fromHex(address2);
    if (this.defaultPrivateKey && _TronWeb.address.fromPrivateKey(this.defaultPrivateKey) !== base582)
      this.defaultPrivateKey = false;
    this.defaultAddress = {
      hex,
      base58: base582
    };
    this.emit("addressChanged", { hex, base58: base582 });
  }
  fullnodeSatisfies(version2) {
    return semver.satisfies(this.fullnodeVersion, version2);
  }
  isValidProvider(provider) {
    return Object.values(providers).some((knownProvider) => provider instanceof knownProvider);
  }
  setFullNode(fullNode) {
    if (isString$1(fullNode))
      fullNode = new providers.HttpProvider(fullNode);
    if (!this.isValidProvider(fullNode))
      throw new Error("Invalid full node provided");
    this.fullNode = fullNode;
    this.fullNode.setStatusPage("wallet/getnowblock");
  }
  setSolidityNode(solidityNode) {
    if (utils$1.isString(solidityNode))
      solidityNode = new providers.HttpProvider(solidityNode);
    if (!this.isValidProvider(solidityNode))
      throw new Error("Invalid solidity node provided");
    this.solidityNode = solidityNode;
    this.solidityNode.setStatusPage("walletsolidity/getnowblock");
  }
  setEventServer(eventServer, healthcheck) {
    this.event.setServer(eventServer, healthcheck);
  }
  setHeader(headers = {}) {
    const fullNode = new providers.HttpProvider(this.fullNode.host, 3e4, "", "", headers);
    const solidityNode = new providers.HttpProvider(this.solidityNode.host, 3e4, "", "", headers);
    const eventServer = new providers.HttpProvider(this.eventServer.host, 3e4, "", "", headers);
    this.setFullNode(fullNode);
    this.setSolidityNode(solidityNode);
    this.setEventServer(eventServer);
  }
  setFullNodeHeader(headers = {}) {
    const fullNode = new providers.HttpProvider(this.fullNode.host, 3e4, "", "", headers);
    const solidityNode = new providers.HttpProvider(this.solidityNode.host, 3e4, "", "", headers);
    this.setFullNode(fullNode);
    this.setSolidityNode(solidityNode);
  }
  setEventHeader(headers = {}) {
    const eventServer = new providers.HttpProvider(this.eventServer.host, 3e4, "", "", headers);
    this.setEventServer(eventServer);
  }
  currentProviders() {
    return {
      fullNode: this.fullNode,
      solidityNode: this.solidityNode,
      eventServer: this.eventServer
    };
  }
  currentProvider() {
    return this.currentProviders();
  }
  getEventResult(...params) {
    return this.event.getEventsByContractAddress(...params);
  }
  getEventByTransactionID(...params) {
    return this.event.getEventsByTransactionID(...params);
  }
  contract(abi2 = [], address2) {
    return new Contract(this, abi2, address2);
  }
  static get address() {
    return {
      fromHex(address2) {
        return fromHex(address2);
      },
      toHex(address2) {
        return toHex$1(address2);
      },
      toChecksumAddress(address2) {
        return toChecksumAddress(address2);
      },
      isChecksumAddress(address2) {
        return isChecksumAddress(address2);
      },
      fromPrivateKey(privateKey, strict = false) {
        return fromPrivateKey(privateKey, strict);
      }
    };
  }
  static sha3(string2, prefix = true) {
    return (prefix ? "0x" : "") + keccak256(Buffer.from(string2, "utf-8")).toString().substring(2);
  }
  static toHex(val) {
    if (utils$1.isBoolean(val))
      return _TronWeb.fromDecimal(+val);
    if (utils$1.isBigNumber(val))
      return _TronWeb.fromDecimal(val);
    if (typeof val === "object")
      return _TronWeb.fromUtf8(JSON.stringify(val));
    if (utils$1.isString(val)) {
      if (/^(-|)0x/.test(val))
        return val;
      if (!isFinite(val) || /^\s*$/.test(val))
        return _TronWeb.fromUtf8(val);
    }
    const result = _TronWeb.fromDecimal(val);
    if (result === "0xNaN") {
      throw new Error("The passed value is not convertible to a hex string");
    } else {
      return result;
    }
  }
  static toUtf8(hex) {
    if (utils$1.isHex(hex)) {
      hex = hex.replace(/^0x/, "");
      return Buffer.from(hex, "hex").toString("utf8");
    } else {
      throw new Error("The passed value is not a valid hex string");
    }
  }
  static fromUtf8(string2) {
    if (!utils$1.isString(string2)) {
      throw new Error("The passed value is not a valid utf-8 string");
    }
    return "0x" + Buffer.from(string2, "utf8").toString("hex");
  }
  static toAscii(hex) {
    if (utils$1.isHex(hex)) {
      let str = "";
      let i = 0;
      const l2 = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l2; i += 2) {
        const code2 = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code2);
      }
      return str;
    } else {
      throw new Error("The passed value is not a valid hex string");
    }
  }
  static fromAscii(string2, padding2) {
    if (!utils$1.isString(string2)) {
      throw new Error("The passed value is not a valid utf-8 string");
    }
    return "0x" + Buffer.from(string2, "ascii").toString("hex").padEnd(padding2, "0");
  }
  static toDecimal(value) {
    return _TronWeb.toBigNumber(value).toNumber();
  }
  static fromDecimal(value) {
    const number2 = _TronWeb.toBigNumber(value);
    const result = number2.toString(16);
    return number2.isLessThan(0) ? "-0x" + result.substr(1) : "0x" + result;
  }
  static fromSun(sun) {
    const trx = _TronWeb.toBigNumber(sun).div(1e6);
    return utils$1.isBigNumber(sun) ? trx : trx.toString(10);
  }
  static toSun(trx) {
    const sun = _TronWeb.toBigNumber(trx).times(1e6);
    return utils$1.isBigNumber(trx) ? sun : sun.toString(10);
  }
  static toBigNumber(amount = 0) {
    if (utils$1.isBigNumber(amount))
      return amount;
    if (utils$1.isString(amount) && /^(-|)0x/.test(amount))
      return new BigNumber(amount.replace("0x", ""), 16);
    return new BigNumber(amount.toString(10), 10);
  }
  static isAddress(address2 = "") {
    return isAddress(address2);
  }
  static async createAccount() {
    const account = utils$1.accounts.generateAccount();
    return account;
  }
  static createRandom(...params) {
    const account = utils$1.accounts.generateRandom(...params);
    return account;
  }
  static fromMnemonic(...params) {
    const account = utils$1.accounts.generateAccountWithMnemonic(...params);
    return account;
  }
  async isConnected() {
    return {
      fullNode: await this.fullNode.isConnected(),
      solidityNode: await this.solidityNode.isConnected(),
      eventServer: this.eventServer && await this.eventServer.isConnected()
    };
  }
};
__publicField(_TronWeb, "version", version);
let TronWeb = _TronWeb;
function getAddress(address2) {
  return TronWeb.address.toHex(address2).replace(ADDRESS_PREFIX_REGEX, "0x");
}
function getTronAddress(address2) {
  return TronWeb.address.toHex(address2);
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getTronAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type2) {
  {
    const match = type2.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), "invalid numeric width", "type", type2);
      const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);
      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type2}`, "value", value);
        return toBeHex(signed ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type2.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type2);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type2}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type2) {
    case "trcToken":
      return getBaseEncoder("uint256");
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type: type2 }) => type2 + " " + name2).join(",")})`;
}
const _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(types) {
    __privateAdd(this, _getEncoder2);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types2, void 0);
    __privateAdd(this, _fullTypes2, void 0);
    __privateAdd(this, _encoderCache2, void 0);
    __privateSet(this, _types2, JSON.stringify(types));
    __privateSet(this, _fullTypes2, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache2, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    Object.keys(types).forEach((type2) => {
      links.set(type2, /* @__PURE__ */ new Set());
      parents.set(type2, []);
      subtypes.set(type2, /* @__PURE__ */ new Set());
    });
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
        uniqueNames.add(field.name);
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        const encoder2 = getBaseEncoder(baseType);
        if (encoder2) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type2, found) {
      assertArgument(!found.has(type2), `circular type reference to ${JSON.stringify(type2)}`, "types", types);
      found.add(type2);
      for (const child of links.get(type2)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type2);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      __privateGet(this, _fullTypes2).set(name, encodeType(name, types[name]) + st.map((t2) => encodeType(t2, types[t2])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types2));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type2) {
    let encoder2 = __privateGet(this, _encoderCache2).get(type2);
    if (!encoder2) {
      encoder2 = __privateMethod(this, _getEncoder2, getEncoder_fn2).call(this, type2);
      __privateGet(this, _encoderCache2).set(type2, encoder2);
    }
    return encoder2;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes2).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type2, value) {
    return this.getEncoder(type2)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type2, value, callback) {
    {
      const encoder2 = getBaseEncoder(type2);
      if (encoder2) {
        return callback(type2, value);
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
      return value.map((v2) => this._visit(match[1], v2, callback));
    }
    const fields = this.types[type2];
    if (fields) {
      return fields.reduce((accum, { name, type: type3 }) => {
        accum[name] = this._visit(type3, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type2}`, "type", type2);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type2 = domainFieldTypes[name];
      assertArgument(type2, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type: type2 });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat(["0x1901", _TypedDataEncoder.hashDomain(domain), _TypedDataEncoder.from(types).hash(value)]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder2 = _TypedDataEncoder.from(types);
    encoder2.visit(value, (type2, value2) => {
      if (type2 === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder2.visit(value, (type2, value2) => {
      if (type2 === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder2 = _TypedDataEncoder.from(types);
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder2.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder2.primaryType,
      message: encoder2.visit(value, (type2, value2) => {
        if (type2.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type2.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type2) {
          case "trcToken":
            return getBigInt(value2).toString();
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type2);
      })
    };
  }
};
_types2 = new WeakMap();
_fullTypes2 = new WeakMap();
_encoderCache2 = new WeakMap();
_getEncoder2 = new WeakSet();
getEncoder_fn2 = function(type2) {
  {
    const encoder2 = getBaseEncoder(type2);
    if (encoder2) {
      return encoder2;
    }
  }
  const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
  if (match) {
    const subtype = match[1];
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes2).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type2];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes2).get(type2));
    return (value) => {
      const values = fields.map(({ name, type: type3 }) => {
        const result = this.getEncoder(type3)(value[name]);
        if (__privateGet(this, _fullTypes2).has(type3)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type2}`, "type", type2);
};
let TypedDataEncoder = _TypedDataEncoder;
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`positive integer expected, not ${n2}`);
}
function isBytes$1(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b2, ...lengths) {
  if (!isBytes$1(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function hash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h2.outputLen);
  number(h2.blockLen);
}
function exists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance2) {
  bytes(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes$1(data);
  bytes(data);
  return data;
}
function concatBytes$1(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    bytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
class Hash4 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues === "function") {
    return crypto$2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi = (a, b2, c) => a & b2 ^ ~a & c;
const Maj = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
class HashMD3 extends Hash4 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished: finished2, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class SHA2564 extends HashMD3 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T12 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T22 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T12 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256$1());
class HMAC3 extends Hash4 {
  constructor(hash$12, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$12);
    const key = toBytes(_key);
    this.iHash = hash$12.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash$12.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash$12.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash2, key, message2) => new HMAC3(hash2, key).update(message2).digest();
hmac.create = (hash2, key) => new HMAC3(hash2, key);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = /* @__PURE__ */ BigInt(0);
const _1n$4 = /* @__PURE__ */ BigInt(1);
const _2n$2 = /* @__PURE__ */ BigInt(2);
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  abytes(bytes2);
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl2 = hex.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi2));
    const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi2] + hex[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array2[ai2] = n1 * 16 + n2;
  }
  return array2;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e2}`);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
function equalBytes(a, b2) {
  if (a.length !== b2.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b2[i];
  return diff === 0;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$3; n2 >>= _1n$4, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$4;
}
function bitSet(n2, pos, value) {
  return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
}
const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v2.fill(1);
    k2.fill(0);
    i = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed = u8n()) => {
    k2 = h2(u8fr([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr([1]), seed);
    v2 = h2();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl2 = v2.slice();
      out.push(sl2);
      len += v2.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators2, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns[type2];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type2}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators2))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abytes,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  isBytes,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$2, u2 = _1n$3;
  while (a !== _0n$2) {
    const q2 = b2 / a;
    const r2 = b2 % a;
    const m2 = x2 - u2 * q2;
    b2 = a, a = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n$3) / _2n$1;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n$3, S2 = 0; Q2 % _2n$1 === _0n$2; Q2 /= _2n$1, S2++)
    ;
  for (Z2 = _2n$1; Z2 < P2 && pow(Z2, legendreC, P2) !== P2 - _1n$3; Z2++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q2);
    let x2 = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n$3 << BigInt(r2 - m2 - 1));
      g = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n$1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$1);
      const v2 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v2);
      const i = Fp2.mul(Fp2.mul(nv, _2n$1), v2);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P2);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p2 = f2.ONE;
  let d = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p2 = f2.mul(p2, d);
    d = f2.sqr(d);
    power >>= _1n$3;
  }
  return p2;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate2 = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate: constTimeNegate2,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p2 = c.ZERO;
      let d = elm;
      while (n2 > _0n$1) {
        if (n2 & _1n$2)
          p2 = p2.add(d);
        d = d.double();
        n2 >>= _1n$2;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base2 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p2;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p2);
          points.push(base2);
        }
        p2 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = opts(W2);
      let p2 = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$2;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate2(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate2(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n2, transform) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr3 extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E2 } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    abytes(data);
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h2(sig.s));
    const r2 = slice(h2(sig.r));
    const shl = s.length / 2;
    const rhl = r2.length / 2;
    const sl2 = h2(shl);
    const rl2 = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes2 = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes2.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y2 } = this.toAffine();
      if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x2);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes2, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I2 = Point.ZERO;
      if (n2 === _0n)
        return I2;
      assertGE(n2);
      if (n2 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I2;
      let k2p = I2;
      let d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d);
        if (k2 & _1n$1)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(n2);
        point = p2;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a, b2) {
      const G2 = Point.BASE;
      const mul2 = (P2, a2) => a2 === _0n || a2 === _1n$1 || !P2.equals(G2) ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
      const sum = mul2(this, a).add(mul2(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y2, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x2, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a = point.toAffine();
      const x2 = Fp2.toBytes(a.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3;
        try {
          y3 = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r2, s, recovery) {
      this.r = r2;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l2 * 2);
      return new Signature2(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r2, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r2, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q2 = Point.BASE.multiply(k2).toAffine();
      const r2 = modN(q2.x);
      if (r2 === _0n)
        return;
      const s = modN(ik2 * modN(m2 + r2 * d));
      if (s === _0n)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n$1);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify2(signature2, msgHash, publicKey2, opts = defaultVerOpts) {
    var _a3;
    const sg2 = signature2;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey2 = ensureBytes("publicKey", publicKey2);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || isBytes(sg2)) {
        try {
          _sig2 = Signature2.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s2 } = sg2;
        _sig2 = new Signature2(r3, s2);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey2);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s } = _sig2;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN(h2 * is2);
    const u2 = modN(r2 * is2);
    const R2 = (_a3 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a3.toAffine();
    if (!R2)
      return false;
    const v2 = modN(R2.x);
    return v2 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify: verify2,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes$1(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create3 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b2) => (a + b2 / _2n) / b2;
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n, P2);
  if (!Fp.eql(Fp.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k2, n2);
      const c2 = divNearest(-b1 * k2, n2);
      let k1 = mod(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256);
BigInt(0);
secp256k1.ProjectivePoint;
function normalizePrivateKeyBytes(priKeyBytes) {
  return hexStr2byteArray(byteArray2hexStr(priKeyBytes).padStart(64, "0"));
}
function getBase58CheckAddress(addressBytes) {
  const hash0 = SHA2565(addressBytes);
  const hash1 = SHA2565(hash0);
  let checkSum = hash1.slice(0, 4);
  checkSum = addressBytes.concat(checkSum);
  return encode58(checkSum);
}
function decodeBase58Address(base58Sting) {
  if (typeof base58Sting != "string")
    return false;
  if (base58Sting.length <= 4)
    return false;
  let address2 = decode58(base58Sting);
  if (base58Sting.length <= 4)
    return false;
  const len = address2.length;
  const offset2 = len - 4;
  const checkSum = address2.slice(offset2);
  address2 = address2.slice(0, offset2);
  const hash0 = SHA2565(address2);
  const hash1 = SHA2565(hash0);
  const checkSum1 = hash1.slice(0, 4);
  if (checkSum[0] == checkSum1[0] && checkSum[1] == checkSum1[1] && checkSum[2] == checkSum1[2] && checkSum[3] == checkSum1[3]) {
    return address2;
  }
  throw new Error("Invalid address provided");
}
function signTransaction(priKeyBytes, transaction2) {
  if (typeof priKeyBytes === "string")
    priKeyBytes = hexStr2byteArray(priKeyBytes);
  const txID = transaction2.txID;
  const signature2 = ECKeySign(hexStr2byteArray(txID), priKeyBytes);
  if (Array.isArray(transaction2.signature)) {
    if (!transaction2.signature.includes(signature2))
      transaction2.signature.push(signature2);
  } else
    transaction2.signature = [signature2];
  return transaction2;
}
function ecRecover(signedData, signature2) {
  signedData = "0x" + signedData.replace(/^0x/, "");
  signature2 = "0x" + signature2.replace(/^0x/, "");
  const recovered = recoverAddress(arrayify(signedData), Signature.from(signature2));
  const tronAddress = ADDRESS_PREFIX + recovered.substring(2);
  return tronAddress;
}
function arrayToBase64String(a) {
  return btoa(String.fromCharCode(...a));
}
function signBytes(privateKey, contents) {
  if (typeof privateKey === "string")
    privateKey = hexStr2byteArray(privateKey);
  const hashBytes = SHA2565(contents);
  const signBytes2 = ECKeySign(hashBytes, privateKey);
  return signBytes2;
}
function _signTypedData(domain, types, value, privateKey) {
  const key = `0x${privateKey.replace(/^0x/, "")}`;
  const signingKey = new SigningKey(key);
  const messageDigest = TypedDataEncoder.hash(domain, types, value);
  const signature2 = signingKey.sign(messageDigest);
  const signatureHex = ["0x", signature2.r.substring(2), signature2.s.substring(2), Number(signature2.v).toString(16)].join("");
  return signatureHex;
}
function getRowBytesFromTransactionBase64(base64Data) {
  const bytesDecode = base64DecodeFromString(base64Data);
  const transaction2 = globalThis.proto.protocol.Transaction.deserializeBinary(bytesDecode);
  const raw = transaction2.getRawData();
  return raw.serializeBinary();
}
function genPriKey() {
  const priKey = secp256k1.utils.randomPrivateKey();
  let priKeyHex = byteArray2hexStr(priKey);
  priKeyHex = priKeyHex.padStart(64, "0");
  return hexStr2byteArray(priKeyHex);
}
function computeAddress(pubBytes) {
  if (pubBytes.length === 65)
    pubBytes = pubBytes.slice(1);
  const hash2 = keccak256(new Uint8Array(pubBytes)).toString().substring(2);
  const addressHex = ADDRESS_PREFIX + hash2.substring(24);
  return hexStr2byteArray(addressHex);
}
function getAddressFromPriKey(priKeyBytes) {
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  return computeAddress(pubBytes);
}
function decode58Check(addressStr) {
  const decodeCheck = decode58(addressStr);
  if (decodeCheck.length <= 4)
    return false;
  const decodeData2 = decodeCheck.slice(0, decodeCheck.length - 4);
  const hash0 = SHA2565(decodeData2);
  const hash1 = SHA2565(hash0);
  if (hash1[0] === decodeCheck[decodeData2.length] && hash1[1] === decodeCheck[decodeData2.length + 1] && hash1[2] === decodeCheck[decodeData2.length + 2] && hash1[3] === decodeCheck[decodeData2.length + 3]) {
    return decodeData2;
  }
  return false;
}
function isAddressValid(base58Str) {
  if (typeof base58Str !== "string")
    return false;
  if (base58Str.length !== ADDRESS_SIZE)
    return false;
  let address2 = decode58(base58Str);
  if (address2.length !== 25)
    return false;
  if (address2[0] !== ADDRESS_PREFIX_BYTE)
    return false;
  const checkSum = address2.slice(21);
  address2 = address2.slice(0, 21);
  const hash0 = SHA2565(address2);
  const hash1 = SHA2565(hash0);
  const checkSum1 = hash1.slice(0, 4);
  if (checkSum[0] == checkSum1[0] && checkSum[1] == checkSum1[1] && checkSum[2] == checkSum1[2] && checkSum[3] == checkSum1[3]) {
    return true;
  }
  return false;
}
function getBase58CheckAddressFromPriKeyBase64String(priKeyBase64String) {
  const priKeyBytes = base64DecodeFromString(priKeyBase64String);
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = computeAddress(pubBytes);
  return getBase58CheckAddress(addressBytes);
}
function getHexStrAddressFromPriKeyBase64String(priKeyBase64String) {
  const priKeyBytes = base64DecodeFromString(priKeyBase64String);
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = computeAddress(pubBytes);
  const addressHex = byteArray2hexStr(addressBytes);
  return addressHex;
}
function getAddressFromPriKeyBase64String(priKeyBase64String) {
  const priKeyBytes = base64DecodeFromString(priKeyBase64String);
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = computeAddress(pubBytes);
  const addressBase64 = base64EncodeToString(addressBytes);
  return addressBase64;
}
function getPubKeyFromPriKey(priKeyBytes) {
  const pubkey = secp256k1.ProjectivePoint.fromPrivateKey(new Uint8Array(normalizePrivateKeyBytes(priKeyBytes)));
  const x2 = pubkey.x;
  const y2 = pubkey.y;
  const xHex = x2.toString(16).padStart(64, "0");
  const yHex = y2.toString(16).padStart(64, "0");
  const pubkeyHex = `04${xHex}${yHex}`;
  const pubkeyBytes = hexStr2byteArray(pubkeyHex);
  return pubkeyBytes;
}
function ECKeySign(hashBytes, priKeyBytes) {
  const signature2 = secp256k1.sign(byteArray2hexStr(hashBytes), byteArray2hexStr(priKeyBytes));
  const r2 = signature2.r.toString(16);
  const s = signature2.s.toString(16);
  const v2 = signature2.recovery + 27;
  return r2.padStart(64, "0") + s.padStart(64, "0") + byte2hexStr(v2);
}
function SHA2565(msgBytes) {
  const msgHex = byteArray2hexStr(msgBytes);
  const hashHex = sha256$1("0x" + msgHex).replace(/^0x/, "");
  return hexStr2byteArray(hashHex);
}
function passwordToAddress(password) {
  const com_priKeyBytes = base64DecodeFromString(password);
  const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);
  return getBase58CheckAddress(com_addressBytes);
}
function pkToAddress(privateKey, strict = false) {
  const com_priKeyBytes = hexStr2byteArray(privateKey, strict);
  const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);
  return getBase58CheckAddress(com_addressBytes);
}
function sha3(string2, prefix = true) {
  return (prefix ? "0x" : "") + keccak256(Buffer.from(string2, "utf-8")).toString().substring(2);
}
const crypto$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ECKeySign,
  SHA256: SHA2565,
  _signTypedData,
  arrayToBase64String,
  computeAddress,
  decode58Check,
  decodeBase58Address,
  ecRecover,
  genPriKey,
  getAddressFromPriKey,
  getAddressFromPriKeyBase64String,
  getBase58CheckAddress,
  getBase58CheckAddressFromPriKeyBase64String,
  getHexStrAddressFromPriKeyBase64String,
  getPubKeyFromPriKey,
  getRowBytesFromTransactionBase64,
  isAddressValid,
  passwordToAddress,
  pkToAddress,
  sha3,
  signBytes,
  signTransaction
}, Symbol.toStringTag, { value: "Module" }));
const INVALID_TRON_PATH_ERROR_MSG = "Invalid tron path provided";
function generateAccount() {
  const priKeyBytes = genPriKey();
  const pubKeyBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = getAddressFromPriKey(priKeyBytes);
  const privateKey = byteArray2hexStr(priKeyBytes);
  const publicKey2 = byteArray2hexStr(pubKeyBytes);
  return {
    privateKey,
    publicKey: publicKey2,
    address: {
      base58: getBase58CheckAddress(addressBytes),
      hex: byteArray2hexStr(addressBytes)
    }
  };
}
function generateRandom(password = "", path = TRON_BIP39_PATH_INDEX_0, wordlist2) {
  const account = HDNodeWallet.createRandom(password, path, wordlist2);
  const result = {
    mnemonic: account.mnemonic,
    privateKey: account.privateKey,
    publicKey: account.signingKey.publicKey,
    address: pkToAddress(account.privateKey.replace(/^0x/, "")),
    path: account.path
  };
  return result;
}
function generateAccountWithMnemonic(mnemonic, path = TRON_BIP39_PATH_INDEX_0, password = "", wordlist2 = null) {
  if (!String(path).match(/^m\/44\'\/195\'/)) {
    throw new Error(INVALID_TRON_PATH_ERROR_MSG);
  }
  const account = HDNodeWallet.fromMnemonic(Mnemonic.fromPhrase(mnemonic, password, wordlist2), path);
  const result = {
    mnemonic: account.mnemonic,
    privateKey: account.privateKey,
    publicKey: account.signingKey.publicKey,
    address: pkToAddress(account.privateKey.replace(/^0x/, ""))
  };
  return result;
}
const accounts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generateAccount,
  generateAccountWithMnemonic,
  generateRandom
}, Symbol.toStringTag, { value: "Module" }));
const TRON_MESSAGE_PREFIX = "TRON Signed Message:\n";
function hashMessage(message2) {
  if (typeof message2 === "string") {
    message2 = toUtf8Bytes(message2);
  } else if (Array.isArray(message2)) {
    message2 = new Uint8Array(message2);
  }
  return keccak256(concat([toUtf8Bytes(TRON_MESSAGE_PREFIX), toUtf8Bytes(String(message2.length)), message2]));
}
function signMessage(message2, privateKey) {
  if (!privateKey.match(/^0x/)) {
    privateKey = "0x" + privateKey;
  }
  const signingKey = new SigningKey(privateKey);
  const messageDigest = hashMessage(message2);
  const signature2 = signingKey.sign(messageDigest);
  return joinSignature(signature2);
}
function verifyMessage(message2, signature2) {
  if (!signature2.match(/^0x/)) {
    signature2 = "0x" + signature2;
  }
  const recovered = recoverAddress(hashMessage(message2), signature2);
  const base58Address = getBase58CheckAddress(hexStr2byteArray(recovered.replace(/^0x/, ADDRESS_PREFIX)));
  return base58Address;
}
const message = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TRON_MESSAGE_PREFIX,
  hashMessage,
  signMessage,
  verifyMessage
}, Symbol.toStringTag, { value: "Module" }));
const utils = {
  ...validations,
  address,
  code,
  accounts,
  base58,
  bytes: bytes$2,
  crypto: crypto$1,
  abi,
  message,
  _TypedDataEncoder: TypedDataEncoder,
  transaction,
  ethersUtils
};
const utils$1 = utils;
var ResourceCode;
(function(ResourceCode2) {
  ResourceCode2[ResourceCode2["BANDWIDTH"] = 0] = "BANDWIDTH";
  ResourceCode2[ResourceCode2["ENERGY"] = 1] = "ENERGY";
  ResourceCode2[ResourceCode2["TRON_POWER"] = 2] = "TRON_POWER";
})(ResourceCode || (ResourceCode = {}));
var TransactionSignWeight_response_code;
(function(TransactionSignWeight_response_code2) {
  TransactionSignWeight_response_code2["ENOUGH_PERMISSION"] = "ENOUGH_PERMISSION";
  TransactionSignWeight_response_code2["NOT_ENOUGH_PERMISSION"] = "NOT_ENOUGH_PERMISSION";
  TransactionSignWeight_response_code2["SIGNATURE_FORMAT_ERROR"] = "SIGNATURE_FORMAT_ERROR";
  TransactionSignWeight_response_code2["COMPUTE_ADDRESS_ERROR"] = "COMPUTE_ADDRESS_ERROR";
  TransactionSignWeight_response_code2["PERMISSION_ERROR"] = "PERMISSION_ERROR";
  TransactionSignWeight_response_code2["OTHER_ERROR"] = "OTHER_ERROR";
})(TransactionSignWeight_response_code || (TransactionSignWeight_response_code = {}));
var BroadcastReturn_response_code;
(function(BroadcastReturn_response_code2) {
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["SUCCESS"] = 0] = "SUCCESS";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["SIGERROR"] = 1] = "SIGERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["CONTRACT_VALIDATE_ERROR"] = 2] = "CONTRACT_VALIDATE_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["CONTRACT_EXE_ERROR"] = 3] = "CONTRACT_EXE_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["BANDWITH_ERROR"] = 4] = "BANDWITH_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["DUP_TRANSACTION_ERROR"] = 5] = "DUP_TRANSACTION_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["TAPOS_ERROR"] = 6] = "TAPOS_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["TOO_BIG_TRANSACTION_ERROR"] = 7] = "TOO_BIG_TRANSACTION_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["TRANSACTION_EXPIRATION_ERROR"] = 8] = "TRANSACTION_EXPIRATION_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["SERVER_BUSY"] = 9] = "SERVER_BUSY";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["NO_CONNECTION"] = 10] = "NO_CONNECTION";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["NOT_ENOUGH_EFFECTIVE_CONNECTION"] = 11] = "NOT_ENOUGH_EFFECTIVE_CONNECTION";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["OTHER_ERROR"] = 20] = "OTHER_ERROR";
})(BroadcastReturn_response_code || (BroadcastReturn_response_code = {}));
var ProposalState;
(function(ProposalState2) {
  ProposalState2[ProposalState2["PENDING"] = 0] = "PENDING";
  ProposalState2[ProposalState2["DISAPPROVED"] = 1] = "DISAPPROVED";
  ProposalState2[ProposalState2["APPROVED"] = 2] = "APPROVED";
  ProposalState2[ProposalState2["CANCELED"] = 3] = "CANCELED";
})(ProposalState || (ProposalState = {}));
var NetworkType;
(function(NetworkType2) {
  NetworkType2["Mainnet"] = "Mainnet";
  NetworkType2["Shasta"] = "Shasta";
  NetworkType2["Nile"] = "Nile";
  NetworkType2["Unknown"] = "Unknown";
})(NetworkType || (NetworkType = {}));
var ChainNetwork;
(function(ChainNetwork2) {
  ChainNetwork2["Mainnet"] = "Mainnet";
  ChainNetwork2["Shasta"] = "Shasta";
  ChainNetwork2["Nile"] = "Nile";
})(ChainNetwork || (ChainNetwork = {}));
function isInBrowser() {
  return typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
}
function isInMobileBrowser() {
  return typeof navigator !== "undefined" && navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i);
}
function useLocalStorage(key, defaultState) {
  const [state, setState] = reactExports.useState(() => {
    try {
      const value = localStorage.getItem(key);
      if (value)
        return JSON.parse(value);
    } catch (error) {
      if (isInBrowser()) {
        console.error(error);
      }
    }
    return defaultState;
  });
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    try {
      if (state === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, JSON.stringify(state));
      }
    } catch (error) {
      if (isInBrowser()) {
        console.error(error);
      }
    }
  }, [state, key]);
  return [state, setState];
}
function printError() {
  console.error(`
You are using WalletContext without provide the WalletContext.Provider.
Please wrap your sub-components with a WalletProvider and provide required values.
`);
}
const DEFAULT_CONTEXT = {
  autoConnect: false,
  connecting: false,
  connected: false,
  disconnecting: false,
  /* eslint-disable */
  select(_name) {
    printError();
  },
  connect() {
    printError();
    return Promise.reject();
  },
  disconnect() {
    printError();
    return Promise.reject();
  },
  signTransaction(_transaction) {
    printError();
    return Promise.reject();
  },
  signMessage(_message) {
    printError();
    return Promise.reject();
  }
  /* eslint-enable */
};
Object.defineProperty(DEFAULT_CONTEXT, "wallets", {
  get() {
    printError();
    return [];
  }
});
Object.defineProperty(DEFAULT_CONTEXT, "wallet", {
  get() {
    printError();
    return null;
  }
});
Object.defineProperty(DEFAULT_CONTEXT, "address", {
  get() {
    printError();
    return null;
  }
});
const WalletContext = reactExports.createContext(DEFAULT_CONTEXT);
function useWallet() {
  return reactExports.useContext(WalletContext);
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function supportTron() {
  return !!(window.tron && window.tron.isTronLink);
}
function supportTronLink() {
  return !!(supportTron() || window.tronLink || window.tronWeb);
}
function isInTronLinkApp() {
  return isInBrowser() && typeof window.iTron !== "undefined";
}
function openTronLink({ dappIcon, dappName } = { dappIcon: "", dappName: "" }) {
  if (!supportTronLink() && isInMobileBrowser() && !isInTronLinkApp()) {
    let defaultDappName = "", defaultDappIcon = "";
    try {
      defaultDappName = document.title;
      const link = document.querySelector('link[rel*="icon"]');
      if (link) {
        defaultDappIcon = new URL(link.getAttribute("href") || "", location.href).toString();
      }
    } catch (e2) {
    }
    const { origin: origin2, pathname, search, hash: hash2 } = window.location;
    const url = origin2 + pathname + search + (hash2.includes("?") ? hash2 : `${hash2}?_=1`);
    const params = {
      action: "open",
      actionId: Date.now() + "",
      callbackUrl: "http://someurl.com",
      // no need callback
      dappIcon: dappIcon || defaultDappIcon,
      dappName: dappName || defaultDappName,
      url,
      protocol: "TronLink",
      version: "1.0",
      chainId: "0x2b6653dc"
    };
    window.location.href = `tronlinkoutside://pull.activity?param=${encodeURIComponent(JSON.stringify(params))}`;
    return true;
  }
  return false;
}
function waitTronwebReady(tronObj) {
  return __awaiter$2(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      const interval = setInterval(() => {
        if (tronObj.tronWeb) {
          clearInterval(interval);
          clearTimeout(timeout);
          resolve();
        }
      }, 50);
      const timeout = setTimeout(() => {
        clearInterval(interval);
        reject("`window.tron.tronweb` is not ready.");
      }, 2e3);
    });
  });
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const chainIdNetworkMap = {
  "0x2b6653dc": NetworkType.Mainnet,
  "0x94a9059e": NetworkType.Shasta,
  "0xcd8690dc": NetworkType.Nile
};
function getNetworkInfoByTronWeb(tronWeb) {
  return __awaiter$1(this, void 0, void 0, function* () {
    var _a3, _b2, _c2;
    const { blockID = "" } = yield tronWeb.trx.getBlockByNumber(0);
    const chainId = `0x${blockID.slice(-8)}`;
    return {
      networkType: chainIdNetworkMap[chainId] || NetworkType.Unknown,
      chainId,
      fullNode: ((_a3 = tronWeb.fullNode) === null || _a3 === void 0 ? void 0 : _a3.host) || "",
      solidityNode: ((_b2 = tronWeb.solidityNode) === null || _b2 === void 0 ? void 0 : _b2.host) || "",
      eventServer: ((_c2 = tronWeb.eventServer) === null || _c2 === void 0 ? void 0 : _c2.host) || ""
    };
  });
}
const TronLinkAdapterName = "TronLink";
class TronLinkAdapter extends Adapter {
  // record if first connect event has emitted or not
  constructor(config2 = {}) {
    super();
    this.name = TronLinkAdapterName;
    this.url = "https://www.tronlink.org/";
    this.icon = "data:image/png;base64,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";
    this._readyState = isInBrowser() ? WalletReadyState.Loading : WalletReadyState.NotFound;
    this._state = AdapterState.Loading;
    this._supportNewTronProtocol = false;
    this._tronLinkMessageHandler = (e2) => {
      var _a3, _b2, _c2, _d2, _e2;
      const message2 = (_a3 = e2.data) === null || _a3 === void 0 ? void 0 : _a3.message;
      if (!message2) {
        return;
      }
      if (message2.action === "accountsChanged") {
        setTimeout(() => {
          var _a4;
          const preAddr = this.address || "";
          if ((_a4 = this._wallet) === null || _a4 === void 0 ? void 0 : _a4.ready) {
            const address2 = message2.data.address;
            this.setAddress(address2);
            this.setState(AdapterState.Connected);
          } else {
            this.setAddress(null);
            this.setState(AdapterState.Disconnect);
          }
          this.emit("accountsChanged", this.address || "", preAddr);
          if (!preAddr && this.address) {
            this.emit("connect", this.address);
          } else if (preAddr && !this.address) {
            this.emit("disconnect");
          }
        }, 200);
      } else if (message2.action === "setNode") {
        this.emit("chainChanged", { chainId: ((_c2 = (_b2 = message2.data) === null || _b2 === void 0 ? void 0 : _b2.node) === null || _c2 === void 0 ? void 0 : _c2.chainId) || "" });
      } else if (message2.action === "connect") {
        const address2 = ((_e2 = (_d2 = this._wallet.tronWeb) === null || _d2 === void 0 ? void 0 : _d2.defaultAddress) === null || _e2 === void 0 ? void 0 : _e2.base58) || "";
        this.setAddress(address2);
        this.setState(AdapterState.Connected);
        this.emit("connect", address2);
      } else if (message2.action === "disconnect") {
        this.setAddress(null);
        this.setState(AdapterState.Disconnect);
        this.emit("disconnect");
      }
    };
    this._onChainChanged = (data) => {
      this.emit("chainChanged", data);
    };
    this._onAccountsChanged = () => {
      var _a3, _b2, _c2;
      const preAddr = this.address || "";
      const curAddr = ((_a3 = this._wallet) === null || _a3 === void 0 ? void 0 : _a3.tronWeb) && ((_c2 = (_b2 = this._wallet) === null || _b2 === void 0 ? void 0 : _b2.tronWeb.defaultAddress) === null || _c2 === void 0 ? void 0 : _c2.base58) || "";
      if (!curAddr) {
        this.setAddress(null);
        this.setState(AdapterState.Disconnect);
      } else {
        const address2 = curAddr;
        this.setAddress(address2);
        this.setState(AdapterState.Connected);
      }
      this.emit("accountsChanged", this.address || "", preAddr);
      if (!preAddr && this.address) {
        this.emit("connect", this.address);
      } else if (preAddr && !this.address) {
        this.emit("disconnect");
      }
    };
    this._checkPromise = null;
    this._updateWallet = () => {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
      let state = this.state;
      let address2 = this.address;
      if (isInMobileBrowser()) {
        if (window.tronLink) {
          this._wallet = window.tronLink;
        } else {
          this._wallet = {
            ready: !!((_a3 = window.tronWeb) === null || _a3 === void 0 ? void 0 : _a3.defaultAddress),
            tronWeb: window.tronWeb,
            request: () => Promise.resolve(true)
          };
        }
        address2 = ((_c2 = (_b2 = this._wallet.tronWeb) === null || _b2 === void 0 ? void 0 : _b2.defaultAddress) === null || _c2 === void 0 ? void 0 : _c2.base58) || null;
        state = address2 ? AdapterState.Connected : AdapterState.Disconnect;
      } else if (window.tron && window.tron.isTronLink) {
        this._supportNewTronProtocol = true;
        this._wallet = window.tron;
        this._listenTronEvent();
        address2 = this._wallet.tronWeb && ((_e2 = (_d2 = this._wallet.tronWeb) === null || _d2 === void 0 ? void 0 : _d2.defaultAddress) === null || _e2 === void 0 ? void 0 : _e2.base58) || null;
        state = address2 ? AdapterState.Connected : AdapterState.Disconnect;
      } else if (window.tronLink) {
        this._wallet = window.tronLink;
        this._listenTronLinkEvent();
        address2 = ((_g2 = (_f2 = this._wallet.tronWeb) === null || _f2 === void 0 ? void 0 : _f2.defaultAddress) === null || _g2 === void 0 ? void 0 : _g2.base58) || null;
        state = this._wallet.ready ? AdapterState.Connected : AdapterState.Disconnect;
      } else if (window.tronWeb) {
        this._wallet = {
          ready: window.tronWeb.ready,
          tronWeb: window.tronWeb,
          request: () => Promise.resolve(true)
        };
        address2 = ((_h2 = this._wallet.tronWeb.defaultAddress) === null || _h2 === void 0 ? void 0 : _h2.base58) || null;
        state = this._wallet.ready ? AdapterState.Connected : AdapterState.Disconnect;
      } else {
        this._wallet = null;
        address2 = null;
        state = AdapterState.NotFound;
      }
      if (isInMobileBrowser() && state === AdapterState.Disconnect) {
        this.checkForWalletReadyForApp();
      }
      this.setAddress(address2);
      this.setState(state);
    };
    this.checkReadyInterval = null;
    const { checkTimeout = 30 * 1e3, dappIcon = "", dappName = "", openUrlWhenWalletNotFound = true, openTronLinkAppOnMobile = true } = config2;
    if (typeof checkTimeout !== "number") {
      throw new Error("[TronLinkAdapter] config.checkTimeout should be a number");
    }
    this.config = {
      checkTimeout,
      openTronLinkAppOnMobile,
      openUrlWhenWalletNotFound,
      dappIcon,
      dappName
    };
    this._connecting = false;
    this._wallet = null;
    this._address = null;
    if (!isInBrowser()) {
      this._readyState = WalletReadyState.NotFound;
      this.setState(AdapterState.NotFound);
      return;
    }
    if (supportTron() || isInMobileBrowser() && (window.tronLink || window.tronWeb)) {
      this._readyState = WalletReadyState.Found;
      this._updateWallet();
    } else {
      this._checkWallet().then(() => {
        if (this.connected) {
          this.emit("connect", this.address || "");
        }
      });
    }
  }
  get address() {
    return this._address;
  }
  get state() {
    return this._state;
  }
  get readyState() {
    return this._readyState;
  }
  get connecting() {
    return this._connecting;
  }
  /**
   * Get network information used by TronLink.
   * @returns {Network} Current network information.
   */
  network() {
    return __awaiter$1(this, void 0, void 0, function* () {
      var _a3;
      try {
        yield this._checkWallet();
        if (this.state !== AdapterState.Connected)
          throw new WalletDisconnectedError2();
        const tronWeb = ((_a3 = this._wallet) === null || _a3 === void 0 ? void 0 : _a3.tronWeb) || window.tronWeb;
        if (!tronWeb)
          throw new WalletDisconnectedError2();
        try {
          return yield getNetworkInfoByTronWeb(tronWeb);
        } catch (e2) {
          throw new WalletGetNetworkError(e2 === null || e2 === void 0 ? void 0 : e2.message, e2);
        }
      } catch (e2) {
        this.emit("error", e2);
        throw e2;
      }
    });
  }
  connect() {
    return __awaiter$1(this, void 0, void 0, function* () {
      var _a3, _b2;
      try {
        this.checkIfOpenTronLink();
        if (this.connected || this.connecting)
          return;
        yield this._checkWallet();
        if (this.state === AdapterState.NotFound) {
          if (this.config.openUrlWhenWalletNotFound !== false && isInBrowser()) {
            window.open(this.url, "_blank");
          }
          throw new WalletNotFoundError();
        }
        if (!this._wallet)
          return;
        this._connecting = true;
        if (this._supportNewTronProtocol) {
          const wallet = this._wallet;
          try {
            const res = yield wallet.request({ method: "eth_requestAccounts" });
            const address2 = res[0];
            this.setAddress(address2);
            this.setState(AdapterState.Connected);
            this._listenTronEvent();
            if (!this._wallet.tronWeb) {
              yield waitTronwebReady(this._wallet);
            }
          } catch (error) {
            let message2 = (error === null || error === void 0 ? void 0 : error.message) || error || "Connect TronLink wallet failed.";
            if (error.code === -32002) {
              message2 = "The same DApp has already initiated a request to connect to TronLink wallet, and the pop-up window has not been closed.";
            }
            if (error.code === 4001) {
              message2 = "The user rejected connection.";
            }
            throw new WalletConnectionError2(message2, error);
          }
        } else if (window.tronLink) {
          const wallet = this._wallet;
          try {
            const res = yield wallet.request({ method: "tron_requestAccounts" });
            if (!res) {
              throw new WalletConnectionError2("TronLink wallet is locked or no wallet account is avaliable.");
            }
            if (res.code === 4e3) {
              throw new WalletConnectionError2("The same DApp has already initiated a request to connect to TronLink wallet, and the pop-up window has not been closed.");
            }
            if (res.code === 4001) {
              throw new WalletConnectionError2("The user rejected connection.");
            }
          } catch (error) {
            throw new WalletConnectionError2(error === null || error === void 0 ? void 0 : error.message, error);
          }
          const address2 = ((_a3 = wallet.tronWeb.defaultAddress) === null || _a3 === void 0 ? void 0 : _a3.base58) || "";
          this.setAddress(address2);
          this.setState(AdapterState.Connected);
          this._listenTronLinkEvent();
        } else if (window.tronWeb) {
          const wallet = this._wallet;
          const address2 = ((_b2 = wallet.tronWeb.defaultAddress) === null || _b2 === void 0 ? void 0 : _b2.base58) || "";
          this.setAddress(address2);
          this.setState(AdapterState.Connected);
        } else {
          throw new WalletConnectionError2("Cannot connect wallet.");
        }
        this.connected && this.emit("connect", this.address || "");
      } catch (error) {
        this.emit("error", error);
        throw error;
      } finally {
        this._connecting = false;
      }
    });
  }
  disconnect() {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this._supportNewTronProtocol) {
        this._stopListenTronEvent();
      } else {
        this._stopListenTronLinkEvent();
      }
      if (this.state !== AdapterState.Connected) {
        return;
      }
      this.setAddress(null);
      this.setState(AdapterState.Disconnect);
      this.emit("disconnect");
    });
  }
  signTransaction(transaction2, privateKey) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const wallet = yield this.checkAndGetWallet();
        try {
          return yield wallet.tronWeb.trx.sign(transaction2, privateKey);
        } catch (error) {
          if (error instanceof Error) {
            throw new WalletSignTransactionError2(error.message, error);
          } else {
            throw new WalletSignTransactionError2(error, new Error(error));
          }
        }
      } catch (error) {
        this.emit("error", error);
        throw error;
      }
    });
  }
  multiSign(transaction2, privateKey, permissionId) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const wallet = yield this.checkAndGetWallet();
        try {
          return yield wallet.tronWeb.trx.multiSign(transaction2, privateKey, permissionId);
        } catch (error) {
          if (error instanceof Error) {
            throw new WalletSignTransactionError2(error.message, error);
          } else {
            throw new WalletSignTransactionError2(error, new Error(error));
          }
        }
      } catch (error) {
        this.emit("error", error);
        throw error;
      }
    });
  }
  signMessage(message2, privateKey) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const wallet = yield this.checkAndGetWallet();
        try {
          return yield wallet.tronWeb.trx.signMessageV2(message2, privateKey);
        } catch (error) {
          if (error instanceof Error) {
            throw new WalletSignMessageError2(error.message, error);
          } else {
            throw new WalletSignMessageError2(error, new Error(error));
          }
        }
      } catch (error) {
        this.emit("error", error);
        throw error;
      }
    });
  }
  /**
   * Switch to target chain. If current chain is the same as target chain, the call will success immediately.
   * Available chainIds:
   * - Mainnet: 0x2b6653dc
   * - Shasta: 0x94a9059e
   * - Nile: 0xcd8690dc
   * @param chainId chainId
   */
  switchChain(chainId) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        yield this._checkWallet();
        if (this.state === AdapterState.NotFound) {
          if (this.config.openUrlWhenWalletNotFound !== false && isInBrowser()) {
            window.open(this.url, "_blank");
          }
          throw new WalletNotFoundError();
        }
        if (!this._supportNewTronProtocol) {
          throw new WalletSwitchChainError("Current version of TronLink doesn't support switch chain operation.");
        }
        const wallet = this._wallet;
        try {
          yield wallet.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId }]
          });
        } catch (e2) {
          throw new WalletSwitchChainError((e2 === null || e2 === void 0 ? void 0 : e2.message) || e2, e2 instanceof Error ? e2 : new Error(e2));
        }
      } catch (error) {
        this.emit("error", error);
        throw error;
      }
    });
  }
  checkAndGetWallet() {
    return __awaiter$1(this, void 0, void 0, function* () {
      this.checkIfOpenTronLink();
      yield this._checkWallet();
      if (this.state !== AdapterState.Connected)
        throw new WalletDisconnectedError2();
      const wallet = this._wallet;
      if (!wallet || !wallet.tronWeb)
        throw new WalletDisconnectedError2();
      return wallet;
    });
  }
  _listenTronLinkEvent() {
    this._stopListenTronLinkEvent();
    window.addEventListener("message", this._tronLinkMessageHandler);
  }
  _stopListenTronLinkEvent() {
    window.removeEventListener("message", this._tronLinkMessageHandler);
  }
  checkIfOpenTronLink() {
    const { dappName = "", dappIcon = "" } = this.config;
    if (this.config.openTronLinkAppOnMobile === false) {
      return;
    }
    if (openTronLink({ dappIcon, dappName })) {
      throw new WalletNotFoundError();
    }
  }
  // following code is for TIP-1193
  _listenTronEvent() {
    this._stopListenTronEvent();
    this._stopListenTronLinkEvent();
    const wallet = this._wallet;
    wallet.on("chainChanged", this._onChainChanged);
    wallet.on("accountsChanged", this._onAccountsChanged);
  }
  _stopListenTronEvent() {
    const wallet = this._wallet;
    wallet.removeListener("chainChanged", this._onChainChanged);
    wallet.removeListener("accountsChanged", this._onAccountsChanged);
  }
  /**
   * check if wallet exists by interval, the promise only resolve when wallet detected or timeout
   * @returns if wallet exists
   */
  _checkWallet() {
    if (this.readyState === WalletReadyState.Found) {
      return Promise.resolve(true);
    }
    if (this._checkPromise) {
      return this._checkPromise;
    }
    const interval = 100;
    const checkTronTimes = Math.floor(2e3 / interval);
    const maxTimes = Math.floor(this.config.checkTimeout / interval);
    let times = 0, timer2;
    this._checkPromise = new Promise((resolve) => {
      const check = () => {
        times++;
        const isSupport = times < checkTronTimes && !isInMobileBrowser() ? supportTron() : supportTronLink();
        if (isSupport || times > maxTimes) {
          timer2 && clearInterval(timer2);
          this._readyState = isSupport ? WalletReadyState.Found : WalletReadyState.NotFound;
          this._updateWallet();
          this.emit("readyStateChanged", this.readyState);
          resolve(isSupport);
        }
      };
      timer2 = setInterval(check, interval);
      check();
    });
    return this._checkPromise;
  }
  checkForWalletReadyForApp() {
    if (this.checkReadyInterval) {
      return;
    }
    let times = 0;
    const maxTimes = Math.floor(this.config.checkTimeout / 200);
    const check = () => {
      var _a3, _b2;
      if (window.tronLink ? (_a3 = window.tronLink.tronWeb) === null || _a3 === void 0 ? void 0 : _a3.defaultAddress : (_b2 = window.tronWeb) === null || _b2 === void 0 ? void 0 : _b2.defaultAddress) {
        this.checkReadyInterval && clearInterval(this.checkReadyInterval);
        this.checkReadyInterval = null;
        this._updateWallet();
        this.emit("connect", this.address || "");
      } else if (times > maxTimes) {
        this.checkReadyInterval && clearInterval(this.checkReadyInterval);
        this.checkReadyInterval = null;
      } else {
        times++;
      }
    };
    this.checkReadyInterval = setInterval(check, 200);
  }
  setAddress(address2) {
    this._address = address2;
  }
  setState(state) {
    const preState = this.state;
    if (state !== preState) {
      this._state = state;
      this.emit("stateChanged", state);
    }
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const initialState = {
  wallet: null,
  address: null,
  connected: false,
  adapter: null
};
const WalletProvider = function({ children, adapters: adaptersPro = null, onError = (error) => console.error(error), onReadyStateChanged, onConnect, onDisconnect, onAccountsChanged, onChainChanged, onAdapterChanged, localStorageKey = "tronAdapterName", autoConnect = true, disableAutoConnectOnLoad = false }) {
  const [name, setName] = useLocalStorage(localStorageKey, null);
  const [{ wallet, connected, address: address2, adapter }, setState] = reactExports.useState(initialState);
  const [connecting, setConnecting] = reactExports.useState(false);
  const [disconnecting, setDisconnecting] = reactExports.useState(false);
  const isConnecting = reactExports.useRef(false);
  const isDisconnecting = reactExports.useRef(false);
  const adapters2 = reactExports.useMemo(() => {
    if (adaptersPro === null) {
      return [new TronLinkAdapter()];
    }
    return adaptersPro;
  }, [adaptersPro]);
  const [wallets2, setWallets] = reactExports.useState(() => adapters2.map((adapter2) => ({
    adapter: adapter2,
    state: adapter2.state
  })));
  reactExports.useEffect(function() {
    setWallets((prevWallets) => adapters2.map((adapter2, index2) => {
      const wallet2 = prevWallets[index2];
      if (wallet2 && wallet2.adapter === adapter2 && wallet2.state === adapter2.state) {
        return wallet2;
      }
      return {
        adapter: adapter2,
        state: adapter2.state
      };
    }));
    function handleStateChange() {
      setWallets((prevWallets) => {
        const index2 = prevWallets.findIndex((wallet2) => wallet2.adapter === this);
        if (index2 === -1) {
          return prevWallets;
        }
        return prevWallets.map((wallet2, idx) => {
          if (idx === index2) {
            return Object.assign(Object.assign({}, wallet2), { state: wallet2.adapter.state });
          }
          return wallet2;
        });
      });
    }
    adapters2.forEach((adapter2) => adapter2.on("stateChanged", handleStateChange, adapter2));
    return () => adapters2.forEach((adapter2) => adapter2.off("stateChanged", handleStateChange, adapter2));
  }, [adapters2]);
  reactExports.useEffect(function() {
    const wallet2 = name && wallets2.find((item) => item.adapter.name === name);
    if (wallet2) {
      setState({
        wallet: wallet2,
        adapter: wallet2.adapter,
        connected: wallet2.adapter.connected,
        address: wallet2.adapter.address
      });
    } else {
      setState(initialState);
    }
  }, [name, wallets2]);
  const preAdapter = reactExports.useRef(null);
  reactExports.useEffect(function() {
    if (adapter !== preAdapter.current) {
      onAdapterChanged === null || onAdapterChanged === void 0 ? void 0 : onAdapterChanged(adapter);
      preAdapter.current = adapter;
    }
  }, [adapter, onAdapterChanged]);
  const handleConnect = reactExports.useCallback(function(addr) {
    if (!adapter) {
      return setName(null);
    }
    setState((state) => Object.assign(Object.assign({}, state), { connected: adapter.connected, address: adapter.address }));
    onConnect === null || onConnect === void 0 ? void 0 : onConnect(addr);
  }, [adapter, setName, onConnect]);
  const handleError = reactExports.useCallback(function(error) {
    onError(error);
    return error;
  }, [onError]);
  const handleAccountChange = reactExports.useCallback(function(address3, preAddr) {
    setState((state) => Object.assign(Object.assign({}, state), { address: address3 }));
    onAccountsChanged === null || onAccountsChanged === void 0 ? void 0 : onAccountsChanged(address3, preAddr);
  }, [onAccountsChanged]);
  const handleDisconnect = reactExports.useCallback(function() {
    onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect();
  }, [onDisconnect]);
  const handleReadyStateChanged = reactExports.useCallback(function(readyState) {
    onReadyStateChanged === null || onReadyStateChanged === void 0 ? void 0 : onReadyStateChanged(readyState);
  }, [onReadyStateChanged]);
  const handleChainChanged = reactExports.useCallback(function(chainData) {
    onChainChanged === null || onChainChanged === void 0 ? void 0 : onChainChanged(chainData);
  }, [onChainChanged]);
  reactExports.useEffect(function() {
    if (adapter) {
      adapter.on("connect", handleConnect);
      adapter.on("error", handleError);
      adapter.on("accountsChanged", handleAccountChange);
      adapter.on("chainChanged", handleChainChanged);
      adapter.on("readyStateChanged", handleReadyStateChanged);
      adapter.on("disconnect", handleDisconnect);
      return () => {
        adapter.off("connect", handleConnect);
        adapter.off("error", handleError);
        adapter.off("accountsChanged", handleAccountChange);
        adapter.off("chainChanged", handleChainChanged);
        adapter.off("readyStateChanged", handleReadyStateChanged);
        adapter.off("disconnect", handleDisconnect);
      };
    }
  }, [
    adapter,
    handleConnect,
    handleError,
    handleAccountChange,
    handleChainChanged,
    handleReadyStateChanged,
    handleDisconnect
  ]);
  reactExports.useEffect(() => {
    return () => {
      adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();
    };
  }, [adapter]);
  const hasManuallySetName = reactExports.useRef(false);
  reactExports.useEffect(function() {
    const canAutoConnect = autoConnect && (!disableAutoConnectOnLoad || hasManuallySetName.current);
    if (isConnecting.current || !canAutoConnect || !adapter || adapter.state !== AdapterState.Disconnect) {
      return;
    }
    (function connect3() {
      return __awaiter(this, void 0, void 0, function* () {
        isConnecting.current = true;
        setConnecting(true);
        try {
          yield adapter.connect();
        } catch (error) {
        } finally {
          setConnecting(false);
          isConnecting.current = false;
        }
      });
    })();
  }, [isConnecting, autoConnect, adapter, setName, disableAutoConnectOnLoad]);
  const select = reactExports.useCallback((name2) => {
    hasManuallySetName.current = true;
    setName(name2);
  }, [setName]);
  const connect2 = reactExports.useCallback(function() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isConnecting.current || isDisconnecting.current || connected) {
        return;
      }
      if (!adapter)
        throw handleError(new WalletNotSelectedError2());
      isConnecting.current = true;
      setConnecting(true);
      try {
        yield adapter.connect();
      } catch (error) {
        setName(null);
        throw error;
      } finally {
        setConnecting(false);
        isConnecting.current = false;
      }
    });
  }, [isConnecting, isDisconnecting, adapter, connected, handleError, setName]);
  const disconnect2 = reactExports.useCallback(function() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isDisconnecting.current)
        return;
      if (!adapter)
        return setName(null);
      isDisconnecting.current = true;
      setDisconnecting(true);
      try {
        yield adapter.disconnect();
        setName(null);
      } catch (error) {
        setName(null);
        throw error;
      } finally {
        setDisconnecting(false);
        isDisconnecting.current = false;
      }
    });
  }, [adapter, isDisconnecting, setName]);
  const signTransaction2 = reactExports.useCallback(function(transaction2, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!adapter)
        throw handleError(new WalletNotSelectedError2());
      return yield adapter.signTransaction(transaction2, privateKey);
    });
  }, [adapter, handleError]);
  const signMessage2 = reactExports.useCallback(function(message2, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!adapter)
        throw handleError(new WalletNotSelectedError2());
      return yield adapter.signMessage(message2, privateKey);
    });
  }, [adapter, handleError]);
  return React.createElement(WalletContext.Provider, { value: {
    disableAutoConnectOnLoad,
    autoConnect,
    wallets: wallets2,
    wallet,
    address: address2,
    connecting,
    connected,
    disconnecting,
    select,
    connect: connect2,
    disconnect: disconnect2,
    signTransaction: signTransaction2,
    signMessage: signMessage2
  } }, children);
};
function cx(...classNames) {
  if (!classNames.length)
    return;
  return classNames.filter(Boolean).join(" ");
}
function cssVar(name, type2 = "colors") {
  return `var(--wk-${type2}-${name.replace(/\./g, "-")})`;
}
function rgba(firstValue, secondValue, thirdValue, fourthValue = 1) {
  var _a3;
  if (typeof firstValue === "string") {
    if (firstValue.startsWith("#")) {
      const hexStr = firstValue.slice(1);
      const formatStr = hexStr.length === 3 ? hexStr.replace(/[A-F\d]/gi, "$&$&") : hexStr;
      const hexArr = (_a3 = formatStr.match(/.{2}/g)) == null ? void 0 : _a3.map((v2) => parseInt(v2, 16));
      if ((hexArr == null ? void 0 : hexArr.length) === 3) {
        return rgba(hexArr[0], hexArr[1], hexArr[2], secondValue);
      }
    }
  }
  return `rgba(${firstValue}, ${secondValue}, ${thirdValue}, ${fourthValue})`;
}
const radii = {
  common: "8px",
  modal: "12px",
  navButton: "4px",
  button: "var(--wk-radii-common)",
  connectButton: "var(--wk-radii-common)",
  disconnectButton: "var(--wk-radii-common)",
  noWalletButton: "var(--wk-radii-common)",
  walletOption: "var(--wk-radii-common)",
  walletOptionIcon: "var(--wk-radii-common)",
  chainOption: "var(--wk-radii-common)",
  toast: "var(--wk-radii-common)",
  qrCode: "var(--wk-radii-common)"
};
const zIndices = {
  modal: 1300,
  toast: 1500
};
const base = {
  light: {
    colors: {
      text: "#1E2026",
      textSecondary: "#76808F",
      primary: "#CC9D09",
      primaryActive: "#F0B90B",
      error: "#D9304E",
      errorActive: "#B82942",
      border: "#E6E8EA",
      disabled: "#AEB4BC",
      modalBackground: "#FFFFFF",
      modalOverlay: "rgba(0, 0, 0, 0.5)",
      buttonText: "var(--wk-colors-text)",
      buttonTextHover: "var(--wk-colors-text)",
      buttonBackground: "#f5f5f5",
      buttonBackgroundHover: rgba("#F0B90B", 0.1),
      connectButtonText: "var(--wk-colors-text)",
      connectButtonTextHover: "var(--wk-colors-text)",
      connectButtonBackground: "#f5f5f5",
      connectButtonBackgroundHover: "#e6e8ea",
      navButtonText: "var(--wk-colors-textSecondary)",
      navButtonBackgroundHover: "var(--wk-colors-border)",
      optionText: "var(--wk-colors-text)",
      optionTextHover: "var(--wk-colors-text)",
      optionBackground: "#f5f5f5",
      optionBackgroundHover: rgba("#F0B90B", 0.1),
      walletOptionText: "var(--wk-colors-optionText)",
      walletOptionTextHover: "var(--wk-colors-optionTextHover)",
      walletOptionBackground: "var(--wk-colors-optionBackground)",
      walletOptionBackgroundHover: "var(--wk-colors-optionBackgroundHover)",
      chainOptionText: "var(--wk-colors-optionText)",
      chainOptionTextHover: "var(--wk-colors-optionTextHover)",
      chainOptionBackground: "var(--wk-colors-optionBackground)",
      chainOptionBackgroundHover: "var(--wk-colors-optionBackgroundHover)",
      toastBackground: "var(--wk-colors-modalBackground)",
      qrCodeDot: "var(--wk-colors-text)",
      qrCodeBorder: "var(--wk-colors-border)",
      noWalletButtonText: "var(--wk-colors-text)",
      noWalletButtonTextHover: "var(--wk-colors-text)",
      noWalletButtonBackground: "transparent",
      noWalletButtonBackgroundHover: "var(--wk-colors-border)",
      noWalletButtonBorder: "var(--wk-colors-border)",
      noWalletButtonBorderHover: "var(--wk-colors-border)",
      disconnectButtonBackgroundText: "var(--wk-colors-text)",
      disconnectButtonBackgroundTextHover: "var(--wk-colors-text)",
      disconnectButtonBackground: "transparent",
      disconnectButtonBackgroundHover: "var(--wk-colors-border)",
      disconnectButtonBorder: "var(--wk-colors-border)",
      disconnectButtonBorderHover: "var(--wk-colors-border)"
    },
    shadows: {
      normal: "0px 4px 20px 0px rgba(0, 0, 0, 0.04)",
      toast: "0px 4px 24px rgba(0, 0, 0, 0.08)"
    },
    radii,
    zIndices
  },
  dark: {
    colors: {
      text: "#FFF",
      textSecondary: "#76808F",
      primary: "#CC9D09",
      primaryActive: "#F0B90B",
      error: "#D9304E",
      errorActive: "#B82942",
      border: "#2e323a",
      disabled: "#5E6673",
      modalBackground: "#1E2026",
      modalOverlay: rgba("#000", 0.5),
      buttonText: "var(--wk-colors-text)",
      buttonTextHover: "var(--wk-colors-text)",
      buttonBackground: "#14151a",
      buttonBackgroundHover: rgba("#F0B90B", 0.1),
      connectButtonText: "var(--wk-colors-text)",
      connectButtonTextHover: "var(--wk-colors-text)",
      connectButtonBackground: "#2b2f36",
      connectButtonBackgroundHover: "#2e323a",
      navButtonText: "var(--wk-colors-textSecondary)",
      navButtonBackgroundHover: "var(--wk-colors-border)",
      optionText: "var(--wk-colors-text)",
      optionTextHover: "var(--wk-colors-text)",
      optionBackground: "#14151a",
      optionBackgroundHover: rgba("#F0B90B", 0.1),
      walletOptionText: "var(--wk-colors-optionText)",
      walletOptionTextHover: "var(--wk-colors-optionTextHover)",
      walletOptionBackground: "var(--wk-colors-optionBackground)",
      walletOptionBackgroundHover: "var(--wk-colors-optionBackgroundHover)",
      chainOptionText: "var(--wk-colors-optionText)",
      chainOptionTextHover: "var(--wk-colors-optionTextHover)",
      chainOptionBackground: "var(--wk-colors-optionBackground)",
      chainOptionBackgroundHover: "var(--wk-colors-optionBackgroundHover)",
      toastBackground: "var(--wk-colors-modalBackground)",
      qrCodeDot: "var(--wk-colors-text)",
      qrCodeBorder: "var(--wk-colors-border)",
      noWalletButtonText: "var(--wk-colors-text)",
      noWalletButtonTextHover: "var(--wk-colors-text)",
      noWalletButtonBackground: "transparent",
      noWalletButtonBackgroundHover: "var(--wk-colors-border)",
      noWalletButtonBorder: "var(--wk-colors-border)",
      noWalletButtonBorderHover: "var(--wk-colors-border)",
      disconnectButtonBackgroundText: "var(--wk-colors-text)",
      disconnectButtonBackgroundTextHover: "var(--wk-colors-text)",
      disconnectButtonBackground: "transparent",
      disconnectButtonBackgroundHover: "var(--wk-colors-border)",
      disconnectButtonBorder: "var(--wk-colors-border)",
      disconnectButtonBorderHover: "var(--wk-colors-border)"
    },
    shadows: {
      normal: "0px 4px 20px 0px rgba(0, 0, 0, 0.04)",
      toast: "0px 4px 24px rgba(0, 0, 0, 0.08)"
    },
    radii,
    zIndices
  }
};
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item) && item !== null;
}
function deepMerge(target, source) {
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return target;
}
const ThemeContext = React.createContext({});
function useTheme() {
  return reactExports.useContext(ThemeContext);
}
const themeMap = {
  base
};
function ThemeProvider(props) {
  const { variant = "base", mode: mode2 = "auto", theme, children } = props;
  const styleContent = reactExports.useMemo(() => {
    const lightTheme = deepMerge(themeMap[variant].light ?? theme, (theme == null ? void 0 : theme.light) ?? theme);
    const darkTheme = deepMerge(themeMap[variant].dark ?? theme, (theme == null ? void 0 : theme.dark) ?? theme);
    const lightCssVars = createCssVars(lightTheme, "--wk-light");
    const darkCssVars = createCssVars(darkTheme, "--wk-dark");
    const lightPointer = createPointer(lightCssVars);
    const darkPointer = createPointer(darkCssVars);
    const lightCssVarsContent = createStyleContent(lightCssVars);
    const darkCssVarsContent = createStyleContent(darkCssVars);
    const lightPointerContent = createStyleContent(lightPointer);
    const darkPointerContent = createStyleContent(darkPointer);
    if (mode2 === "light") {
      return `body {
        ${lightPointerContent};
        ${lightCssVarsContent};
      }`;
    }
    if (mode2 === "dark") {
      return `body {
        ${darkPointerContent};
        ${darkCssVarsContent};
      }`;
    }
    if (mode2 === "auto") {
      return `body {
        ${lightCssVarsContent};
        ${darkCssVarsContent};
        @media (prefers-color-scheme: light) {
          ${lightPointerContent};
        }
        @media (prefers-color-scheme: dark) {
          ${darkPointerContent};
        }
      }`;
    }
    return "";
  }, [theme, mode2, variant]);
  const [colorMode, setColorMode] = reactExports.useState("light");
  reactExports.useEffect(() => {
    if (mode2 === "auto") {
      const matchMedia = window.matchMedia("(prefers-color-scheme: dark)");
      const onChange = () => {
        const cm = matchMedia.matches ? "dark" : "light";
        setColorMode(cm);
      };
      onChange();
      matchMedia.addEventListener("change", onChange);
      return () => {
        matchMedia.removeEventListener("change", onChange);
      };
    } else {
      setColorMode(mode2);
    }
  }, [mode2]);
  const value = reactExports.useMemo(() => {
    return {
      colorMode
    };
  }, [colorMode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeContext.Provider, { value, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: styleContent }),
    children
  ] });
}
function createCssVars(theme, prefix = "") {
  const cssVars = {};
  const walk2 = (input, prefix2 = "") => {
    Object.entries(input).forEach(([key, value]) => {
      const varName = `${prefix2}-${key}`;
      if (typeof value !== "object") {
        cssVars[varName] = value;
      } else {
        walk2(value, varName);
      }
    });
  };
  walk2(theme, prefix);
  return cssVars;
}
function createStyleContent(cssVars) {
  return Object.entries(cssVars).map(([key, value]) => {
    return `${key}: ${value}`;
  }).join(";");
}
function createPointer(cssVars) {
  const pointers = {};
  Object.keys(cssVars).forEach((item) => {
    const key = item.replace(/\-light|\-dark/g, "");
    const value = `var(${item})`;
    pointers[key] = value;
  });
  return pointers;
}
const WalletKitContext = React.createContext({});
function useWalletKit() {
  return reactExports.useContext(WalletKitContext);
}
function EvmWalletProvider(props) {
  const { children } = props;
  const { evmConfig } = useWalletKit();
  if (!evmConfig) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WagmiProvider, { config: evmConfig.wagmiConfig, reconnectOnMount: evmConfig.autoConnect, children });
}
class CustomEventEmitter {
  constructor() {
    __publicField(this, "listenersMap");
    __publicField(this, "EVM_CONNECT_ERROR", "EVM_CONNECT_ERROR");
    __publicField(this, "EVM_CONNECT_SETTLE", "EVM_CONNECT_SETTLE");
    __publicField(this, "SOLANA_WALLET_ERROR", "SOLANA_WALLET_ERROR");
    __publicField(this, "TRON_WALLET_ERROR", "TRON_WALLET_ERROR");
    this.listenersMap = {};
  }
  on(event, cb2) {
    if (!this.listenersMap[event])
      this.listenersMap[event] = [];
    this.listenersMap[event].push(cb2);
  }
  emit(event, ...params) {
    const listener = this.listenersMap[event];
    if (listener) {
      listener.forEach((cb2) => cb2(...params));
    }
  }
  off(event, cb2) {
    const listeners2 = this.listenersMap[event];
    if (listeners2) {
      const index2 = listeners2.findIndex((item) => item === cb2);
      if (index2 > -1) {
        listeners2.splice(index2);
      }
    }
  }
}
const EventEmitter = new CustomEventEmitter();
function SolanaWalletProvider(props) {
  const { children } = props;
  const { solanaConfig } = useWalletKit();
  const onError = reactExports.useCallback((error) => {
    EventEmitter.emit(EventEmitter.SOLANA_WALLET_ERROR, error);
  }, []);
  if (!solanaConfig) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectionProvider, { endpoint: solanaConfig.rpcUrl, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    WalletProvider$1,
    {
      wallets: solanaConfig.adapters,
      onError,
      autoConnect: solanaConfig.autoConnect,
      children
    }
  ) });
}
const ToastManager = {
  listeners: [],
  toastList: [],
  autoIncreaseId: 0,
  add(options) {
    const toastId = this.autoIncreaseId++;
    this.toastList.unshift({
      toastId,
      ...options
    });
    this.notify();
    return toastId;
  },
  remove(toastId) {
    const index2 = this.toastList.findIndex((item) => item.toastId === toastId);
    if (index2 > -1) {
      this.toastList.splice(index2, 1);
      this.notify();
    }
  },
  notify() {
    this.listeners.forEach((fn) => {
      fn([...this.toastList]);
    });
  },
  subscribe(fn) {
    this.listeners.push(fn);
  },
  unsubscribe(fn) {
    const index2 = this.listeners.findIndex((item) => item === fn);
    if (index2 > -1) {
      this.listeners.splice(index2, 1);
    }
  }
};
const toast = (props) => {
  const { variant = "info", duration = 3e3, ...restProps } = props;
  return ToastManager.add({
    variant,
    duration,
    ...restProps
  });
};
toast.info = (props) => {
  return toast({ variant: "info", ...props });
};
toast.error = (props) => {
  return toast({ variant: "error", ...props });
};
function getDefaultConfig(config2) {
  const { options, evmConfig, solanaConfig, tronConfig } = config2;
  return {
    options: {
      title: "Connect Wallet",
      disclaimer: void 0,
      gridLayoutThreshold: 6,
      useGridLayoutOnMobile: true,
      hideNoWalletCTA: false,
      hideOfficialWalletConnectCTA: true,
      walletDownloadUrl: `https://trustwallet.com/`,
      closeModalAfterSwitchingNetwork: true,
      closeModalAfterConnected: true,
      closeModalOnEsc: true,
      closeModalOnOverlayClick: true,
      openModalOnWrongNetwork: false,
      onError(_err, description) {
        if (description) {
          toast.error({
            description
          });
        }
      },
      ...options
    },
    evmConfig,
    solanaConfig,
    tronConfig
  };
}
const RouteContext = React.createContext({});
function useRouter() {
  return reactExports.useContext(RouteContext);
}
var CONNECT_STATUS = /* @__PURE__ */ ((CONNECT_STATUS2) => {
  CONNECT_STATUS2["CONNECTED"] = "connected";
  CONNECT_STATUS2["CONNECTING"] = "connecting";
  CONNECT_STATUS2["FAILED"] = "failed";
  CONNECT_STATUS2["REJECTED"] = "rejected";
  CONNECT_STATUS2["NOTCONNECTED"] = "notconnected";
  CONNECT_STATUS2["UNAVAILABLE"] = "unavailable";
  return CONNECT_STATUS2;
})(CONNECT_STATUS || {});
var clsBox = "wk_t59jcv0";
const Box = React.forwardRef((props, ref) => {
  const { as = "div", className, ...restProps } = props;
  return React.createElement(as, {
    ref,
    className: cx(clsBox, className),
    ...restProps
  });
});
Box.displayName = "Box";
var clsButton$1 = "wk_14j9dar0";
const Button = React.forwardRef((props, ref) => {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ref, as: "button", className: cx("wk-button", clsButton$1, className), ...restProps });
});
Button.displayName = "Button";
var clsModalBody = "wk_vno40y0";
function ModalBody(props) {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-modal-body", clsModalBody, className), ...restProps });
}
var clsModalFooter = "wk_1rmpmq20";
function ModalFooter(props) {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-modal-footer", clsModalFooter, className), ...restProps });
}
var clsModalHeader = "wk_qhb85j0";
function ModalHeader(props) {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-modal-header", clsModalHeader, className), ...restProps });
}
function CircleLoadingIcon(props) {
  const { thickness, endColor, ...restProps } = props;
  const startStopColor = cssVar("modalBackground");
  const endStopColor = endColor ?? cssVar("primaryActive");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "52", height: "102", viewBox: "0 0 52 102", fill: "none", ...restProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M1 101C28.6142 101 51 78.6142 51 51C51 23.3858 28.6142 1 1 1",
        stroke: "url(#paint0_linear_1252_60553)",
        strokeWidth: thickness,
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "linearGradient",
      {
        id: "paint0_linear_1252_60553",
        x1: "1",
        y1: "1",
        x2: "0.999999",
        y2: "101",
        gradientUnits: "userSpaceOnUse",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: startStopColor }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: endStopColor })
        ]
      }
    ) })
  ] });
}
var clsContainer$6 = "wk_107z37f0";
var clsErrorCircle = "wk_107z37f2";
var clsLoading$1 = "wk_107z37f4";
var clsLogo = "wk_107z37f1";
function ConnectSpinner(props) {
  const {
    className,
    isLoading = false,
    isError: isError2 = false,
    thickness = 2,
    loadingColor,
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: cx("wk-connect-spinner", clsContainer$6, className), ...restProps, children: [
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircleLoadingIcon, { className: clsLoading$1, thickness, endColor: loadingColor }),
    isError2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: clsErrorCircle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: clsLogo, children })
  ] });
}
var clsContent$2 = "wk_1nr7e5q0";
function Content(props) {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-content", clsContent$2, className), ...restProps });
}
var clsDescription$1 = "wk_1cxzn9q0";
function Description(props) {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-description", clsDescription$1, className), ...restProps });
}
const AlertIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 16 15", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M1.63937 12.5331L7.6704 2.47023C8.04617 1.84325 8.95383 1.84326 9.3296 2.47023L15.3606 12.5331C15.7475 13.1787 15.283 14 14.531 14H2.46897C1.71695 14 1.25246 13.1787 1.63937 12.5331Z",
        stroke: "currentColor",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M9.5 11.7231C9.5 12.2754 9.05228 12.7231 8.5 12.7231C7.94772 12.7231 7.5 12.2754 7.5 11.7231C7.5 11.1709 7.94772 10.7231 8.5 10.7231C9.05228 10.7231 9.5 11.1709 9.5 11.7231Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M7.6684 5.65882C7.63842 5.15178 8.01942 4.72314 8.50008 4.72314C8.98075 4.72314 9.36174 5.15178 9.33176 5.65882L9.12831 9.09936C9.10757 9.44999 8.83247 9.72314 8.50008 9.72314C8.16769 9.72314 7.89259 9.44999 7.87186 9.09936L7.6684 5.65882Z",
        fill: "currentColor"
      }
    )
  ] });
};
var clsErrorTitle = "wk_ebg9wh0";
function ErrorTitle(props) {
  const { className, children, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: cx("wk-error-title", clsErrorTitle, className), ...restProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, {}),
    children
  ] });
}
var clsInfoTitle = "wk_pb4clz0";
function InfoTitle(props) {
  const { className, children, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-info-title", clsInfoTitle, className), ...restProps, children });
}
function useWalletDownloadUrl(urls) {
  const { options } = useWalletKit();
  const url = reactExports.useMemo(() => {
    const url2 = urls.default ?? options.walletDownloadUrl;
    return url2;
  }, [options.walletDownloadUrl, urls.default]);
  return url;
}
function useWalletLogos(walletLogos) {
  const { colorMode } = useTheme();
  const logos = reactExports.useMemo(() => {
    const { default: defaultLogos, transparent: transparentLogos } = walletLogos ?? {};
    const defaultLogo = (defaultLogos == null ? void 0 : defaultLogos[colorMode]) ?? defaultLogos;
    const transparentLogo = (transparentLogos == null ? void 0 : transparentLogos[colorMode]) ?? transparentLogos ?? defaultLogo;
    return {
      default: defaultLogo,
      transparent: transparentLogo
    };
  }, [colorMode, walletLogos]);
  return logos;
}
var clsButton = "wk_qfvtl92";
var clsContent$1 = "wk_qfvtl90";
var clsFooter$1 = "wk_qfvtl93";
var clsGap = "wk_qfvtl91";
const ConnectModalContext = React.createContext({});
function useConnectModal() {
  return reactExports.useContext(ConnectModalContext);
}
function useAutoCloseConnectModal(isConnected, address2) {
  const { options, selectedWallet } = useWalletKit();
  const router = useRouter();
  const { onClose } = useConnectModal();
  reactExports.useEffect(() => {
    var _a3;
    if (router.route !== ViewRoutes.HOME && isConnected) {
      (_a3 = options.onConnected) == null ? void 0 : _a3.call(options, {
        wallet: selectedWallet,
        address: address2
      });
      if (options.closeModalAfterConnected) {
        onClose();
      }
    }
  }, [isConnected, router.route, options.closeModalAfterConnected]);
}
function TemplateConnectingView(props) {
  const { status, runConnect, onTryAgain, wallet, isConnected, address: address2 } = props;
  const { log: log2 } = useWalletKit();
  const logos = useWalletLogos(wallet.logos);
  const downloadUrl = useWalletDownloadUrl(wallet.downloadUrls);
  reactExports.useEffect(() => {
    log2("[ConnectingView]", `name: ${wallet == null ? void 0 : wallet.name}, status: ${status}`);
    if (status === CONNECT_STATUS.UNAVAILABLE)
      return;
    const connectTimeout = setTimeout(runConnect, 600);
    return () => {
      clearTimeout(connectTimeout);
    };
  }, []);
  const isError2 = [
    CONNECT_STATUS.FAILED,
    CONNECT_STATUS.NOTCONNECTED,
    CONNECT_STATUS.REJECTED
  ].includes(status);
  const isLoading = status === CONNECT_STATUS.CONNECTING;
  useAutoCloseConnectModal(isConnected, address2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalHeader, { children: wallet == null ? void 0 : wallet.name }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalBody, { className: clsContent$1, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectSpinner, { isLoading, isError: isError2, loadingColor: wallet.spinnerColor, children: logos.transparent }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: clsGap }),
      status === CONNECT_STATUS.FAILED && /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorTitle, { children: "Connection Failed" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Description, { children: "Sorry, something went wrong. Please try connecting again." })
      ] }),
      status === CONNECT_STATUS.REJECTED && /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTitle, { children: "Request Cancelled" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Description, { children: "You cancelled the request. Click above to try again." })
      ] }),
      status === CONNECT_STATUS.CONNECTING && /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTitle, { children: "Requesting Connection" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Description, { children: [
          "Open the ",
          wallet.name,
          " ",
          isMobile() ? "app" : "browser extension",
          " to connect your wallet."
        ] })
      ] }),
      status === CONNECT_STATUS.CONNECTED && /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoTitle, { children: "Already Connected" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Description, { children: "It is now okay to close this popup" })
      ] }),
      status === CONNECT_STATUS.NOTCONNECTED && /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ErrorTitle, { children: [
          "Login to ",
          wallet.name
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Description, { children: [
          "To continue, please login to your ",
          wallet.name,
          " extension."
        ] })
      ] }),
      status === CONNECT_STATUS.UNAVAILABLE && /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoTitle, { children: [
          "Install ",
          wallet.name
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Description, { children: [
          "To connect your ",
          wallet.name,
          ", install the browser extension."
        ] })
      ] })
    ] }),
    (status === CONNECT_STATUS.FAILED || status === CONNECT_STATUS.REJECTED) && /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFooter, { className: clsFooter$1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: cx("wk-retry-button", clsButton), onClick: onTryAgain, children: "Try Again" }) }),
    status === CONNECT_STATUS.UNAVAILABLE && /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFooter, { className: clsFooter$1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        className: cx("wk-download-button", clsButton),
        as: "a",
        href: downloadUrl,
        target: "_blank",
        rel: "noopener",
        children: "Install the Extension"
      }
    ) })
  ] });
}
function useIsConnected() {
  const { address: address2 } = useAccount();
  return !!address2;
}
function useWalletConnector(id2) {
  const connectors = useConnectors();
  return connectors.find((item) => item.id === id2);
}
function evmCommonErrorHandler(props) {
  var _a3;
  const { log: log2, handler, error } = props;
  let text = "";
  if (error) {
    if (error.code) {
      switch (error.code) {
        case 4902:
          if (isIOS() && trustWallet().isInstalled()) {
            text = "Not supported chainId";
          }
          break;
      }
    }
    let description = text || ((_a3 = error.cause) == null ? void 0 : _a3.message) || error.message;
    if (description == null ? void 0 : description.includes("Connection request reset")) {
      description = void 0;
    }
    if (isMobile() && binanceWallet().isInstalled()) {
      if ((description == null ? void 0 : description.includes("Request failed: The JSON sent is not a valid Request object.")) || (description == null ? void 0 : description.includes("Adaptor not found: eip155"))) {
        description = "Please update to the latest version of the Binance app and try again later.";
      }
    }
    log2("[WalletError]", error);
    handler == null ? void 0 : handler(error, description);
  }
}
let timer;
function useEvmConnect(props) {
  const { log: log2, options, evmConfig } = useWalletKit();
  const connectProps = {
    chainId: evmConfig == null ? void 0 : evmConfig.initialChainId
  };
  const { connect: connect2, connectAsync, connectors, ...restProps } = useConnect({
    ...props,
    mutation: {
      ...props == null ? void 0 : props.mutation,
      onSettled(data, error, ...params) {
        clearTimeout(timer);
        timer = setTimeout(() => {
          var _a3, _b2;
          EventEmitter.emit(EventEmitter.EVM_CONNECT_SETTLE, data, error, ...params);
          (_b2 = (_a3 = props == null ? void 0 : props.mutation) == null ? void 0 : _a3.onSettled) == null ? void 0 : _b2.call(_a3, data, error, ...params);
          if (error) {
            evmCommonErrorHandler({
              log: log2,
              handler: options.onError,
              error
            });
          }
        }, 100);
      }
    }
  });
  return {
    connect: ({ ...opts }) => {
      return connect2({
        ...connectProps,
        ...opts
      });
    },
    connectAsync: async ({ ...opts }) => {
      return await connectAsync({
        ...connectProps,
        ...opts
      });
    },
    connectors,
    ...restProps
  };
}
function useConnectingStatus(props = {}) {
  const { initialStatus } = props;
  const { selectedWallet, evmConfig, options, action } = useWalletKit();
  const defaultStatus = selectedWallet.isInstalled() ? CONNECT_STATUS.CONNECTING : CONNECT_STATUS.UNAVAILABLE;
  const [status, setStatus] = reactExports.useState(initialStatus ?? defaultStatus);
  const { connect: connect2 } = useEvmConnect();
  reactExports.useEffect(() => {
    const onSettled = (data, error) => {
      var _a3;
      if (error) {
        if (error.code) {
          switch (error.code) {
            case -32002:
              setStatus(CONNECT_STATUS.NOTCONNECTED);
              break;
            case 4001:
              setStatus(CONNECT_STATUS.REJECTED);
              break;
            default:
              setStatus(CONNECT_STATUS.FAILED);
              break;
          }
        } else {
          if (error.message) {
            switch (error.message) {
              case "User rejected request":
                setStatus(CONNECT_STATUS.REJECTED);
                break;
              default:
                setStatus(CONNECT_STATUS.FAILED);
                break;
            }
          }
        }
      } else if (data) {
        if ((evmConfig == null ? void 0 : evmConfig.initialChainId) && data.chainId === evmConfig.initialChainId && action === "add-network") {
          (_a3 = options.onChainAlreadyAdded) == null ? void 0 : _a3.call(options, {
            wallet: selectedWallet,
            chainId: data.chainId
          });
        }
      }
    };
    EventEmitter.on(EventEmitter.EVM_CONNECT_SETTLE, onSettled);
    return () => {
      EventEmitter.off(EventEmitter.EVM_CONNECT_SETTLE, onSettled);
    };
  }, [action, evmConfig == null ? void 0 : evmConfig.initialChainId, options, selectedWallet]);
  return {
    status,
    connect: connect2,
    setStatus
  };
}
function EvmConnectingView() {
  const { selectedWallet } = useWalletKit();
  const isConnected = useIsConnected();
  const selectedConnector = useWalletConnector(selectedWallet.id);
  const { connect: connect2, status, setStatus } = useConnectingStatus();
  const { address: address2 } = useAccount();
  const runConnect = reactExports.useCallback(() => {
    if (!selectedWallet.isInstalled())
      return;
    if (selectedConnector) {
      setStatus(CONNECT_STATUS.CONNECTING);
      connect2({ connector: selectedConnector });
    } else {
      setStatus(CONNECT_STATUS.UNAVAILABLE);
    }
  }, [connect2, selectedConnector, selectedWallet, setStatus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TemplateConnectingView,
    {
      status,
      runConnect,
      onTryAgain: runConnect,
      wallet: selectedWallet,
      isConnected,
      address: address2
    }
  );
}
var clsLink = "wk_1a9rgw50";
const Link = (props) => {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: "a",
      className: cx("wk-link", clsLink, className),
      target: "_blank",
      rel: "noopener",
      ...restProps
    }
  );
};
Link.displayName = "Link";
const ForwardIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "21", height: "20", viewBox: "0 0 21 20", fill: "currentColor", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.49408 3.57709C9.81951 3.25165 10.3472 3.25165 10.6726 3.57709L16.5059 9.41042C16.8314 9.73586 16.8314 10.2635 16.5059 10.5889L10.6726 16.4223C10.3472 16.7477 9.81951 16.7477 9.49408 16.4223C9.16864 16.0968 9.16864 15.5692 9.49408 15.2438L13.9048 10.833H5.08333C4.6231 10.833 4.25 10.4599 4.25 9.99967C4.25 9.53944 4.6231 9.16634 5.08333 9.16634H13.9048L9.49408 4.7556C9.16864 4.43016 9.16864 3.90252 9.49408 3.57709Z"
    }
  ) });
};
var clsFadeIn = "wk_y1x8do2";
var clsFadeOut = "wk_y1x8do3";
var clsToastSlideIn = "wk_1jpwxhg2";
var clsToastSlideOut = "wk_1jpwxhg3";
var clsModalSlideIn = "wk_3li8yi2";
var clsModalSlideOut = "wk_3li8yi3";
const animationMap = {
  fade: [clsFadeOut, clsFadeIn],
  "toast-slide": [clsToastSlideOut, clsToastSlideIn],
  "modal-slide": [clsModalSlideOut, clsModalSlideIn]
};
const Transition = (props) => {
  const { in: show, children, variant = "fade", onExit } = props;
  const { className, onAnimationEnd, ...restProps } = children.props;
  const [isMounted, setIsMounted] = reactExports.useState(show);
  reactExports.useEffect(() => {
    if (show) {
      setIsMounted(true);
    }
  }, [show]);
  const onPlayEnd = (e2) => {
    onAnimationEnd == null ? void 0 : onAnimationEnd(e2);
    if (!show) {
      onExit == null ? void 0 : onExit();
      setIsMounted(false);
    }
  };
  if (!isMounted) {
    return null;
  }
  return React.cloneElement(children, {
    className: cx(animationMap[variant][Number(show)], className),
    onAnimationEnd: onPlayEnd,
    ...restProps
  });
};
function generateMatrix(value, errorCorrectionLevel2) {
  const arr = Array.prototype.slice.call(
    browser.create(value, { errorCorrectionLevel: errorCorrectionLevel2 }).modules.data,
    0
  );
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce(
    (rows, key, index2) => (index2 % sqrt === 0 ? rows.push([key]) : rows[rows.length - 1].push(key)) && rows,
    []
  );
}
function QRCode(props) {
  const { className, ecl = "M", clearSize = 40, size: size2 = 212, uri } = props;
  const dots = reactExports.useMemo(() => {
    const dots2 = [];
    const matrix = generateMatrix(uri, ecl);
    const cellSize = size2 / matrix.length;
    const qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y2 }) => {
      const x1 = (matrix.length - 7) * cellSize * x2;
      const y1 = (matrix.length - 7) * cellSize * y2;
      for (let i = 0; i < 3; i++) {
        const width = cellSize * (7 - i * 2);
        const r2 = [8, 4, 0][i];
        dots2.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              fill: i % 2 === 0 ? "var(--wk-colors-qrCodeDot)" : "var(--wk-colors-modalBackground)",
              height: width,
              width,
              rx: r2,
              ry: r2,
              x: x1 + cellSize * i,
              y: y1 + cellSize * i
            },
            `${i}-${x2}-${y2}`
          )
        );
      }
    });
    const clearArenaSize = Math.ceil(clearSize / cellSize) + 4;
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    matrix.forEach((row, i) => {
      row.forEach((_, j) => {
        if (matrix[i][j]) {
          if (!(i < 7 && j < 7 || i > matrix.length - 8 && j < 7 || i < 7 && j > matrix.length - 8)) {
            if (!(i > matrixMiddleStart && i < matrixMiddleEnd && j > matrixMiddleStart && j < matrixMiddleEnd)) {
              dots2.push(
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "circle",
                  {
                    cx: i * cellSize + cellSize / 2,
                    cy: j * cellSize + cellSize / 2,
                    fill: "var(--wk-colors-qrCodeDot)",
                    r: cellSize / 3
                  },
                  `circle-${i}-${j}`
                )
              );
            }
          }
        }
      });
    });
    return dots2;
  }, [ecl, clearSize, size2, uri]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, height: "100%", width: "100%", viewBox: `0 0 ${size2} ${size2}`, children: dots });
}
var clsContainer$5 = "wk_92eoeu1";
var clsCorner = "wk_92eoeu2";
function QRCodePlaceHolder() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: clsContainer$5, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: "span", className: clsCorner }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: "span", className: clsCorner }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: "span", className: clsCorner })
  ] });
}
var clsQrCodeContainer = "wk_10yx5n50";
var clsQrCodeLogo = "wk_10yx5n52";
var clsQrCodeWrapper = "wk_10yx5n51";
function CustomQRCode(props) {
  const { className, logo, logoSize = 44, value, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-qrcode", clsQrCodeContainer, className), ...restProps, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: clsQrCodeWrapper, children: [
    value ? /* @__PURE__ */ jsxRuntimeExports.jsx(Transition, { in: !!value, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { uri: value }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodePlaceHolder, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: cx("wk-qrcode-logo", clsQrCodeLogo),
        style: {
          width: logoSize,
          height: logoSize,
          opacity: value ? 1 : 0.3
        },
        children: logo
      }
    )
  ] }) });
}
var clsContainer$4 = "wk_1j0944g0";
var clsOfficialButton = "wk_1j0944g1";
function TemplateQRCodeView(props) {
  const { wallet, qrCodeUri, onClickOpenWcModal, isConnected, isWalletConnect: isWalletConnect2, address: address2 } = props;
  const { options } = useWalletKit();
  const logos = useWalletLogos(wallet == null ? void 0 : wallet.logos);
  useAutoCloseConnectModal(isConnected, address2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalHeader, { children: "Scan with your phone" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalBody, { className: cx("wk-scan-qrcode", clsContainer$4), children: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomQRCode, { value: qrCodeUri, logo: logos.default }) }),
    isWalletConnect2 && !(options == null ? void 0 : options.hideOfficialWalletConnectCTA) && /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Link,
      {
        className: cx("wk-official-wc-button", clsOfficialButton),
        onClick: onClickOpenWcModal,
        children: [
          "Open the official WalletConnect modal",
          /* @__PURE__ */ jsxRuntimeExports.jsx(ForwardIcon, {})
        ]
      }
    ) })
  ] });
}
function useWalletConnectConnector() {
  const connectors = useConnectors();
  return connectors.find((item) => isWalletConnect(item.id));
}
function useWalletConnectUri(props = {}) {
  const { enabled = true, refreshUriOnError = true } = props;
  const { connectAsync } = useEvmConnect();
  const { log: log2 } = useWalletKit();
  const connector = useWalletConnectConnector();
  const isConnected = useIsConnected();
  const [wcUri, setWcUri] = reactExports.useState();
  reactExports.useEffect(() => {
    if (isConnected || !connector || !enabled)
      return;
    const onUpdateWcUri = ({ type: type2, data }) => {
      if (type2 === "display_uri") {
        setWcUri(data);
      }
    };
    const connectWallet = async () => {
      try {
        log2("[WcUri]", "connecting");
        const provider = await (connector == null ? void 0 : connector.getProvider());
        provider.rpc.showQrModal = false;
        await connectAsync({ connector });
      } catch (error) {
        if ((error == null ? void 0 : error.code) === 4001 && refreshUriOnError) {
          connectWallet();
        }
      }
    };
    connectWallet();
    connector.emitter.on("message", onUpdateWcUri);
    return () => {
      connector == null ? void 0 : connector.emitter.off("message", onUpdateWcUri);
    };
  }, [isConnected, enabled, refreshUriOnError]);
  return {
    wcUri
  };
}
function useWalletConnectModal() {
  const { connectAsync } = useEvmConnect();
  const connectModal = useConnectModal();
  const { log: log2 } = useWalletKit();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isOpen) {
      const timer2 = setTimeout(() => {
        connectModal.onClose();
      }, 800);
      return () => {
        clearTimeout(timer2);
      };
    }
  }, [connectModal, isOpen]);
  const connector = useWalletConnectConnector();
  return {
    isOpen,
    onOpen: async () => {
      document.body.style.setProperty("--wcm-z-index", "2147483647");
      const provider = await (connector == null ? void 0 : connector.getProvider());
      provider.rpc.showQrModal = true;
      if (connector) {
        setIsOpen(true);
        try {
          await connectAsync({ connector });
        } catch (err) {
          log2("[OpenWcModal]", err);
        }
        setIsOpen(false);
      }
    }
  };
}
function EvmQRCodeView() {
  var _a3;
  const { selectedWallet } = useWalletKit();
  const { wcUri } = useWalletConnectUri();
  const wcModal = useWalletConnectModal();
  const qrCodeUri = wcUri && (((_a3 = selectedWallet.getUri) == null ? void 0 : _a3.call(selectedWallet, wcUri)) ?? wcUri);
  const isConnected = useIsConnected();
  const { address: address2 } = useAccount();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TemplateQRCodeView,
    {
      wallet: selectedWallet,
      qrCodeUri,
      onClickOpenWcModal: wcModal.onOpen,
      isConnected,
      isWalletConnect: isWalletConnect(selectedWallet.id),
      address: address2
    }
  );
}
function EvmUriConnectingView() {
  const { selectedWallet } = useWalletKit();
  const isConnected = useIsConnected();
  const { address: address2 } = useAccount();
  const { status, setStatus } = useConnectingStatus({
    initialStatus: CONNECT_STATUS.CONNECTING
  });
  const { wcUri } = useWalletConnectUri({
    enabled: status !== CONNECT_STATUS.CONNECTING,
    refreshUriOnError: false
  });
  const onTryAgain = () => {
    setStatus(CONNECT_STATUS.CONNECTING);
    const walletUri = selectedWallet.getUri(wcUri);
    openLink(walletUri);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TemplateConnectingView,
    {
      isConnected,
      status,
      runConnect: () => void 0,
      onTryAgain,
      wallet: selectedWallet,
      address: address2
    }
  );
}
function useSolanaConnect() {
  const { solanaConfig } = useWalletKit();
  const { select, wallets: adapters2, connected } = useWallet$1();
  const connect2 = reactExports.useCallback(
    async ({ adapterName }) => {
      var _a3;
      select(adapterName);
      if (!(solanaConfig == null ? void 0 : solanaConfig.autoConnect)) {
        const adapter = (_a3 = adapters2.find((item) => item.adapter.name === adapterName)) == null ? void 0 : _a3.adapter;
        if (adapter) {
          await adapter.connect();
        }
      }
    },
    [adapters2, select, solanaConfig == null ? void 0 : solanaConfig.autoConnect]
  );
  return {
    connect: connect2,
    isConnected: connected
  };
}
function solanaCommonErrorHandler(props) {
  const { log: log2, handler, error } = props;
  if (error) {
    const description = error.message || error.name;
    log2("[WalletError]", error);
    handler == null ? void 0 : handler(error, description);
  }
}
function SolanaConnectingView() {
  const { log: log2, selectedWallet, options } = useWalletKit();
  const [status, setStatus] = reactExports.useState(
    selectedWallet.isInstalled() ? CONNECT_STATUS.CONNECTING : CONNECT_STATUS.UNAVAILABLE
  );
  const { isConnected, connect: connect2 } = useSolanaConnect();
  const { publicKey: publicKey2 } = useWallet$1();
  reactExports.useEffect(() => {
    const onError = (error) => {
      let message2 = "";
      if (error.message.includes("Error Calling Method: requestAccounts") || error.message.includes("rejected")) {
        message2 = "User rejected the request";
        setStatus(CONNECT_STATUS.REJECTED);
      } else {
        setStatus(CONNECT_STATUS.FAILED);
      }
      solanaCommonErrorHandler({
        log: log2,
        handler: options.onError,
        error: {
          message: message2
        }
      });
    };
    EventEmitter.on(EventEmitter.SOLANA_WALLET_ERROR, onError);
    return () => {
      EventEmitter.off(EventEmitter.SOLANA_WALLET_ERROR, onError);
    };
  }, [options.onError, log2]);
  const runConnect = reactExports.useCallback(async () => {
    if (!selectedWallet.isInstalled())
      return;
    setStatus(CONNECT_STATUS.CONNECTING);
    connect2({
      adapterName: selectedWallet.adapterName
    });
  }, [connect2, selectedWallet]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TemplateConnectingView,
    {
      status,
      runConnect,
      onTryAgain: runConnect,
      wallet: selectedWallet,
      isConnected,
      address: publicKey2 == null ? void 0 : publicKey2.toBase58()
    }
  );
}
function SolanaQRCodeView() {
  return null;
}
const MOBILE_MEDIA = "screen and (max-width: 767px)";
function useMediaQuery(query) {
  const [isMatched, setIsMatched] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const onChange = () => {
      const isMatched2 = window.matchMedia(query).matches;
      setIsMatched(isMatched2);
    };
    onChange();
    const matchMedia = window.matchMedia(query);
    matchMedia.addEventListener("change", onChange);
    return () => {
      matchMedia.removeEventListener("change", onChange);
    };
  }, [query]);
  return isMatched;
}
const useResponsive = () => {
  const isMobileLayout = useMediaQuery(MOBILE_MEDIA);
  return {
    isMobileLayout
  };
};
const WalletIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: 24, height: 24, viewBox: "0 0 40 40", fill: "currentColor", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M4.16669 12.5C4.16669 9.73858 6.40526 7.5 9.16669 7.5H30.8334C33.5948 7.5 35.8334 9.73858 35.8334 12.5V27.5C35.8334 30.2614 33.5948 32.5 30.8334 32.5H9.16669C6.40526 32.5 4.16669 30.2614 4.16669 27.5V12.5ZM9.16669 10.8333C8.24621 10.8333 7.50002 11.5795 7.50002 12.5V27.5C7.50002 28.4205 8.24621 29.1667 9.16669 29.1667H30.8334C31.7538 29.1667 32.5 28.4205 32.5 27.5V26.4583H24.1667C20.5998 26.4583 17.7084 23.5668 17.7084 20C17.7084 16.4332 20.5998 13.5417 24.1667 13.5417H32.5V12.5C32.5 11.5795 31.7538 10.8333 30.8334 10.8333H9.16669ZM32.5 16.4583H24.1667C22.2107 16.4583 20.625 18.044 20.625 20C20.625 21.956 22.2107 23.5417 24.1667 23.5417H32.5V16.4583ZM26.6667 20C26.6667 21.1506 25.7339 22.0833 24.5834 22.0833C23.4328 22.0833 22.5 21.1506 22.5 20C22.5 18.8494 23.4328 17.9167 24.5834 17.9167C25.7339 17.9167 26.6667 18.8494 26.6667 20Z"
    }
  ) });
};
var clsWalletOption$1 = "wk_1dbgl2y1";
var clsWalletOptionDisabled$1 = "wk_1dbgl2y4";
var clsWalletOptionIcon$1 = "wk_1dbgl2y3";
var clsWalletOptionName$1 = "wk_1dbgl2y2";
var clsWalletOptionWrapper = "wk_1dbgl2y0";
const Text = (props) => {
  const { ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: "p", ...restProps });
};
Text.displayName = "Text";
function useWalletRender(props) {
  const { wallet, layout, clickRef, defaultRender } = props;
  const { colorMode } = useTheme();
  const logos = useWalletLogos(wallet.logos);
  const renderOptions = {
    layout,
    colorMode,
    wallet: {
      id: wallet.id,
      walletType: wallet.walletType,
      name: wallet.name,
      logo: layout === "grid" ? logos.default : logos.transparent,
      isDisabled: wallet.isDisabled,
      isVisible: wallet.isVisible
    },
    onClick(e2) {
      var _a3;
      (_a3 = clickRef.current) == null ? void 0 : _a3.call(clickRef, wallet.id, e2);
    }
  };
  const render2 = wallet.render ?? defaultRender;
  return render2 == null ? void 0 : render2(renderOptions);
}
function SetEvmWalletClickRef(props) {
  const { clickRef } = props;
  const { log: log2, options, evmConfig, setSelectedWallet } = useWalletKit();
  const { disconnect: disconnect2 } = useDisconnect();
  const wcModal = useWalletConnectModal();
  const connectModal = useConnectModal();
  const router = useRouter();
  const timerRef = reactExports.useRef();
  clickRef.current = (walletId, e2) => {
    var _a3;
    const wallet = evmConfig.wallets.find((item) => item.id === walletId);
    const pass = (_a3 = options.onClickWallet) == null ? void 0 : _a3.call(options, wallet, e2);
    if (pass === false)
      return;
    log2("[ClickWallet]", `ethereum:`, typeof window.ethereum);
    log2("[ClickWallet]", `installed:`, wallet.isInstalled());
    const jumpTo = (viewRoute) => {
      setSelectedWallet(wallet);
      if (connectModal.isOpen) {
        router.push(viewRoute);
      } else {
        connectModal.onOpen({
          viewRoute
        });
      }
    };
    const jumpToQRCodeView = () => {
      var _a4;
      const qrCodeUri = wallet.getUri("xxx");
      if (qrCodeUri) {
        jumpTo(ViewRoutes.EVM_QRCODE);
      } else {
        (_a4 = options.onError) == null ? void 0 : _a4.call(
          options,
          new Error(`The wallet does not support QR code`),
          `The wallet does not support QR code`
        );
      }
    };
    const jumpToConnectingView = () => {
      jumpTo(ViewRoutes.EVM_CONNECTING);
    };
    const jumpToDeepLink = () => {
      var _a4;
      const deepLink = wallet.getDeepLink();
      if (deepLink) {
        openLink(deepLink);
      } else {
        (_a4 = options.onError) == null ? void 0 : _a4.call(
          options,
          new Error(`The wallet does not support deeplink`),
          `The wallet does not support deeplink`
        );
      }
    };
    const jumpToUriConnectingView = () => {
      var _a4;
      const wcUri = getEvmGlobalData().homeViewWalletConnectUri;
      if (wcUri) {
        const connectUri = wallet.getUri(wcUri);
        if (connectUri) {
          openLink(connectUri);
          jumpTo(ViewRoutes.EVM_URI_CONNECTING);
        } else {
          (_a4 = options.onError) == null ? void 0 : _a4.call(
            options,
            new Error(`The wallet does not support URI connection`),
            `The wallet does not support URI connection`
          );
        }
      }
    };
    disconnect2();
    clearTimeout(timerRef.current);
    timerRef.current = setTimeout(() => {
      if (isTMA()) {
        if (isMobile()) {
          if (isWalletConnect(walletId)) {
            wcModal.onOpen();
          } else {
            jumpToUriConnectingView();
          }
        } else {
          jumpToQRCodeView();
        }
      } else if (isMobile()) {
        if (isWalletConnect(walletId)) {
          wcModal.onOpen();
        } else if (wallet.isInstalled()) {
          jumpToConnectingView();
        } else {
          jumpToDeepLink();
        }
      } else {
        if (isWalletConnect(walletId)) {
          if (wallet.showQRCode) {
            jumpToQRCodeView();
          } else {
            wcModal.onOpen();
          }
        } else if (wallet.showQRCode) {
          jumpToQRCodeView();
        } else {
          jumpToConnectingView();
        }
      }
    }, 300);
  };
  return null;
}
function SetSolanaWalletClickRef(props) {
  const { clickRef } = props;
  const { log: log2, options, setSelectedWallet, solanaConfig } = useWalletKit();
  const { disconnect: disconnect2 } = useWallet$1();
  const { connect: connect2 } = useSolanaConnect();
  const connectModal = useConnectModal();
  const router = useRouter();
  const timerRef = reactExports.useRef();
  clickRef.current = (walletId, e2) => {
    var _a3;
    const wallet = solanaConfig.wallets.find((item) => item.id === walletId);
    const pass = (_a3 = options.onClickWallet) == null ? void 0 : _a3.call(options, wallet, e2);
    if (pass === false)
      return;
    log2("[ClickWallet]", `wallet:`, wallet);
    log2("[ClickWallet]", `installed:`, wallet.isInstalled());
    const jumpTo = (viewRoute) => {
      setSelectedWallet(wallet);
      if (connectModal.isOpen) {
        router.push(viewRoute);
      } else {
        connectModal.onOpen({
          viewRoute
        });
      }
    };
    const jumpToConnectingView = () => {
      jumpTo(ViewRoutes.SOLANA_CONNECTING);
    };
    disconnect2();
    clearTimeout(timerRef.current);
    timerRef.current = setTimeout(() => {
      if (isMobile()) {
        const deeplink = wallet.getDeepLink();
        if (wallet.isInstalled()) {
          jumpToConnectingView();
        } else if (deeplink) {
          openLink(deeplink);
        } else {
          connect2({
            adapterName: wallet.adapterName
          });
        }
      } else {
        jumpToConnectingView();
      }
    }, 300);
  };
  return null;
}
function useTronConnect() {
  const { select, wallets: adapters2, connected } = useWallet();
  const [isConnected, setIsConnected] = reactExports.useState(connected);
  const connect2 = reactExports.useCallback(
    async ({ adapterName, chainId }) => {
      var _a3;
      select(adapterName);
      const finalChainId = typeof chainId === "number" ? `0x${chainId.toString(16)}` : chainId;
      const adapter = (_a3 = adapters2.find((item) => item.adapter.name === adapterName)) == null ? void 0 : _a3.adapter;
      if (adapter) {
        await adapter.connect();
        setIsConnected(true);
        if (finalChainId && !isMobile()) {
          await (adapter == null ? void 0 : adapter.switchChain(finalChainId));
        }
      }
    },
    [adapters2, select]
  );
  return {
    connect: connect2,
    isConnected
  };
}
function SetTronWalletClickRef(props) {
  const { clickRef } = props;
  const { log: log2, options, setSelectedWallet, tronConfig } = useWalletKit();
  const { disconnect: disconnect2 } = useWallet();
  const { connect: connect2 } = useTronConnect();
  const connectModal = useConnectModal();
  const router = useRouter();
  const timerRef = reactExports.useRef();
  clickRef.current = (walletId, e2) => {
    var _a3;
    const wallet = tronConfig.wallets.find((item) => item.id === walletId);
    const pass = (_a3 = options.onClickWallet) == null ? void 0 : _a3.call(options, wallet, e2);
    if (pass === false)
      return;
    log2("[ClickWallet]", `wallet:`, wallet);
    log2("[ClickWallet]", `installed:`, wallet.isInstalled());
    const jumpTo = (viewRoute) => {
      setSelectedWallet(wallet);
      if (connectModal.isOpen) {
        router.push(viewRoute);
      } else {
        connectModal.onOpen({
          viewRoute
        });
      }
    };
    const jumpToConnectingView = () => {
      jumpTo(ViewRoutes.TRON_CONNECTING);
    };
    disconnect2();
    clearTimeout(timerRef.current);
    timerRef.current = setTimeout(() => {
      if (isMobile()) {
        if (wallet.isInstalled()) {
          jumpToConnectingView();
        } else {
          connect2({
            adapterName: wallet.adapterName
          });
        }
      } else {
        jumpToConnectingView();
      }
    }, 300);
  };
  return null;
}
function SetWalletClickRef(props) {
  const { wallet, clickRef } = props;
  if (wallet.walletType === "evm") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SetEvmWalletClickRef, { clickRef });
  }
  if (wallet.walletType === "solana") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SetSolanaWalletClickRef, { clickRef });
  }
  if (wallet.walletType === "tron") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SetTronWalletClickRef, { clickRef });
  }
}
function WalletOption$1(props) {
  const { wallet } = props;
  const clickRef = reactExports.useRef();
  const component = useWalletRender({
    wallet,
    layout: "grid",
    clickRef,
    defaultRender: ({ wallet: wallet2, onClick }) => {
      const { isDisabled, name, logo } = wallet2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-wallet-option-wrapper", clsWalletOptionWrapper), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          className: cx(
            "wk-wallet-option",
            clsWalletOption$1,
            isDisabled ? clsWalletOptionDisabled$1 : void 0
          ),
          onClick: isDisabled ? void 0 : onClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-wallet-option-logo", clsWalletOptionIcon$1), children: logo }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { className: cx("wk-wallet-option-name", clsWalletOptionName$1), children: name })
          ]
        }
      ) });
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SetWalletClickRef, { wallet, clickRef }),
    component
  ] });
}
var clsNoWalletButton = "wk_cvot8n1";
var clsWallets$1 = "wk_cvot8n0";
function GridLayout(props) {
  const { visibleWallets } = props;
  const { options } = useWalletKit();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalBody, { className: cx("wk-wallets", clsWallets$1), "data-layout": "grid", children: visibleWallets == null ? void 0 : visibleWallets.map((w2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(WalletOption$1, { wallet: w2 }, index2)) }),
    !options.hideNoWalletCTA && /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        as: "a",
        className: cx("wk-nowallet-button", clsNoWalletButton),
        href: options.walletDownloadUrl,
        target: "_blank",
        rel: "noopener",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(WalletIcon, {}),
          "I dont have a wallet"
        ]
      }
    ) })
  ] });
}
var clsNoWalletLink = "wk_1lg2shr1";
var clsWallets = "wk_1lg2shr0";
var clsWalletOption = "wk_713zwr0";
var clsWalletOptionDisabled = "wk_713zwr3";
var clsWalletOptionIcon = "wk_713zwr2";
var clsWalletOptionName = "wk_713zwr1";
function WalletOption(props) {
  const { wallet } = props;
  const clickRef = reactExports.useRef();
  const component = useWalletRender({
    wallet,
    layout: "list",
    clickRef,
    defaultRender: ({ wallet: wallet2, onClick }) => {
      const { isDisabled, name, logo } = wallet2;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          className: cx(
            "wk-wallet-option",
            clsWalletOption,
            isDisabled ? clsWalletOptionDisabled : void 0
          ),
          onClick: isDisabled ? void 0 : onClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { className: cx("wk-wallet-option-name", clsWalletOptionName), children: name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-wallet-option-logo", clsWalletOptionIcon), children: logo })
          ]
        }
      );
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SetWalletClickRef, { wallet, clickRef }),
    component
  ] });
}
function ListLayout(props) {
  const { visibleWallets } = props;
  const { options } = useWalletKit();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalBody, { className: cx("wk-wallets", clsWallets), "data-layout": "list", children: visibleWallets == null ? void 0 : visibleWallets.map((w2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(WalletOption, { wallet: w2 }, index2)) }),
    !options.hideNoWalletCTA && /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Link,
      {
        className: cx("wk-nowallet-link", clsNoWalletLink),
        href: options.walletDownloadUrl,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(WalletIcon, {}),
          "I dont have a wallet"
        ]
      }
    ) })
  ] });
}
var clsDisclaimer = "wk_zqrn660";
function EvmHomeViewWalletConnectUriProvider() {
  const { wcUri } = useWalletConnectUri({
    refreshUriOnError: false
  });
  setEvmGlobalData({
    homeViewWalletConnectUri: wcUri
  });
  return null;
}
function HomeView() {
  const { wallets: wallets2, options } = useWalletKit();
  const { isMobileLayout } = useResponsive();
  const visibleWallets = wallets2.filter((item) => item.isVisible !== false);
  const useGridLayout = visibleWallets.length >= options.gridLayoutThreshold || isMobileLayout && options.useGridLayoutOnMobile;
  const needPreCreateWcUri = isTMA() && isMobile();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalHeader, { children: options.title }),
    options.disclaimer && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-disclaimer", clsDisclaimer), children: options.disclaimer }),
    useGridLayout ? /* @__PURE__ */ jsxRuntimeExports.jsx(GridLayout, { visibleWallets }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ListLayout, { visibleWallets }),
    needPreCreateWcUri && /* @__PURE__ */ jsxRuntimeExports.jsx(EvmHomeViewWalletConnectUriProvider, {})
  ] });
}
function tronCommonErrorHandler(props) {
  const { log: log2, handler, error } = props;
  if (error) {
    const description = error.message || error.name;
    log2("[WalletError]", error);
    handler == null ? void 0 : handler(error, description);
  }
}
function TronConnectingView() {
  const { log: log2, selectedWallet, options, tronConfig } = useWalletKit();
  const [status, setStatus] = reactExports.useState(
    selectedWallet.isInstalled() ? CONNECT_STATUS.CONNECTING : CONNECT_STATUS.UNAVAILABLE
  );
  const { connect: connect2, isConnected } = useTronConnect();
  const { address: address2 } = useWallet();
  reactExports.useEffect(() => {
    const onError = (error) => {
      let message2 = "";
      if (error.message.includes("rejected")) {
        message2 = "User rejected the request";
        setStatus(CONNECT_STATUS.REJECTED);
      } else {
        setStatus(CONNECT_STATUS.FAILED);
      }
      tronCommonErrorHandler({
        log: log2,
        handler: options.onError,
        error: {
          message: message2
        }
      });
    };
    EventEmitter.on(EventEmitter.TRON_WALLET_ERROR, onError);
    return () => {
      EventEmitter.off(EventEmitter.TRON_WALLET_ERROR, onError);
    };
  }, [options.onError, log2]);
  const runConnect = reactExports.useCallback(async () => {
    if (!selectedWallet.isInstalled())
      return;
    setStatus(CONNECT_STATUS.CONNECTING);
    connect2({
      adapterName: selectedWallet.adapterName,
      chainId: tronConfig == null ? void 0 : tronConfig.initialChainId
    });
  }, [connect2, selectedWallet, tronConfig == null ? void 0 : tronConfig.initialChainId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TemplateConnectingView,
    {
      status,
      runConnect,
      onTryAgain: runConnect,
      wallet: selectedWallet,
      isConnected,
      address: address2
    }
  );
}
var ViewRoutes = /* @__PURE__ */ ((ViewRoutes2) => {
  ViewRoutes2["HOME"] = "HOME";
  ViewRoutes2["EVM_CONNECTING"] = "EVM_CONNECTING";
  ViewRoutes2["EVM_QRCODE"] = "EVM_QRCODE";
  ViewRoutes2["EVM_URI_CONNECTING"] = "EVM_URI_CONNECTING";
  ViewRoutes2["SOLANA_CONNECTING"] = "SOLANA_CONNECTING";
  ViewRoutes2["SOLANA_QRCODE"] = "SOLANA_QRCODE";
  ViewRoutes2["TRON_CONNECTING"] = "TRON_CONNECTING";
  return ViewRoutes2;
})(ViewRoutes || {});
function RouteProvider(props) {
  const { children } = props;
  const [route, setRoute] = reactExports.useState("");
  const { current: history } = reactExports.useRef([]);
  const view = reactExports.useMemo(() => {
    switch (route) {
      case "HOME":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(HomeView, {});
      case "EVM_CONNECTING":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EvmConnectingView, {});
      case "EVM_QRCODE":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EvmQRCodeView, {});
      case "EVM_URI_CONNECTING":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EvmUriConnectingView, {});
      case "SOLANA_CONNECTING":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SolanaConnectingView, {});
      case "SOLANA_QRCODE":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SolanaQRCodeView, {});
      case "TRON_CONNECTING":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TronConnectingView, {});
    }
    return null;
  }, [route]);
  const back = reactExports.useCallback(() => {
    history.pop();
    const nextRoute = history[history.length - 1];
    if (nextRoute) {
      setRoute(nextRoute);
    }
  }, [history]);
  const push = reactExports.useCallback(
    (nextRoute) => {
      if (nextRoute === "HOME") {
        reset();
      }
      if (history[history.length - 1] !== nextRoute) {
        history.push(nextRoute);
        setRoute(nextRoute);
      }
    },
    [history]
  );
  const replace = reactExports.useCallback(
    (nextRoute) => {
      if (history[history.length - 1] !== nextRoute) {
        history[history.length - 1] = nextRoute;
        setRoute(nextRoute);
      }
    },
    [history]
  );
  const reset = reactExports.useCallback(() => {
    history.length = 0;
  }, [history]);
  const value = reactExports.useMemo(() => {
    return {
      route,
      view,
      back,
      push,
      replace,
      reset,
      history
    };
  }, [back, history, view, push, replace, reset, route]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RouteContext.Provider, { value, children });
}
function useDisclosure() {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const onOpen = reactExports.useCallback(() => {
    setIsOpen(true);
  }, []);
  const onClose = reactExports.useCallback(() => {
    setIsOpen(false);
  }, []);
  return {
    isOpen,
    onOpen,
    onClose
  };
}
function ConnectModalProvider(props) {
  const { children } = props;
  const { setAction, evmConfig, tronConfig, options } = useWalletKit();
  const { isOpen, onClose, onOpen } = useDisclosure();
  const router = useRouter();
  const value = reactExports.useMemo(() => {
    return {
      isOpen,
      onClose() {
        onClose();
        setTimeout(() => {
          router.reset();
        }, 300);
      },
      onOpen(params = {}) {
        var _a3, _b2;
        router.push(params.viewRoute ?? ViewRoutes.HOME);
        setAction(params.action);
        if (evmConfig && params.initialChainId) {
          evmConfig.initialChainId = params.initialChainId;
        }
        if (evmConfig && ((_a3 = params.evmConfig) == null ? void 0 : _a3.initialChainId)) {
          evmConfig.initialChainId = params.evmConfig.initialChainId;
        }
        if (tronConfig && ((_b2 = params.tronConfig) == null ? void 0 : _b2.initialChainId)) {
          tronConfig.initialChainId = params.tronConfig.initialChainId;
        }
        if (params.onConnected) {
          options.onConnected = params.onConnected;
        }
        onOpen();
      }
    };
  }, [evmConfig, isOpen, onClose, onOpen, options, router, setAction, tronConfig]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectModalContext.Provider, { value, children });
}
const Portal = (props) => {
  const { children } = props;
  const portal = reactExports.useRef();
  const [, forceUpdate] = reactExports.useState({});
  reactExports.useEffect(() => {
    const host = document.body;
    portal.current = document.createElement("div");
    portal.current.setAttribute("class", "wk-portal");
    host.appendChild(portal.current);
    forceUpdate({});
    const portalNode = portal.current;
    return () => {
      if (host.contains(portalNode)) {
        host.removeChild(portalNode);
      }
    };
  }, []);
  return portal.current ? reactDomExports.createPortal(children, portal.current) : null;
};
Portal.displayName = "Portal";
var clsContainer$3 = "wk_1sntu031";
var clsDescWrapper = "wk_1sntu033";
var clsIconWrapper = "wk_1sntu032";
var clsToastRoot = "wk_1sntu030";
const ErrorIcon = (props) => {
  const errorColor = cssVar("error");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M18.3333 10.0001C18.3333 14.6025 14.6024 18.3334 9.99999 18.3334C5.39762 18.3334 1.66666 14.6025 1.66666 10.0001C1.66666 5.39771 5.39762 1.66675 9.99999 1.66675C14.6024 1.66675 18.3333 5.39771 18.3333 10.0001Z",
        fill: errorColor
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M13.5503 7.41394C13.8166 7.14767 13.8166 6.71597 13.5503 6.4497C13.284 6.18343 12.8523 6.18343 12.5861 6.4497L10 8.90372L7.41394 6.4497C7.14767 6.18343 6.71597 6.18343 6.4497 6.4497C6.18343 6.71597 6.18343 7.14767 6.4497 7.41394L8.90372 10L6.4497 12.5861C6.18343 12.8523 6.18343 13.284 6.4497 13.5503C6.71597 13.8166 7.14767 13.8166 7.41394 13.5503L10 11.0963L12.5861 13.5503C12.8523 13.8166 13.284 13.8166 13.5503 13.5503C13.8166 13.284 13.8166 12.8523 13.5503 12.5861L11.0963 10L13.5503 7.41394Z",
        fill: "white"
      }
    )
  ] });
};
const InfoIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M18.3333 10.0001C18.3333 14.6025 14.6024 18.3334 9.99999 18.3334C5.39762 18.3334 1.66666 14.6025 1.66666 10.0001C1.66666 5.39771 5.39762 1.66675 9.99999 1.66675C14.6024 1.66675 18.3333 5.39771 18.3333 10.0001Z",
        fill: "#5F8BFF"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "10", cy: "5.41675", r: "1.25", fill: "white" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M10.579 7.55143L7.87065 7.8755C7.65964 7.89895 7.5 8.07731 7.5 8.28962V8.75002C7.5 8.98014 7.68931 9.15814 7.91392 9.20817C8.47131 9.33231 8.95833 9.73515 8.95833 10.4167V12.9167C8.95833 13.5982 8.47131 14.0011 7.91392 14.1252C7.68931 14.1752 7.5 14.3532 7.5 14.5834V15C7.5 15.2301 7.68655 15.4167 7.91667 15.4167H12.0833C12.3135 15.4167 12.5 15.2301 12.5 15V14.5834C12.5 14.3532 12.3107 14.1752 12.0861 14.1252C11.5287 14.0011 11.0417 13.5982 11.0417 12.9167V7.96525C11.0417 7.71691 10.8258 7.52401 10.579 7.55143Z",
        fill: "white"
      }
    )
  ] });
};
const iconMap = {
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoIcon, {}),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, {})
};
function ToastComponent(props) {
  const { variant = "info", description, duration, toastId } = props;
  const [show, setShow] = reactExports.useState(true);
  const [delay, setDelay] = reactExports.useState(duration);
  reactExports.useEffect(() => {
    if (delay) {
      const timer2 = setTimeout(() => {
        setShow(false);
      }, delay);
      return () => {
        clearTimeout(timer2);
      };
    }
  }, [delay]);
  const onExit = () => {
    ToastManager.remove(toastId);
  };
  const onMouseEnter = () => {
    setDelay(void 0);
  };
  const onMouseLeave = () => {
    setDelay(duration);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Transition, { in: show, variant: "toast-slide", onExit, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: "wk-toast", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: clsContainer$3, onMouseEnter, onMouseLeave, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: clsIconWrapper, children: iconMap[variant] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: clsDescWrapper, children: description })
  ] }) }) });
}
const ToastProvider = () => {
  const [toastList, setToastList] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const update = (newList) => {
      setToastList(newList);
    };
    ToastManager.subscribe(update);
    return () => {
      ToastManager.unsubscribe(update);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: toastList.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-toast-container", clsToastRoot), children: toastList.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(ToastComponent, { ...item }, item.toastId)) }) }) });
};
ToastProvider.displayName = "ToastProvider";
const ProfileModalContext = React.createContext({});
function ProfileModalProvider(props) {
  const { children } = props;
  const { isOpen, onClose, onOpen } = useDisclosure();
  const value = reactExports.useMemo(() => {
    return {
      isOpen,
      onClose,
      onOpen
    };
  }, [isOpen, onClose, onOpen]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileModalContext.Provider, { value, children });
}
function TronWalletProvider(props) {
  const { children } = props;
  const { tronConfig } = useWalletKit();
  reactExports.useMemo(() => {
    try {
      if (typeof window !== "undefined" && !(tronConfig == null ? void 0 : tronConfig.autoConnect)) {
        window.localStorage.removeItem("tronAdapterName");
      }
    } catch (err) {
      console.log(err);
    }
  }, [tronConfig == null ? void 0 : tronConfig.autoConnect]);
  const onError = reactExports.useCallback((error) => {
    EventEmitter.emit(EventEmitter.TRON_WALLET_ERROR, error);
  }, []);
  if (!tronConfig) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WalletProvider,
    {
      adapters: tronConfig.adapters,
      autoConnect: false,
      onError,
      children
    }
  );
}
const SwitchNetworkModalContext = React.createContext({});
function SwitchNetworkProvider(props) {
  const { children } = props;
  const [isClosable, setIsClosable] = reactExports.useState(true);
  const { isOpen, onClose, onOpen } = useDisclosure();
  const { isConnected, chain } = useAccount();
  const chains = useChains();
  const { options } = useWalletKit();
  const isSupported = chains == null ? void 0 : chains.find((e2) => e2.id === (chain == null ? void 0 : chain.id));
  const value = reactExports.useMemo(() => {
    return {
      isClosable,
      isOpen,
      onClose() {
        onClose();
        setTimeout(() => {
          setIsClosable(true);
        }, 300);
      },
      onOpen(options2) {
        const { isClosable: isClosable2 = true } = options2 ?? {};
        if (isConnected) {
          setIsClosable(isClosable2);
          onOpen();
        } else {
          toast.info({
            description: "Please connect a wallet first."
          });
        }
      }
    };
  }, [isClosable, isConnected, isOpen, onClose, onOpen]);
  reactExports.useEffect(() => {
    if (isConnected && options.openModalOnWrongNetwork) {
      const timer2 = setTimeout(() => {
        if (!isSupported) {
          value.onOpen({
            isClosable: false
          });
        }
      }, 300);
      return () => {
        clearTimeout(timer2);
      };
    }
  }, [isSupported, isConnected]);
  reactExports.useEffect(() => {
    if (isConnected && !isSupported) {
      setIsClosable(true);
    }
  }, [isSupported, isConnected]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchNetworkModalContext.Provider, { value, children });
}
function WalletKitProvider(props) {
  const { config: config2, children, theme, mode: mode2, debugMode = false } = props;
  const finalConfig = reactExports.useMemo(() => {
    var _a3, _b2, _c2;
    const finalConfig2 = getDefaultConfig(config2);
    const wallets22 = [];
    const evmWallets = (_a3 = finalConfig2.evmConfig) == null ? void 0 : _a3.wallets;
    const solanaWallets = (_b2 = finalConfig2.solanaConfig) == null ? void 0 : _b2.wallets;
    const tronWallets = (_c2 = finalConfig2.tronConfig) == null ? void 0 : _c2.wallets;
    if (evmWallets)
      wallets22.push(...evmWallets);
    if (solanaWallets)
      wallets22.push(...solanaWallets);
    if (tronWallets)
      wallets22.push(...tronWallets);
    return {
      ...finalConfig2,
      wallets: wallets22
    };
  }, [config2]);
  const [action, setAction] = reactExports.useState();
  const [selectedWallet, setSelectedWallet] = reactExports.useState({});
  const [wallets2, setWallets] = reactExports.useState(finalConfig.wallets);
  const value = reactExports.useMemo(() => {
    return {
      ...finalConfig,
      log: debugMode ? console.log : () => void 0,
      action,
      setAction,
      selectedWallet,
      setSelectedWallet,
      wallets: wallets2,
      setWallets
    };
  }, [action, debugMode, finalConfig, selectedWallet, wallets2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WalletKitContext.Provider, { value, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider, { mode: mode2, theme, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastProvider, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RouteProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(EvmWalletProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SolanaWalletProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TronWalletProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectModalProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileModalProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchNetworkProvider, { children }) }) }) }) }) }) })
  ] }) });
}
var clsModalContent = "wk_1kzf8pa0";
function ModalContent(props) {
  const { className, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: cx("wk-modal-content", clsModalContent, className), ...restProps });
}
var clsIconButton = "wk_1bjpejd0";
const IconButton = (props) => {
  const { className, icon, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: cx("wk-icon-button", clsIconButton, className), ...restProps, children: icon });
};
IconButton.displayName = "IconButton";
const BackIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 40 40", fill: "currentColor", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M24.5118 8.82165C25.1627 9.47253 25.1627 10.5278 24.5118 11.1787L15.6904 20.0002L24.5118 28.8217C25.1627 29.4725 25.1627 30.5278 24.5118 31.1787C23.861 31.8295 22.8057 31.8295 22.1548 31.1787L12.1548 21.1787C11.5039 20.5278 11.5039 19.4725 12.1548 18.8217L22.1548 8.82165C22.8057 8.17078 23.861 8.17078 24.5118 8.82165Z"
    }
  ) });
};
const CloseIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 40 40", fill: "currentColor", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12.0119 9.51184C11.361 8.86097 10.3057 8.86097 9.65484 9.51184C9.00397 10.1627 9.00397 11.218 9.65484 11.8689L17.643 19.857L9.51187 27.9882C8.86099 28.639 8.86099 29.6943 9.51187 30.3452C10.1627 30.9961 11.218 30.9961 11.8689 30.3452L20 22.214L27.9218 30.1358C28.5726 30.7867 29.6279 30.7867 30.2788 30.1358C30.9297 29.4849 30.9297 28.4296 30.2788 27.7788L22.357 19.857L30.1358 12.0783C30.7867 11.4274 30.7867 10.3721 30.1358 9.72123C29.4849 9.07036 28.4297 9.07036 27.7788 9.72123L20 17.5L12.0119 9.51184Z"
    }
  ) });
};
var clsNavbar = "wk_1nzgcmu0";
function Navbar(props) {
  const { className, showBack, showClose = true, onBack, onClose, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: cx("wk-navbar", clsNavbar, className), ...restProps, children: [
    showBack && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { className: "wk-navbar-back-button", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BackIcon, {}), onClick: onBack }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { style: { flex: 1 } }),
    showClose && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { className: "wk-navbar-close-button", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}), onClick: onClose })
  ] });
}
function useKeyDown(props = {}) {
  const { key = "Enter", enabled = true, handler } = props;
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    const onKeyDown = (e2) => {
      if (e2.code === key) {
        handler == null ? void 0 : handler();
      }
    };
    window.addEventListener("keydown", onKeyDown);
    return () => {
      window.removeEventListener("keydown", onKeyDown);
    };
  }, [enabled, handler, key]);
}
function useScrollLock(isLocked = false) {
  reactExports.useEffect(() => {
    if (!isLocked) {
      return;
    }
    const originalOverflow = document.documentElement.style.overflow;
    document.documentElement.style.overflow = "hidden";
    return () => {
      document.documentElement.style.overflow = originalOverflow;
    };
  }, [isLocked]);
}
var clsModal = "wk_3qg8ds0";
var clsModalOverlay = "wk_3qg8ds1";
function Modal(props) {
  const {
    className,
    isOpen,
    onClose,
    children,
    contentClassName,
    closeOnEsc = true,
    closeOnOverlayClick = true,
    ...restProps
  } = props;
  useKeyDown({
    key: "Escape",
    enabled: isOpen && closeOnEsc,
    handler() {
      onClose();
    }
  });
  useScrollLock(isOpen);
  const { isMobileLayout } = useResponsive();
  const { colorMode } = useTheme();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Transition, { in: isOpen, variant: "fade", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className: cx("wk-modal", clsModal, className),
      style: {
        colorScheme: colorMode
      },
      ...restProps,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            className: cx("wk-modal-overlay", clsModalOverlay),
            onClick: () => closeOnOverlayClick && onClose()
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Transition, { in: isOpen, variant: isMobileLayout ? "modal-slide" : void 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModalContent, { className: contentClassName, children }) })
      ]
    }
  ) }) });
}
function ConnectModal() {
  const { options } = useWalletKit();
  const { isOpen, onClose } = useConnectModal();
  const { view, history, back } = useRouter();
  const showBack = history.length > 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Modal,
    {
      className: "wk-connect-modal",
      isOpen,
      onClose,
      closeOnEsc: options == null ? void 0 : options.closeModalOnEsc,
      closeOnOverlayClick: options == null ? void 0 : options.closeModalOnOverlayClick,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Navbar, { showBack, onBack: back, onClose }),
        view
      ]
    }
  );
}
const mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
function MetaMaskTransparentIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M34.413 4.45703L21.9209 13.7351L24.231 8.26117L34.413 4.45703Z",
        fill: "#E2761B",
        stroke: "#E2761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M5.57422 4.45703L17.9659 13.823L15.7688 8.26117L5.57422 4.45703Z",
        fill: "#E4761B",
        stroke: "#E4761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M29.9179 25.9639L26.5908 31.0612L33.7095 33.0197L35.7559 26.0769L29.9179 25.9639Z",
        fill: "#E4761B",
        stroke: "#E4761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M4.25586 26.0769L6.28976 33.0197L13.4084 31.0612L10.0813 25.9639L4.25586 26.0769Z",
        fill: "#E4761B",
        stroke: "#E4761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.0071 17.3511L11.0234 20.3517L18.0919 20.6656L17.8408 13.0698L13.0071 17.3511Z",
        fill: "#E4761B",
        stroke: "#E4761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M26.9805 17.351L22.0841 12.9819L21.9209 20.6656L28.9768 20.3517L26.9805 17.351Z",
        fill: "#E4761B",
        stroke: "#E4761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.4082 31.061L17.6518 28.9895L13.9857 26.127L13.4082 31.061Z",
        fill: "#E4761B",
        stroke: "#E4761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M22.335 28.9895L26.5911 31.061L26.001 26.127L22.335 28.9895Z",
        fill: "#E4761B",
        stroke: "#E4761B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M26.5911 31.0608L22.335 28.9893L22.6739 31.7639L22.6363 32.9315L26.5911 31.0608Z",
        fill: "#D7C1B3",
        stroke: "#D7C1B3",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.4082 31.0608L17.363 32.9315L17.3379 31.7639L17.6518 28.9893L13.4082 31.0608Z",
        fill: "#D7C1B3",
        stroke: "#D7C1B3",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M17.4262 24.2939L13.8857 23.2519L16.3842 22.1094L17.4262 24.2939Z",
        fill: "#233447",
        stroke: "#233447",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M22.5615 24.2939L23.6036 22.1094L26.1146 23.2519L22.5615 24.2939Z",
        fill: "#233447",
        stroke: "#233447",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.4091 31.0607L14.0117 25.9634L10.082 26.0764L13.4091 31.0607Z",
        fill: "#CD6116",
        stroke: "#CD6116",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M25.9893 25.9634L26.5919 31.0607L29.919 26.0764L25.9893 25.9634Z",
        fill: "#CD6116",
        stroke: "#CD6116",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M28.9768 20.3516L21.9209 20.6654L22.5738 24.2938L23.6158 22.1093L26.1268 23.2518L28.9768 20.3516Z",
        fill: "#CD6116",
        stroke: "#CD6116",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.886 23.2518L16.3969 22.1093L17.4265 24.2938L18.0919 20.6654L11.0234 20.3516L13.886 23.2518Z",
        fill: "#CD6116",
        stroke: "#CD6116",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M11.0234 20.3516L13.9864 26.1268L13.886 23.2517L11.0234 20.3516Z",
        fill: "#E4751F",
        stroke: "#E4751F",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M26.1275 23.2517L26.002 26.1268L28.9775 20.3516L26.1275 23.2517Z",
        fill: "#E4751F",
        stroke: "#E4751F",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M18.0922 20.6655L17.4268 24.2939L18.2554 28.5751L18.4437 22.938L18.0922 20.6655Z",
        fill: "#E4751F",
        stroke: "#E4751F",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M21.921 20.6655L21.582 22.9254L21.7327 28.5751L22.5739 24.2939L21.921 20.6655Z",
        fill: "#E4751F",
        stroke: "#E4751F",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M22.5736 24.294L21.7324 28.5752L22.3351 28.9896L26.0011 26.127L26.1266 23.252L22.5736 24.294Z",
        fill: "#F6851B",
        stroke: "#F6851B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.8857 23.252L13.9862 26.127L17.6522 28.9896L18.2549 28.5752L17.4262 24.294L13.8857 23.252Z",
        fill: "#F6851B",
        stroke: "#F6851B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M22.6361 32.9317L22.6737 31.7641L22.3599 31.4879H17.6267L17.3379 31.7641L17.363 32.9317L13.4082 31.061L14.7892 32.191L17.589 34.137H22.3975L25.2098 32.191L26.5909 31.061L22.6361 32.9317Z",
        fill: "#C0AD9E",
        stroke: "#C0AD9E",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M22.3348 28.9895L21.7321 28.5752H18.2544L17.6518 28.9895L17.3379 31.7641L17.6267 31.4879H22.3599L22.6737 31.7641L22.3348 28.9895Z",
        fill: "#161616",
        stroke: "#161616",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M34.9401 14.3378L36.0073 9.21535L34.4128 4.45703L22.335 13.4212L26.9803 17.3509L33.5465 19.2718L35.0029 17.5769L34.3751 17.125L35.3795 16.2084L34.6011 15.6058L35.6055 14.84L34.9401 14.3378Z",
        fill: "#763D16",
        stroke: "#763D16",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M3.99219 9.21535L5.05936 14.3378L4.38139 14.84L5.38578 15.6058L4.61993 16.2084L5.62433 17.125L4.99658 17.5769L6.4404 19.2718L13.0066 17.3509L17.6519 13.4212L5.57411 4.45703L3.99219 9.21535Z",
        fill: "#763D16",
        stroke: "#763D16",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M33.5465 19.272L26.9803 17.3511L28.9765 20.3517L26.001 26.127L29.9181 26.0767H35.7562L33.5465 19.272Z",
        fill: "#F6851B",
        stroke: "#F6851B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.0066 17.3511L6.44042 19.272L4.25586 26.0767H10.0813L13.9859 26.127L11.023 20.3517L13.0066 17.3511Z",
        fill: "#F6851B",
        stroke: "#F6851B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M21.9205 20.6655L22.3348 13.4213L24.2431 8.26123H15.7686L17.6518 13.4213L18.0912 20.6655L18.2419 22.9505L18.2544 28.5751H21.7321L21.7573 22.9505L21.9205 20.6655Z",
        fill: "#F6851B",
        stroke: "#F6851B",
        strokeWidth: "0.0753296",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  ] });
}
function MetaMaskIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      width: "40",
      height: "40",
      viewBox: "0 0 68 68",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_6070_1947)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "68", height: "68", rx: "16", fill: "#3375BB" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              x: "-5.6665",
              y: "-3.40039",
              width: "79.3333",
              height: "74.8",
              fill: "url(#pattern0_metamask)"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "pattern",
            {
              id: "pattern0_metamask",
              patternContentUnits: "objectBoundingBox",
              width: "1",
              height: "1",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "use",
                {
                  xlinkHref: "#image0_6070_1947",
                  transform: "matrix(0.00217391 0 0 0.00230567 0 -0.00724637)"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_6070_1947", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "68", height: "68", rx: "16", fill: "white" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "image",
            {
              id: "image0_6070_1947",
              width: "460",
              height: "440",
              xlinkHref: "data:image/png;base64,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"
            }
          )
        ] })
      ]
    }
  );
}
const metaMaskConfig = {
  name: "MetaMask",
  logos: {
    default: /* @__PURE__ */ jsxRuntimeExports.jsx(MetaMaskIcon, {}),
    transparent: /* @__PURE__ */ jsxRuntimeExports.jsx(MetaMaskTransparentIcon, {})
  },
  downloadUrls: {
    default: "https://metamask.io/download/"
  },
  spinnerColor: "#F0B90B"
};
function metaMask(props = {}) {
  const { connectorOptions, ...restProps } = props;
  return {
    ...metaMaskConfig,
    id: "metaMask",
    walletType: "evm",
    showQRCode: false,
    isInstalled() {
      return hasEvmInjectedProvider("isMetaMask");
    },
    getDeepLink() {
      const dappPath = window.location.href.replace(/^https?:\/\//, "");
      return `https://metamask.app.link/dapp/${dappPath}`;
    },
    getUri(uri) {
      const encodedUri = encodeURIComponent(uri);
      return `https://metamask.app.link/wc?uri=${encodedUri}`;
    },
    getCreateConnectorFn() {
      return metaMask$1({
        useDeeplink: false,
        headless: true,
        openDeeplink(arg) {
          openLink(arg);
        },
        ...connectorOptions
      });
    },
    ...restProps
  };
}
const CoinbaseWalletTransparentIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CoinbaseWalletIcon, { width: 40, height: 40, ...props });
};
const CoinbaseWalletIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      width: "40",
      height: "40",
      viewBox: "0 0 68 68",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M0 18.1333C0 8.11857 8.11857 0 18.1333 0H49.8667C59.8814 0 68 8.11857 68 18.1333V49.8667C68 59.8814 59.8814 68 49.8667 68H18.1333C8.11857 68 0 59.8814 0 49.8667V18.1333Z",
            fill: "#0051FE"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: "2.2666",
            y: "2.26758",
            width: "63.4667",
            height: "63.4667",
            fill: "url(#pattern0_coinbase)"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "pattern",
            {
              id: "pattern0_coinbase",
              patternContentUnits: "objectBoundingBox",
              width: "1",
              height: "1",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { xlinkHref: "#image0_6070_1983", transform: "scale(0.00166667)" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "image",
            {
              id: "image0_6070_1983",
              width: "600",
              height: "600",
              xlinkHref: "data:image/png;base64,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"
            }
          )
        ] })
      ]
    }
  );
};
const coinbaseWalletConfig = {
  name: "Coinbase Wallet",
  logos: {
    default: /* @__PURE__ */ jsxRuntimeExports.jsx(CoinbaseWalletIcon, {}),
    transparent: /* @__PURE__ */ jsxRuntimeExports.jsx(CoinbaseWalletTransparentIcon, {})
  },
  downloadUrls: {
    default: "https://www.coinbase.com/wallet/downloads"
  },
  spinnerColor: void 0
};
function coinbaseWallet(props = {}) {
  const { connectorOptions, ...restProps } = props;
  return {
    ...coinbaseWalletConfig,
    id: "coinbaseWallet",
    walletType: "evm",
    showQRCode: false,
    isInstalled() {
      if (connectorOptions && "headlessMode" in connectorOptions && !connectorOptions.headlessMode) {
        return true;
      }
      return !!getProvider$1();
    },
    getDeepLink() {
      return `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(window.location.href)}`;
    },
    getUri() {
      return void 0;
    },
    getCreateConnectorFn() {
      const { metadata } = getEvmGlobalData();
      return coinbaseWallet$1({
        appName: metadata.name,
        headlessMode: true,
        overrideIsMetaMask: false,
        appLogoUrl: metadata == null ? void 0 : metadata.icon,
        ...connectorOptions
      });
    },
    ...restProps
  };
}
function getProvider$1() {
  if (typeof window === "undefined")
    return;
  return getEvmInjectedProvider("isCoinbaseWallet") || window.coinbaseWalletExtension;
}
function BscIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "28", height: "28", viewBox: "0 0 28 28", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0.5", y: "0.5", width: "27", height: "27", fill: "url(#BscIconPattern0)" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("pattern", { id: "BscIconPattern0", patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { xlinkHref: "#image0_2258_278", transform: "translate(0.0514019) scale(0.00934579)" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "image",
        {
          id: "image0_2258_278",
          width: "96",
          height: "107",
          xlinkHref: "data:image/png;base64,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"
        }
      )
    ] })
  ] });
}
function ComboIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "26", height: "26", viewBox: "0 0 26 26", fill: "none", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "26", height: "26", fill: "url(#ComboIconPattern0)" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "pattern",
        {
          id: "ComboIconPattern0",
          patternContentUnits: "objectBoundingBox",
          width: "1",
          height: "1",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { xlinkHref: "#image0_1252_60936", transform: "translate(0 0.066875) scale(0.00125)" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "image",
        {
          id: "image0_1252_60936",
          width: "800",
          height: "693",
          xlinkHref: "data:image/png;base64,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"
        }
      )
    ] })
  ] });
}
function EthereumIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: 24, height: 24, viewBox: "0 0 512 512", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "512", height: "512", rx: "15%", fill: "#ffffff" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#3C3C3B", d: "m256 362v107l131-185z" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#343434", d: "m256 41l131 218-131 78-132-78" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#8C8C8C", d: "m256 41v158l-132 60m0 25l132 78v107" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#141414", d: "m256 199v138l131-78" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#393939", d: "m124 259l132-60v138" })
  ] });
}
const chainDisplayConfigs = [
  {
    id: 1,
    name: "Ethereum",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(EthereumIcon, { width: 24, height: 24 })
  },
  {
    id: 56,
    name: "BSC",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(BscIcon, { width: 24, height: 24 })
  },
  {
    id: 97,
    name: "BSC Testnet",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(BscIcon, { width: 24, height: 24 })
  },
  {
    id: 91715,
    name: "Combo Testnet",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(ComboIcon, { width: 24, height: 24 })
  },
  {
    id: 204,
    name: "opBNB",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(BscIcon, { width: 24, height: 24 })
  },
  {
    id: 1017,
    name: "BNB Greenfield",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(BscIcon, { width: 24, height: 24 })
  },
  {
    id: 5600,
    name: "BNB Greenfield Testnet",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(BscIcon, { width: 24, height: 24 })
  },
  {
    id: 9e3,
    name: "BNB Greenfield Devnet",
    logo: /* @__PURE__ */ jsxRuntimeExports.jsx(BscIcon, { width: 24, height: 24 })
  }
];
function getChainDisplayConfigs() {
  return chainDisplayConfigs;
}
function defaultEvmConfig(params) {
  const {
    autoConnect = false,
    metadata = { name: "WalletKit" },
    walletConnectProjectId,
    initialChainId,
    wallets: wallets2,
    chains = [mainnet],
    chainDisplayConfigs: chainDisplayConfigs2 = getChainDisplayConfigs(),
    client: client2,
    ...restProps
  } = params;
  setEvmGlobalData({
    metadata,
    walletConnectProjectId
  });
  const transports = (params == null ? void 0 : params.transports) ?? Object.fromEntries(chains.map((chain) => [chain.id, http()]));
  const fns = getCreateConnectorFns(wallets2);
  const wagmiConfig = createConfig({
    multiInjectedProviderDiscovery: false,
    ...restProps,
    chains,
    connectors: fns,
    transports
  });
  wagmiConfig.connectors.forEach((connector) => {
    if (connector.id === "metaMaskSDK") {
      connector.id = metaMask().id;
    }
    if (connector.id === "coinbaseWalletSDK") {
      connector.id = coinbaseWallet().id;
    }
  });
  return {
    autoConnect,
    metadata,
    walletConnectProjectId,
    initialChainId,
    wallets: wallets2,
    chains,
    wagmiConfig,
    chainDisplayConfigs: chainDisplayConfigs2
  };
}
function getCreateConnectorFns(wallets2) {
  const fns = wallets2.map((w2) => {
    const fn = w2.getCreateConnectorFn();
    if (w2.isDisabled && typeof window !== "undefined") {
      localStorage.removeItem(`wagmi.${w2.id}.shimDisconnect`);
    }
    return fn;
  });
  createSingletonWalletConnect(wallets2, fns);
  return fns;
}
function createSingletonWalletConnect(wallets2, fns) {
  if (wallets2.find((w2) => isWalletConnect(w2.id))) {
    return;
  }
  const fn = walletConnect().getCreateConnectorFn();
  fns.push(fn);
}
const queryClient = new QueryClient();
const config = {
  options: {
    closeModalOnEsc: false
  },
  evmConfig: defaultEvmConfig({
    autoConnect: true,
    initialChainId: 1,
    walletConnectProjectId: "e68a1816d39726c2afabf05661a32767",
    wallets: [binanceWallet(), binanceWeb3Wallet(), metaMask(), trustWallet(), walletConnect()],
    chains: [mainnet]
  })
};
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WalletKitProvider, { config, debugMode: true, mode: "auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectButton, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectModal, {})
  ] }) });
}
function ConnectButton() {
  const { onOpen } = useConnectModal();
  const { address: address2 } = useAccount();
  const { disconnect: disconnect2 } = useDisconnect();
  if (address2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        "address:",
        address2
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => disconnect2(), children: "disconnect" })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => onOpen(), children: "connect" });
}
const global$1 = "";
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
export {
  EventEmitter$3 as E,
  __vitePreload as _,
  validate as a,
  getAugmentedNamespace as b,
  commonjsGlobal as c,
  bytesToHex$3 as d,
  bnExports as e,
  safeBufferExports as f,
  getDefaultExportFromCjs$1 as g,
  buffer as h,
  eventemitter3Exports$2 as i,
  dijkstraExports as j,
  require$$0$1 as r,
  sha256$4 as s,
  v4 as v
};
